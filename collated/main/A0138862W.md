# A0138862W
###### /resources/view/MainWindow.css
``` css
* {
    -fx-primary: #66D9EF; /* lightblue */
    -fx-secondary: #FD971F; /* orange */
    -fx-tertiary: #A6E22E; /* green */
    -fx-quaternary: #F92672; /* pink */
    -fx-quinary: #272822; /* black */
    -fx-quinary-alt: #1f201b;
    -fx-senary: #AE81FF; /* purple */
}
 
.table-view {
    -fx-base: #1d1d1d;
    -fx-control-inner-background: -fx-quinary;
    -fx-control-inner-background-alt: -fx-quinary-alt;
    -fx-background-color: -fx-quinary;
    -fx-table-cell-border-color: transparent;
    -fx-table-header-border-color: transparent;
    -fx-padding: 5;
}

.table-view .column-header-background {
    -fx-background-color: transparent;
}

.table-view .column-header, .table-view .filler {
    -fx-size: 35;
    -fx-border-insets: 0 10 1 0;
}

.table-view .column-header .label {
    -fx-font-size: 18px;
    -fx-font-family: "Verdana";
    -fx-text-fill: -fx-primary;
    -fx-alignment: center;
    -fx-opacity: 1;
}

.table-row-cell {
    -fx-cell-size: 55px;
}

.table-row-cell:selected {
   -fx-background-color: black;
   -fx-table-cell-border-color: black;
   -fx-border-width: 2px 2px 2px 2px;
   -fx-border-color: -fx-primary;
   -fx-border-style: dashed;
}

.text-field{
    -fx-background-color: #3f3f3f;
    -fx-font-size: 12pt;
    -fx-font-family: "Lucida Console";
    -fx-text-fill: -fx-primary;
    -fx-border-radius: 0 0 0 0;
    -fx-background-radius: 0 0 0 0;
}

.tab-pane .tab-header-area .headers-region,
.tab-pane .tab-header-area .tab-header-background{
    -fx-background-color: -fx-quinary;
}

.tab-pane .tab-header-area .tab{
    -fx-background-color: -fx-quinary;
}

.tab-pane .tab-header-area .tab-label{
    -fx-text-fill: lightGray;
    -fx-font-weight: bold;
    -fx-font-style: oblique;
}

.tab-pane .tab-header-area .tab:selected .tab-label{
    -fx-text-fill: -fx-primary;
    -fx-font-weight: bold;
}

.text-area,
.text-area .content{
    -fx-background-color: #1d1d1d;
    -fx-font-size: 12pt;
    -fx-font-family: "Lucida Console";
    -fx-text-fill: -fx-primary;
}

.list-view{
    -fx-background-color: #1d1d1d;
}

.label{
    -fx-text-fill: white;
    -fx-font-family: "Verdana";
    -fx-font-size: 12pt;
    -fx-font-weight: bold;
    -fx-padding: 15px;
    -fx-font-style: oblique;
}

.list-cell{
    -fx-cell-size: 50;
    -fx-padding: 10 5 10 15;
    -fx-background-color: -fx-quinary;
    -fx-text-fill: white;
}

.list-cell:filled:selected:focused{
    -fx-background-color: #1a1a1a;
}

.scroll-bar,
.scroll-bar .decrement-button,
.scroll-bar .increment-button{
    -fx-background-color: -fx-quinary;
}

.scroll-bar .thumb,
.scroll-bar .decrement-button > .decrement-arrow,
.scroll-bar .increment-button > .increment-arrow{
    -fx-background-color: -fx-primary;
}

.action-history-entry .title{
    -fx-text-fill: -fx-primary;
    -fx-font-weight: bold;
    -fx-font-size: 14px;
    -fx-font-style: normal;
    -fx-padding: 0px;
}

.action-history-entry .date{
    -fx-text-fill: -fx-primary;
    -fx-font-weight: normal;
    -fx-font-size: 10px;
    -fx-font-style: normal;
    -fx-padding: 0px;
}

.action-history-entry .description{
    -fx-text-fill: white;
    -fx-font-weight: normal;
    -fx-font-size: 12px;
    -fx-font-style: normal;
    -fx-padding: 0px;
}

.task-name-column{
    -fx-font-weight: bold;
    -fx-font-size: 18px;
}

.index-column{
    -fx-font-weight: bold;
    -fx-font-size: 16px;
    -fx-fill: white;
    -fx-font-style: oblique;
}

.pretty-date{
    -fx-font-weight:bold;
}

.ugly-date{
    -fx-font-size:10px;
}

.tag{
    -fx-background-color: -fx-primary;
    -fx-background-radius: 30;
    -fx-background-insets: 0;
    -fx-text-fill: -fx-quinary;
    -fx-font-size: 10px;
    -fx-font-weight: bold;
}

.tag-overdue{
    -fx-background-color: -fx-quaternary;
    -fx-background-radius: 30;
    -fx-background-insets: 0;
    -fx-text-fill: white;
    -fx-font-size: 8px;
    -fx-font-weight: bold;
}

.tag-happening{
    -fx-background-color: -fx-secondary;
    -fx-background-radius: 30;
    -fx-background-insets: 0;
    -fx-text-fill: black;
    -fx-font-size: 8px;
    -fx-font-weight: bold;
}

.tag-due-duration,
.tag-event-duration{
    -fx-background-color: darkGray;
    -fx-background-radius: 30;
    -fx-background-insets: 0;
    -fx-text-fill: black;
    -fx-font-size: 8px;
    -fx-font-weight: bold;
}

.normal{
    -fx-fill: -fx-tertiary;
}

.overdue{
    -fx-fill: -fx-quaternary;
}

.happening{
    -fx-fill: -fx-secondary;
}

.completed{
	-fx-fill: -fx-senary;
}

.titled-pane,
.titled-pane .title,
.titled-pane .content{
    -fx-background-color: #1d1d1d;
    -fx-border-color: #1d1d1d;
}

.titled-pane .title{
    -fx-border-width: 2px 0px 0px 0px;
    -fx-border-color: #3f3f3f;
    -fx-border-style: dashed;
}

.titled-pane > .title .text{
    -fx-fill: -fx-primary;
    -fx-font-family: "Lucida Console";
    -fx-font-style: oblique;
    -fx-font-weight: bold;
    
}

.titled-pane .title .arrow-button .arrow{
    -fx-background-color: -fx-primary;
}

.titled-pane .list-cell{
    -fx-background-color: #1d1d1d;
}
```
###### /resources/view/ActionHistoryEntry.fxml
``` fxml
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>

<HBox fx:id="actionHistoryEntry" maxHeight="-Infinity" maxWidth="1.7976931348623157E308" styleClass="action-history-entry" xmlns="http://javafx.com/javafx/8.0.101" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <VBox minWidth="200.0" prefWidth="200.0">
         <children>
            <Label fx:id="title" styleClass="title" text="TITLE" />
            <Label fx:id="date" styleClass="date" text="DATE" />
         </children>
      </VBox>
   </children>
</HBox>
```
###### /resources/view/MainWindow.fxml
``` fxml

<?import javafx.scene.control.ListView?>
<?import javafx.scene.control.Tab?>
<?import javafx.scene.control.TabPane?>
<?import javafx.scene.control.TableColumn?>
<?import javafx.scene.control.TableView?>
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.control.TitledPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="800.0" prefWidth="1280.0" styleClass="root" stylesheets="@MainWindow.css" xmlns="http://javafx.com/javafx/8.0.102" xmlns:fx="http://javafx.com/fxml/1" fx:controller="harmony.mastermind.ui.MainWindow">
    <children>
          <AnchorPane prefHeight="369.0" prefWidth="485.0" VBox.vgrow="ALWAYS">
              <children>
                  <BorderPane prefHeight="200.0" prefWidth="200.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                      <center>
                  <AnchorPane BorderPane.alignment="CENTER">
                     <children>
                                <TabPane fx:id="tabPane" prefHeight="200.0" prefWidth="200.0" tabClosingPolicy="UNAVAILABLE" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                    <tabs>
                                        <Tab fx:id="Home" text="Home">
                                            <content>
                                                <AnchorPane fx:id="homeTableViewPlaceholder" minHeight="0.0" minWidth="0.0" prefHeight="180.0" prefWidth="200.0"></AnchorPane>
                                            </content>
                                        </Tab>
                                        <Tab fx:id="Tasks" text="Tasks">
                                            <content>
                                                <AnchorPane fx:id="tasksTableViewPlaceholder" minHeight="0.0" minWidth="0.0" prefHeight="180.0" prefWidth="200.0"></AnchorPane>
                                            </content>
                                        </Tab>
                                        <Tab fx:id="Events" text="Events">
                                            <content>
                                                <AnchorPane fx:id="eventsTableViewPlaceholder" minHeight="0.0" minWidth="0.0" prefHeight="180.0" prefWidth="200.0"></AnchorPane>
                                            </content>
                                        </Tab>
                                        <Tab fx:id="Deadlines" text="Deadlines">
                                            <content>
                                                <AnchorPane  fx:id="deadlinesTableViewPlaceholder" minHeight="0.0" minWidth="0.0" prefHeight="180.0" prefWidth="200.0"></AnchorPane>
                                            </content>
                                        </Tab>
                                        <Tab fx:id="Archives" text="Archives">
                                            <content>
                                                <AnchorPane fx:id="archivesTableViewPlaceholder" minHeight="0.0" minWidth="0.0" prefHeight="180.0" prefWidth="200.0"></AnchorPane>
                                            </content>
                                        </Tab>
                                    </tabs>
                                </TabPane>
                     </children>
                  </AnchorPane>
                      </center>
               <bottom>
                  <AnchorPane BorderPane.alignment="CENTER">
                     <children>
                        <VBox maxHeight="300.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                           <children>
                              <AnchorPane fx:id="actionHistoryPanePlaceholder"></AnchorPane>
                              <AnchorPane fx:id="commandBoxPlaceholder"></AnchorPane>
                           </children>
                        </VBox>
                     </children>
                  </AnchorPane>
               </bottom>
                  </BorderPane>
              </children>
          </AnchorPane>
    </children>
</VBox>
```
###### /java/harmony/mastermind/commons/exceptions/TaskAlreadyMarkedException.java
``` java
/*
 * This exception is thrown when attempt to execute MarkCOmmand on a task that's already marked
 */
public class TaskAlreadyMarkedException extends Exception {

   
    public TaskAlreadyMarkedException(){
        super();
    }
}
```
###### /java/harmony/mastermind/commons/events/ui/ExecuteCommandEvent.java
``` java
public class ExecuteCommandEvent extends BaseEvent{

    public Date dateExecuted;
    public String title;
    public String description;
    
```
###### /java/harmony/mastermind/commons/events/ui/ExecuteCommandEvent.java
``` java
    public ExecuteCommandEvent(String title, String description){
        dateExecuted = new Date();
        
        this.title = title;
        this.description = description;
    }

```
###### /java/harmony/mastermind/commons/events/ui/ExecuteCommandEvent.java
``` java
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    
    

}
```
###### /java/harmony/mastermind/commons/events/ui/ToggleActionHistoryEvent.java
``` java
/**
 * 
 * This event is raised when the ActionHistoryCommand request to toggle the UI.
 *
 */
public class ToggleActionHistoryEvent extends BaseEvent{

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/harmony/mastermind/commons/events/ui/TabChangedEvent.java
``` java
public class TabChangedEvent extends BaseEvent {
    
    public final String fromTabId;
    public final String toTabId;
    
    public TabChangedEvent(String fromTabId, String toTabId){
        this.fromTabId = fromTabId;
        this.toTabId = toTabId;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/harmony/mastermind/commons/events/ui/HighlightLastActionedRowRequestEvent.java
``` java
/*
 * This event is raise when a command request UI to highlight the action row in the tableview
 * 
 */
public class HighlightLastActionedRowRequestEvent extends BaseEvent {

    public Task task;
    
    public HighlightLastActionedRowRequestEvent(Task task){
        this.task = task;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/harmony/mastermind/model/tag/UniqueTagList.java
``` java
    public String toString(){
        // functional way to transform list of items into concatenated string joining with commas (JAVA 8)
        return this.getInternalList().stream().map(Object::toString).collect(Collectors.joining(","));
    }
}
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    /*
     * push the command to the undo history.
     * @see harmony.mastermind.model.Model#pushToUndoHistory(harmony.mastermind.logic.commands.Undoable)
     */
    public void pushToUndoHistory(Undoable command) {
        undoHistory.push(command);
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    /** undo last action performed **/
    public CommandResult undo() throws EmptyStackException {
        CommandResult commandResult = undoHistory.pop().undo();
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return commandResult;
    }

    @Override
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    /*
     * push the command to the redo history. Should only be called after an undo operation
     * @see harmony.mastermind.model.Model#pushToRedoHistory(harmony.mastermind.logic.commands.Redoable)
     */
    public void pushToRedoHistory(Redoable command) {
        redoHistory.push(command);
    }

    @Override
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    /** redo the action that being undone function **/
    public CommandResult redo() throws EmptyStackException {
        CommandResult commandResult = redoHistory.pop().redo();
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return commandResult;
    }

    @Override
    /**
     * This method should only be called when the user entered a new command
     * other than redo/undo
     **/
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public void clearRedoHistory() {
        redoHistory.clear();
    }

```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** undo last action performed, throws EmptyStackException is there's no more action can be undone **/
    CommandResult undo() throws EmptyStackException;
    
```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** push the command to redo history */
    void pushToRedoHistory(Redoable command);
    
```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** undo last action performed, throws EmptyStackException is there's no more action can be undone **/
    CommandResult redo() throws EmptyStackException;
    
    /** empty redoHistory **/
    // required when a new command is entered, model should throw away all remaining commands in the redo history
    void clearRedoHistory();
    
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Returns filtered task list as an {@code ObervableList<Task>} */
    ObservableList<Task> getListToMark();

```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Search */
    void searchTask(String input);

```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    /*
     * Initialize through taskBuilder (preferred way)
     */
    protected Task(TaskBuilder taskBuilder){
        this.name = taskBuilder.getName();
        this.startDate = taskBuilder.getStartDate();
        this.endDate = taskBuilder.getEndDate();
        this.createdDate = taskBuilder.getCreatedDate();
        this.tags = taskBuilder.getTags();
        this.recur = taskBuilder.getRecur();
        this.isMarked = taskBuilder.isMarked();
    }
    
    // event
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public Task(String name, Date startDate, Date endDate, UniqueTagList tags, String recur, Date createdDate) {
        this.name = name;
        this.startDate = startDate;
        this.endDate = endDate;
        this.tags = tags;
        this.isMarked = false;
        this.recur = recur;
        this.createdDate = createdDate;
    }

    // deadline
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public Task(String name, Date endDate, UniqueTagList tags, String recur, Date createdDate) {
        this(name, null, endDate, tags, recur, createdDate);
    }

    // floating
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public Task(String name, UniqueTagList tags, Date createdDate) {
        this(name, null, null, tags, null, createdDate);
    }

```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getStartDate(), source.getEndDate(), source.getTags(), source.getRecur(), source.getCreatedDate());
        this.isMarked = source.isMarked();
    }

    @Override
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isFloating() {
        return startDate == null && endDate == null;
    }

    @Override
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isDeadline() {
        return startDate == null && endDate != null;
    }

    @Override
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isEvent() {
        return startDate != null && endDate != null;
    }

```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public Date getCreatedDate() {
        return createdDate;
    }

```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    /*
     * 
     * Check if the current task is due. Applies to only deadline & event
     * - deadline: true if and only if current date is after end date
     * - event: true if and only if current date is after end date & start date
     * 
     * @see harmony.mastermind.model.task.ReadOnlyTask#isDue()
     */
    public boolean isDue(){
        Date now = new Date();
        if (isDeadline() && now.after(endDate)) {
            return true;
        } else if (isEvent() && now.after(startDate) && now.after(endDate)){
            return true;
        } else {
            return false;
        }
    }

```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    /*
     * 
     * Check if current task is happening at the moment.
     * Only applies to event, where the current date falls between start & end date 
     * 
     * @see harmony.mastermind.model.task.ReadOnlyTask#isHappening()
     */
    public boolean isHappening(){
        Date now = new Date();
        if (isEvent() && now.after(startDate) && now.before(endDate)) {
            return true;
        } else {
            return false;   
        }
    }
    
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    /*
     * 
     * Calculate the duration of event. 
     * Applies to only event, return null otherwise.
     * 
     * @see harmony.mastermind.model.task.ReadOnlyTask#getEventDuration()
     */
    public Duration getEventDuration(){
        if(isEvent()){
            long differencel = endDate.getTime() - startDate.getTime();
            
            return Duration.of(differencel, ChronoUnit.MILLIS);
        }else{
            return null;
        }
    }
    
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    /*
     * calculate the duration until due date
     * Applies to only deadlines, return null otherwise.
     * 
     */
    public Duration getDueDuration(){
        if(endDate != null){
            long nowl = System.currentTimeMillis();
            long endDatel = endDate.getTime();
            
            long differencel = endDatel - nowl;
            
            return Duration.of(differencel, ChronoUnit.MILLIS);
        }else{
            return null;
        }
    }
}
```
###### /java/harmony/mastermind/model/task/TaskBuilder.java
``` java
import java.util.Date;
import java.util.Set;

import harmony.mastermind.commons.exceptions.IllegalValueException;
import harmony.mastermind.commons.exceptions.InvalidEventDateException;
import harmony.mastermind.model.tag.Tag;
import harmony.mastermind.model.tag.UniqueTagList;
import harmony.mastermind.model.tag.UniqueTagList.DuplicateTagException;

/**
 * The TaskBuilder is a safe way to create a task object instead of relying on constructors.
 * The Task has numerous attributes which depends on the nature of the task (event, floating, deadline),
 * it must be build independently.
 * <br/>
 * The task builder provide a systematic way to build a task object and is future proof.
 * Task Builder mitigates the problem of having too many parameters in Task constructor.
 *
 */
public class TaskBuilder {

    private final String name;
    private Date startDate;
    private Date endDate;
    private Date createdDate;
    private UniqueTagList tags;
    private String recur;
    private boolean isMarked;
    
    /**
     * creation date will automatically assigned upon initializing.
     * 
     * @param name is mandatory field. The task name.
     * 
     */
    public TaskBuilder(String name){
        this.name = name;
        this.createdDate = new Date();
    }
    
    /**
     * build a floating task with both start and end dates are null
     * 
     */
    public TaskBuilder asFloating(){
        startDate = null;
        endDate = null;
        return this;
    }
    
    /**
     * build an event with both valid start and end dates
     * 
     * @param startDate is the start date of the event
     * @param endDate is the end date of the event
     * 
     * @throws InvalidEventDateException if start date is after end date
     * 
     */
    public TaskBuilder asEvent(Date startDate, Date endDate) throws InvalidEventDateException{
        if (startDate.after(endDate)) {
            throw new InvalidEventDateException();
        }
        
        this.startDate = startDate;
        this.endDate = endDate;
        
        return this;
    }
    
    /**
     * build a deadline task with only end date
     * 
     *  @param endDate is the due date.
     * 
     */
    public TaskBuilder asDeadline(Date endDate){
        this.startDate = null;
        this.endDate = endDate;
        return this;
    }
    
    public TaskBuilder withTags(Set<String> tagSet) throws IllegalValueException {
        tags = new UniqueTagList(); 
        for (String tag: tagSet) {
            this.tags.add(new Tag(tag));
        }
        return this;
    }
    
    public TaskBuilder withTags(UniqueTagList tags) throws IllegalValueException {
        this.tags = tags; 
        return this;
    }
    
    /**
     * build a recurring task. 
     * 
     * @param recur can be daily, weekly, monthly, yearly
     * 
     */
    public TaskBuilder asRecurring(String recur){
        this.recur = recur;
        return this;
    }
    
    /**
     * Set a custom creation date. This will overwrite the auto assigned date.
     * 
     * @param createdDate is the customized creation date
     * 
     */
    public TaskBuilder withCreationDate(Date createdDate){
        this.createdDate = createdDate;
        return this;
    }
    
    /**
     * build a task as marked task
     * 
     */
    public TaskBuilder asMarked(){
        this.isMarked = true;
        return this;
    }
    
    
    /**
     * finalize build and return a Task object
     * 
     */
    public Task build(){
        return new Task(this);
    }

```
###### /java/harmony/mastermind/model/task/TaskListComparator.java
``` java
public class TaskListComparator implements Comparator<ReadOnlyTask> {

    /*
     * By default, compare by creation dates.
     * This comparator use for sorting table view so edit/delete will not add to the bottom of the list
     * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
     */
    @Override
    public int compare(ReadOnlyTask o1, ReadOnlyTask o2) {
        if(o1.getCreatedDate() == null || o2.getCreatedDate() == null){
            return 0;
        }
       
        if (o1.getCreatedDate().after(o2.getCreatedDate())) {
            return 1;
        } else if (o1.getCreatedDate().before(o2.getCreatedDate())) {
            return -1;
        } else {
            return 0;
        }                
    }
}
```
###### /java/harmony/mastermind/storage/XmlAdaptedTask.java
``` java
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName();
        createdDate = source.getCreatedDate();

        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }
```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    private Command prepareAdd(String args) {
        try {

            final Matcher matcher = AddCommand.COMMAND_ARGUMENTS_PATTERN.matcher(args.trim());

            // Validate user command input
            if (!matcher.matches()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_EXAMPLES));
            }
            
            // mandatory field                       
            // catch escaped name group if exists, otherwise use unescaped name group
            final String nameEscaped = matcher.group("nameEscaped");
            final String name = (nameEscaped != null)? nameEscaped: matcher.group("name");
            
            // at this point name variable should never be null because the regex only capture full match of mandatory components
            // check for bug in regex expression if the following throws assertion error
            assert name != null;

            // optionals
            final Optional<String> dates = Optional.ofNullable(matcher.group("dates"));
            final Optional<String> tags = Optional.ofNullable(matcher.group("tags"));
            final Optional<String> recur = Optional.ofNullable(matcher.group("recur"));
            
            // return internal value if present. else, return empty string
            final Set<String> tagSet = getTagsFromArgs(tags.map(val -> val).orElse(""));
            
            // after init every capturing groups, we start to build the command 
            AddCommand addCommand = buildAddCommand(name, dates, recur, tagSet);
            
            return addCommand;
        } catch (IllegalValueException | InvalidEventDateException e) {
            return new IncorrectCommand(e.getMessage());
        }
    }

```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    /**
     * Build the AddCommand
     * 
     * @param name is mandatory field
     * @param dates contain user input date string that has to be parsed by natural language processing library. Optional
     * @param recur contain recur input contain the keyword such as daily, weekly, monthly. Optional
     * @param tagSet unique set of tag string associated to the task
     * 
     * @throws IllegalValueException if tags contain non-alphanumeric value
     * @throws InvalidEventDateException if event start date is after end date
     */
    private AddCommand buildAddCommand(final String name, final Optional<String> dates, final Optional<String> recur, final Set<String> tagSet) throws IllegalValueException, InvalidEventDateException {
        AddCommandBuilder addCommandBuilder = new AddCommandBuilder(name);
        addCommandBuilder.withTags(tagSet);
        
        if(dates.isPresent()){
            PrettyTimeParser ptp = new PrettyTimeParser();
            List<DateGroup> parsedDates = ptp.parseSyntax(dates.get());
            
            if(!parsedDates.isEmpty()){
                recur.ifPresent(recurVal -> addCommandBuilder.asRecurring(recurVal));
                List<Date> startEndDates = parsedDates.get(0).getDates();
                
                /*
                 * We assume two conditions after parsing nlp dates:
                 * 1. Found only 1 date, then we assume it is a deadline
                 * 2. Found 2 dates, then we assume it is an event
                 */
                if(shouldParseAsDeadline(startEndDates)){
                    addCommandBuilder.asDeadline(startEndDates.get(0));
                }else if(shouldParseAsEvent(startEndDates)){
                    addCommandBuilder.asEvent(startEndDates.get(0), startEndDates.get(1));
                }
            }
        };
        return addCommandBuilder.build();
    }

```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    /*
     * Determine the date should be parse as deadline task
     */
    private boolean shouldParseAsDeadline(List<Date> dates){
        return dates.size() == 1;
    }
    
```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    /*
     * Determine the date should be parse as event task
     */
    private boolean shouldParseAsEvent(List<Date> dates){
        return dates.size() == 2;
    }
    
```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    /*
     * Extract the source destination string and prepare the Import ICS command. 
     * 
     */
    private Command prepareImport(String args){
        final Matcher matcher = ImportCommand.COMMAND_ARGUMENTS_PATTERN.matcher(args.trim());
        
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ImportCommand.MESSAGE_USAGE));
        }
        
        final String source = matcher.group("source");
        final String extension = matcher.group("extension");
        
        assert source != null;
        assert extension != null;
        
        return new ImportCommand(source, extension);
    }
    
    /**
     * Parses arguments in the context of the edit task command.
     * 
     * @param args
     *            full command args string
     * @return the prepared command
     */
```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    private Command prepareEdit(String args) {
        final Matcher matcher = EditCommand.COMMAND_ARGUMENTS_PATTERN.matcher(args.trim());
        
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        try {
            
            // mandatory
            // regex accept only numbers in index field, encountering NumberFormatException is impossible
            final int index = Integer.parseInt(matcher.group("index"));
            
            //optional
            final Optional<String> recur = Optional.ofNullable(matcher.group("recur"));
            final Optional<String> name = Optional.ofNullable(matcher.group("name"));
            final Optional<String> startDate = Optional.ofNullable(matcher.group("startDate"));
            final Optional<String> endDate = Optional.ofNullable(matcher.group("endDate"));
            final Optional<String> tags = Optional.ofNullable(matcher.group("tags"));
            
            Optional<Set<String>> tagSet = Optional.empty();
            if(tags.isPresent()){
                tagSet = Optional.ofNullable(getTagsFromArgs(tags.get()));
            };
            
            return new EditCommand(index, name, startDate, endDate, tagSet, recur);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (ParseException pe) {
            return new IncorrectCommand(pe.getMessage());
        }

    }
    
    private Command prepareExport(String args){
        final Matcher matcher = ExportCommand.COMMAND_ARGUMENTS_PATTERN.matcher(args.trim());
        
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ExportCommand.MESSAGE_EXAMPLE));
        }
        
        try {
            // mandatory
            final String destination = matcher.group("destination");
            
            // at this point destination variable should never be null because the regex only capture full match of mandatory components
            // check for bug in regex expression if the following throws assertion error
            assert destination != null;
            
            // capture all matched string if present
            final Optional<String> tasks = Optional.ofNullable(matcher.group("tasks"));
            final Optional<String> deadlines = Optional.ofNullable(matcher.group("deadlines"));
            final Optional<String> events = Optional.ofNullable(matcher.group("events"));
            final Optional<String> archives = Optional.ofNullable(matcher.group("archives"));
            
            if(isExportingAll(tasks, deadlines, events, archives)){
                return new ExportCommand(destination, true, true, true, true);
            }else{
                boolean isExportingTasks = tasks.isPresent();
                boolean isExportingDeadlines = deadlines.isPresent();
                boolean isExportingEvents = events.isPresent();
                boolean isExportingArchives = archives.isPresent();
                
                return new ExportCommand(destination, isExportingTasks, isExportingDeadlines, isExportingEvents, isExportingArchives);
            }
        } catch (IOException e) {
            return new IncorrectCommand(e.getMessage());
        }
    }
    
    /*
     * This method return true if user did not specify any categories to export,
     * then we assume user wants to export all categories.
     * eg: export to C:\User\Jim\Workspace\mastermind.csv
     */
    private boolean isExportingAll(Optional<String> tasks, Optional<String> deadlines, Optional<String> events, Optional<String> archives){
        return tasks.isPresent() == false &&
                deadlines.isPresent() == false &&
                events.isPresent() == false &&
                archives.isPresent() == false;
    }
    
```
###### /java/harmony/mastermind/logic/commands/Command.java
``` java
    /**
     * Raises an event to highlight the last action row in table
     * This event should be subscribed by UiManager to update the table
     * 
     * @param the row that contain the task that needs to be highlighted
     * 
     */
    protected void requestHighlightLastActionedRow(Task task){
        EventsCenter.getInstance().post(new HighlightLastActionedRowRequestEvent(task));
    }
    
}
```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
public class AddCommand extends Command implements Undoable, Redoable {
    private static final Logger logger = LogsCenter.getLogger(AddCommand.class);

    public static final String COMMAND_KEYWORD_ADD = "add";
    public static final String COMMAND_KEYWORD_DO = "do";
    
    // Better regex, support better NLP:
    // general form: add some task name from tomorrow 8pm to next friday 8pm daily #recurring,awesome
    // https://regex101.com/r/M2A3tB/8
    public static final String COMMAND_ARGUMENTS_REGEX = "(?='(?<nameEscaped>.+)'|(?<name>(?:(?:.(?!by|from|#)))+))"
                                                        + "(?:(?=.*(?:by|from)\\s(?<dates>(?:.(?!#|.*'))+)?))?"
                                                        + "(?:(?=.*(?<recur>daily|weekly|monthly|yearly)))?"
                                                        + "(?:(?=.*#(?<tags>.+)))?"
                                                        + ".*";

    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);
    
    public static final String COMMAND_DESCRIPTION = "Adding a task";

    public static final String COMMAND_FORMAT = "Floating Task: (add|do) <task_name> #[<comma_separated_tags>]\n"
                                                + "Deadline: (add|do) <task_name> by <end_date> [daily|weekly|monthly|yearly] #[comma_separated_tags]\n"
                                                + "Event: (add|do) <task_name> from <start_date> to <end_date> [daily|weekly|monthly|yearly] #[comma_separated_tags]";

    public static final String MESSAGE_EXAMPLE_EVENT = "add attend workshop from today 7pm to next monday 1pm #programming,java";
    public static final String MESSAGE_EXAMPLE_DEADLINE = "add submit homework by next sunday 11pm #math,physics";
    public static final String MESSAGE_EXAMPLE_FLOATING = "do chores #cleaning";
    public static final String MESSAGE_EXAMPLE_RECUR_DEADLINE = "add submit homework by next sunday 11pm weekly #math,physics";
    public static final String MESSAGE_EXAMPLE_RECUR_EVENT = "add attend workshop from today 7pm to next monday 1pm monthly #programming,java";
    
    public static final String MESSAGE_EXAMPLES = new StringBuilder()
                                                    .append("[Format]\n")
                                                    .append(COMMAND_FORMAT+ "\n\n")
                                                    .append("[Examples]:\n")
                                                    .append("Event: "+ MESSAGE_EXAMPLE_EVENT+"\n")
                                                    .append("Deadline: "+MESSAGE_EXAMPLE_DEADLINE+"\n")
                                                    .append("Floating: "+MESSAGE_EXAMPLE_FLOATING+"\n")
                                                    .append("Recurring Deadline: "+MESSAGE_EXAMPLE_RECUR_DEADLINE+"\n")
                                                    .append("Recurring Event: "+MESSAGE_EXAMPLE_RECUR_EVENT+"\n")
                                                    .toString();

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_UNDO_SUCCESS = "[Undo Add Command] Task deleted: %1$s";
    public static final String MESSAGE_REDO_SUCCESS = "[Redo Add Command] Task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in Mastermind";

    private final Task toAdd;
    

    private static final String TASK = "Task";
    private static final String DEADLINE = "Deadline";
    private static final String EVENT = "Event";
    
    static GenericMemory task; 
    static GenericMemory deadline; 
    static GenericMemory event;

```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    /**
     * Build the AddCommand using addCommandBuilder. 
     * Depending on the builder attributes, the taskBuilder will return the appropriate event/floating/deadline task. 
     * 
     * @param addCommandBuilder to build the command safely
     * 
     */
    protected AddCommand(AddCommandBuilder addCommandBuilder) throws IllegalValueException, InvalidEventDateException{
        TaskBuilder taskBuilder = new TaskBuilder(addCommandBuilder.getName());
        taskBuilder.withTags(addCommandBuilder.getTags());
        
        if(addCommandBuilder.isDeadline()){
            taskBuilder.asDeadline(addCommandBuilder.getEndDate());
        }else if(addCommandBuilder.isEvent()){
            taskBuilder.asEvent(addCommandBuilder.getStartDate(), addCommandBuilder.getEndDate());
        }
        
        if(addCommandBuilder.isRecurring()){
            taskBuilder.asRecurring(addCommandBuilder.getRecur());
        }
        
        toAdd = taskBuilder.build();
        
        Parser.mem.add(new GenericMemory(toAdd.getTags().toString(), toAdd.getName(), ""));        
    }

    @Override
```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public CommandResult execute() {
        assert model != null;
        try {
            executeAdd();
            
            model.pushToUndoHistory(this);
            
            // this is a new command entered by user (not undo/redo)
            // need to clear the redoHistory Stack 
            model.clearRedoHistory();
            
            requestHighlightLastActionedRow(toAdd);

            return new CommandResult(COMMAND_KEYWORD_ADD,String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(COMMAND_KEYWORD_ADD,MESSAGE_DUPLICATE_TASK);
        }

    }

```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    /** action to perform when ModelManager requested to undo this command **/
    @Override
    public CommandResult undo() {
        try {
            model.deleteTask(toAdd);
            
            model.pushToRedoHistory(this);
            
            logger.info("Task undo" + toAdd.getName());

            return new CommandResult(COMMAND_KEYWORD_ADD,String.format(MESSAGE_UNDO_SUCCESS, toAdd));
        } catch (UniqueTaskList.TaskNotFoundException pne) {
            return new CommandResult(COMMAND_KEYWORD_ADD,Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        }
    }
    
```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    /** action to perform when ModelManager requested to redo this command**/
    @Override
    public CommandResult redo() {
        assert model != null;
        try {
            executeAdd();
            
            model.pushToUndoHistory(this);
            
            requestHighlightLastActionedRow(toAdd);
            
            logger.info("Task redo" + toAdd.getName());

            return new CommandResult(COMMAND_KEYWORD_ADD,String.format(MESSAGE_REDO_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(COMMAND_KEYWORD_ADD,MESSAGE_DUPLICATE_TASK);
        }        
    }
    
    
```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    /** extract method since it's reusable for execute() and redo()**/
    private void executeAdd() throws DuplicateTaskException {
        model.addTask(toAdd);
    }
    
```
###### /java/harmony/mastermind/logic/commands/RedoCommand.java
``` java
    public CommandResult execute() {

        try{
            // All Command supports undo operation must implement Redoable interface
            
            // execute the redo strategy implemented by the underlying command
            CommandResult redoResult = model.redo();
            
            // display successful message and the details of the undo operations
            return new CommandResult(COMMAND_WORD, 
                    MESSAGE_SUCCESS + "\n" +
                    "=====Redo Details=====\n" +
                    redoResult.feedbackToUser + "\n"+
                    "==================");
        }catch(EmptyStackException ex){
            return new CommandResult(COMMAND_WORD, MESSAGE_EMPTY_COMMAND_HISTORY);
        }
    }

}
```
###### /java/harmony/mastermind/logic/commands/Undoable.java
``` java
public interface Undoable {

    /**
     * Specify the undo strategy according to the nature of the corresponding class.
     * For example, to implement an undo operation on AddCommand, a delete operation should be implemented.
     * Similarly, a DeleteCommand should implement a add operation to restore the record.
     * 
     * @return CommandResult, the Object contains details & feedback about the undo operation.
     */
```
###### /java/harmony/mastermind/logic/commands/Undoable.java
``` java
    public CommandResult undo();
    
}
```
###### /java/harmony/mastermind/logic/commands/MarkCommand.java
``` java
    @Override
    /*
     * Strategy to undo mark command
     * 
     * @see harmony.mastermind.logic.commands.Undoable#undo()
     */
    public CommandResult undo() {
        try {
            
            for (Task t:tasksToMark) {
                model.unmarkTask(t);

                requestHighlightLastActionedRow(t);                
            }
            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNDO_SUCCESS, tasksToMark.get(0)));
        } catch (DuplicateTaskException dte) {
            return new CommandResult(COMMAND_WORD, String.format(UnmarkCommand.MESSAGE_DUPLICATE_UNMARK_TASK, tasksToMark.get(0)));
        } catch (ArchiveTaskList.TaskNotFoundException tnfe) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

```
###### /java/harmony/mastermind/logic/commands/MarkCommand.java
``` java
    @Override
    /*
     * Strategy to redo mark command
     * 
     * @see harmony.mastermind.logic.commands.Redoable#redo()
     */
    public CommandResult redo() {
        try {
            executeMark();

            model.pushToUndoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_REDO_SUCCESS, tasksToMark.get(0)));

        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(COMMAND_WORD,Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        } catch (DuplicateTaskException | NotRecurringTaskException e) {
            return new CommandResult(COMMAND_WORD,MESSAGE_MARK_RECURRING_FAILURE);
        }
    }

```
###### /java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
public class ExportCommand extends Command {

    public static final String COMMAND_KEYWORD_EXPORT = "export";

    public static final String COMMAND_ARGUMENTS_REGEX = "(?:(?=.*(?<tasks>tasks)))?"
                                                         + "(?:(?=.*(?<deadlines>deadlines)))?"
                                                         + "(?:(?=.*(?<events>events)))?"
                                                         + "(?:(?=.*(?<archives>archives)))?"
                                                         + ".*to "
                                                         + "(?<destination>.+)";

    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);

    public static final String COMMAND_FORMAT = "export [tasks] [deadlines] [events] [archives] to <destination>";
    
    public static final String COMMAND_DESCRIPTION = "Export to desired format";

    public static final String MESSAGE_EXAMPLE = "export tasks deadlines to C:\\Desktop\\mastermind.csv";

    public static final String MESSAGE_SUCCESS = "CSV exported.";
    
    public static final String MESSAGE_FAILURE = "Failed to export CSV.";

    private static final String NEWLINE_CHARACTER = "\n";

    private static final Object[] GOOGLE_CALENDAR_HEADER = { "Subject", "Start Date", "Start Time", "End Date", "End Time", "All Day Event", "Description", "Location", "Private" };

    private static final SimpleDateFormat GOOGLE_CALENDAR_DATE_FORMAT = new SimpleDateFormat("MM/dd/yyyy");

    private static final SimpleDateFormat GOOGLE_CALENDAR_TIME_FORMAT = new SimpleDateFormat("HH:mm");

    private final String destination;

    private final boolean isExportingTasks;

    private final boolean isExportingDeadlines;

    private final boolean isExportingEvents;

    private final boolean isExportingArchives;

```
###### /java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    /**
     * Create a ExportCommand
     * 
     * @param destination the file output destination
     * @param isExportingTasks whether to export all floating tasks
     * @param isExportingDeadlines whether to export all deadlines
     * @param isExportingEvents whether to export all events
     * @param isExportingArchives whether to export all archives
     * @throws IOException if destination file path is invalid
     */
    public ExportCommand(String destination, boolean isExportingTasks, boolean isExportingDeadlines, boolean isExportingEvents, boolean isExportingArchives) throws IOException {
        this.destination = destination;
        this.isExportingTasks = isExportingTasks;
        this.isExportingDeadlines = isExportingDeadlines;
        this.isExportingEvents = isExportingEvents;
        this.isExportingArchives = isExportingArchives;
    }

```
###### /java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    @Override
    public CommandResult execute() {

        CSVFormat csvFormat = CSVFormat.EXCEL;

        try (FileWriter fileWriter = new FileWriter(destination); CSVPrinter csvPrinter = new CSVPrinter(fileWriter, csvFormat);) {
            printHeader(csvPrinter);
            printTasks(csvPrinter);
            printDeadlines(csvPrinter);
            printEvents(csvPrinter);
            printArchives(csvPrinter);
            return new CommandResult(COMMAND_KEYWORD_EXPORT, MESSAGE_SUCCESS);
        } catch (IOException e) {
            return new CommandResult(COMMAND_KEYWORD_EXPORT, MESSAGE_FAILURE);
        }
    }

```
###### /java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    private void printHeader(CSVPrinter csvPrinter) throws IOException {
        csvPrinter.printRecord(GOOGLE_CALENDAR_HEADER);
    }

```
###### /java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    private void printTasks(CSVPrinter csvPrinter) throws IOException {
        if (isExportingTasks) {
            UnmodifiableObservableList<ReadOnlyTask> tasks = model.getFilteredFloatingTaskList();
            printDataBody(csvPrinter, tasks);
        }
    }
    
```
###### /java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    private void printDeadlines(CSVPrinter csvPrinter) throws IOException{
        if(isExportingDeadlines){
            UnmodifiableObservableList<ReadOnlyTask> deadlines = model.getFilteredDeadlineList();
            printDataBody(csvPrinter, deadlines);
        }
    }
    
```
###### /java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    private void printEvents(CSVPrinter csvPrinter) throws IOException{
        if(isExportingEvents){
            UnmodifiableObservableList<ReadOnlyTask> events = model.getFilteredEventList();
            printDataBody(csvPrinter, events);
        }
    }

```
###### /java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    private void printArchives(CSVPrinter csvPrinter) throws IOException{
        if(isExportingArchives){
            UnmodifiableObservableList<ReadOnlyTask> archives = model.getFilteredArchiveList();
            printDataBody(csvPrinter, archives);
        }
    }

```
###### /java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    /**
     * A helper method to print list of tasks into csv.
     * Due to the limitation of Google Calendar (must specify start and end date):
     * 
     * - Floating tasks are assigned with dummy date (exported date) as their start and end date, in addition set the all day event as true.
     * - Deadlines will share the same start and end dates
     * - Event will and distinct start and end dates
     * 
     * All tags are exported under descriptions
     * 
     * @param csvPrinter CSVPrinter object
     * @param tasks list of tasks to print
     * @throws IOException if file is not writable
     */
    private void printDataBody(CSVPrinter csvPrinter, UnmodifiableObservableList<ReadOnlyTask> tasks) throws IOException {
        for (ReadOnlyTask task : tasks) {
            List<Object> data = new ArrayList<>();
            data.add(task.getName());
            if(task.isFloating()){
                Date dummyDate = new Date();
                data.add(GOOGLE_CALENDAR_DATE_FORMAT.format(dummyDate));
                data.add(GOOGLE_CALENDAR_TIME_FORMAT.format(dummyDate));
                data.add(GOOGLE_CALENDAR_DATE_FORMAT.format(dummyDate));
                data.add(GOOGLE_CALENDAR_TIME_FORMAT.format(dummyDate));
            } else if (task.isDeadline()){
                data.add(GOOGLE_CALENDAR_DATE_FORMAT.format(task.getEndDate()));
                data.add(GOOGLE_CALENDAR_TIME_FORMAT.format(task.getEndDate()));
                data.add(GOOGLE_CALENDAR_DATE_FORMAT.format(task.getEndDate()));
                data.add(GOOGLE_CALENDAR_TIME_FORMAT.format(task.getEndDate()));
            } else if (task.isEvent()){
                data.add(GOOGLE_CALENDAR_DATE_FORMAT.format(task.getStartDate()));
                data.add(GOOGLE_CALENDAR_TIME_FORMAT.format(task.getStartDate()));
                data.add(GOOGLE_CALENDAR_DATE_FORMAT.format(task.getEndDate()));
                data.add(GOOGLE_CALENDAR_TIME_FORMAT.format(task.getEndDate()));
            }
            data.add((task.isFloating())? "TRUE": "FALSE");
            data.add(task.getTags().toString().replaceAll(",", " "));
            data.add(null);
            data.add("TRUE");
            csvPrinter.printRecord(data);
        }
    }

}
```
###### /java/harmony/mastermind/logic/commands/HistoryCommand.java
``` java
/**
 * 
 * Command to toggle ActionHistory in UI
 * 
 * This command takes no parameter.
 * @author kfwong
 *
 */
public class HistoryCommand extends Command {

    public static final String COMMAND_KEYWORD_ACTIONHISTORY = "history";
    public static final String COMMAND_DESCRIPTION = "Toggles action history bar";

    public static final String MESSAGE_SUCCESS = "Action history toggled.";

    @Override
    public CommandResult execute() {

        requestToggleActionHistory();
        return new CommandResult(COMMAND_KEYWORD_ACTIONHISTORY, MESSAGE_SUCCESS);

    }

    private void requestToggleActionHistory() {
        EventsCenter.getInstance().post(new ToggleActionHistoryEvent());
    }

}
```
###### /java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    public static final String COMMAND_ARGUMENTS_REGEX = "(?=(?<index>\\d+))"
                                                        + "(?:(?=.*name to (?:(?<name>.+?)(?:,|$|\\R))?))?"
                                                        + "(?:(?=.*start date to (?:(?<startDate>.+?)(?:,|$|\\R))?))?"
                                                        + "(?:(?=.*end date to (?:(?<endDate>.+?)(?:,|$|\\R))?))?"
                                                        + "(?:(?=.*tags to #(?:(?<tags>.+?)(?:\\s|,\\s|$|,$|\\R))?))?"
                                                        + "(?:(?=.*recur (?<recur>daily|weekly|monthly|yearly)(?:,|$|\\R)))?"
                                                        + ".+";


    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);

    public static final String COMMAND_FORMAT = "(edit|update|change) <index> [name to <name>,] [start date to <start_date>,] [end date to <end_date>,] [recur (daily|weekly|monthly|yearly),] [tags to #<comma_separated_tags>,]";

    public static final String MESSAGE_USAGE = COMMAND_FORMAT
                                               + "\n"
                                               + "Edits the task identified by the index number used in the last task listing.\n"
                                               + "Example: \n"
                                               + "edit 2 name to parents with dinner, end date to tomorrow 7pm, recur daily, tags to #meal,family";

    public static final String MESSAGE_EDIT_TASK_PROMPT = "Edit the following task: %1$s";

    public static final String MESSAGE_UNDO_SUCCESS = "[Undo Edit Command] Task reverted: %1$s";
    public static final String MESSAGE_REDO_SUCCESS = "[Redo Edit Command] Edit the following task: %1$s";
    
    public static final String COMMAND_DESCRIPTION = "Editing a task";

    // private MainWindow window;
    private ReadOnlyTask originalTask;
    private Task editedTask;

    private final int targetIndex;
    private Optional<String> name;
    private Optional<String> startDate;
    private Optional<String> endDate;
    private Optional<String> recur;
    private Optional<Set<String>> tags;
```
###### /java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    /*
     * Strategy implementation to undo the edit command
     * @see harmony.mastermind.logic.commands.Undoable#undo()
     */
    public CommandResult undo() {

        try {
            model.deleteTask(editedTask);

            // add back the original task
            model.addTask((Task) originalTask);

            model.pushToRedoHistory(this);
            
            requestHighlightLastActionedRow((Task)originalTask);

            return new CommandResult(COMMAND_KEYWORD_EDIT, String.format(MESSAGE_UNDO_SUCCESS, originalTask));
        } catch (UniqueTaskList.TaskNotFoundException pne) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, AddCommand.MESSAGE_DUPLICATE_TASK);
        }
    }

    @Override
```
###### /java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    /*
     * Strategy implementation to redo the edit command
     * 
     * @see harmony.mastermind.logic.commands.Redoable#redo()
     */
    public CommandResult redo() {

        try {
            executeEdit();

            model.pushToUndoHistory(this);
            
            requestHighlightLastActionedRow(editedTask);

            return new CommandResult(COMMAND_KEYWORD_EDIT, String.format(MESSAGE_REDO_SUCCESS, originalTask));
        } catch (TaskNotFoundException | IndexOutOfBoundsException ie) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        } catch (IllegalValueException e){
            return new CommandResult(COMMAND_KEYWORD_EDIT, Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        } catch (InvalidEventDateException e){
            return new CommandResult(COMMAND_KEYWORD_EDIT, Messages.MESSAGE_INVALID_DATE);
        }
    }

```
###### /java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    private void executeEdit() throws TaskNotFoundException, IndexOutOfBoundsException, InvalidEventDateException, IllegalValueException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new IndexOutOfBoundsException();
        }

        if (originalTask == null) {
            originalTask = lastShownList.get(targetIndex - 1);
        }

        // parsing inputs
        // if user provides explicit field and value, we change them
        // otherwise, all omitted field are taken from the original
        String toEditName = name.map(val -> val).orElse(originalTask.getName());
        Date toEditStartDate = startDate.map(val -> prettyTimeParser.parse(val).get(0)).orElse(originalTask.getStartDate());
        Date toEditEndDate = endDate.map(val -> prettyTimeParser.parse(val).get(0)).orElse(originalTask.getEndDate());
        String toEditRecur = recur.map(val -> val).orElse(originalTask.getRecur());
        UniqueTagList toEditTags = new UniqueTagList(tags.map(val -> {
            final Set<Tag> tagSet = new HashSet<>();
            for (String tagName : val) {
                try {
                    tagSet.add(new Tag(tagName));
                } catch (IllegalValueException e) {
                    e.printStackTrace();
                }
            }
            return tagSet;
        }).orElse(originalTask.getTags().toSet()));
        Date toEditCreatedDate = originalTask.getCreatedDate();
        

        // initialize the new task with edited values
        editedTask = buildEditedTask(toEditName, toEditStartDate, toEditEndDate, toEditRecur, toEditTags, toEditCreatedDate);

        model.deleteTask(originalTask);
        model.addTask(editedTask);
    }

```
###### /java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    /**
     * Attempt to build a task based on edited value. 
     * If this command has build it before, it'll simply return the previous instance.
     * 
     * @param toEditName The edited name
     * @param toEditStartDate the edited start date
     * @param toEditEndDate edited end date
     * @param toEditRecur recurring keyword
     * @param toEditTags tags
     * @param toEditCreatedDate custom creation date
     * @return
     * @throws IllegalValueException if tags are not alphanumeric
     * @throws InvalidEventDateException if start date is after end date
     */
    private Task buildEditedTask(String toEditName, Date toEditStartDate, Date toEditEndDate, String toEditRecur, UniqueTagList toEditTags, Date toEditCreatedDate) throws IllegalValueException, InvalidEventDateException {
        if (editedTask == null) {                    
            TaskBuilder taskBuilder = new TaskBuilder(toEditName);
            taskBuilder.withCreationDate(toEditCreatedDate);
            taskBuilder.withTags(toEditTags);
            taskBuilder.asRecurring(toEditRecur);
            
            if (isEvent(toEditStartDate, toEditEndDate)){
                taskBuilder.asEvent(toEditStartDate,toEditEndDate);
            } else if (isDeadline(toEditStartDate, toEditEndDate)){
                taskBuilder.asDeadline(toEditEndDate);
            } else if (isFloating(toEditStartDate, toEditEndDate)){
                taskBuilder.asFloating();
            }
            editedTask = taskBuilder.build();
        }
        
        return editedTask;
    }
```
###### /java/harmony/mastermind/logic/commands/DeleteCommand.java
``` java
    /** action to perform when ModelManager requested to undo this delete command **/
    public CommandResult undo() {
        try {
            model.addTask((Task) toDelete);

            model.pushToRedoHistory(this);
            
            requestHighlightLastActionedRow((Task) toDelete);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNDO_SUCCESS, toDelete));
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_WORD, AddCommand.MESSAGE_DUPLICATE_TASK);
        }
    }

    @Override
```
###### /java/harmony/mastermind/logic/commands/DeleteCommand.java
``` java
    /** action to perform when ModelManager requested to redo this delete command **/
    public CommandResult redo() {
        try {
            executeDelete();
            
            model.pushToUndoHistory(this);

        } catch (TaskNotFoundException | IndexOutOfBoundsException | ArchiveTaskList.TaskNotFoundException tnfe) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        return new CommandResult(COMMAND_WORD, String.format(MESSAGE_REDO_SUCCESS, toDelete));
    }

    private void executeDelete() throws TaskNotFoundException, IndexOutOfBoundsException, ArchiveTaskList.TaskNotFoundException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getCurrentList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new IndexOutOfBoundsException();
        }

        if (toDelete == null) {
            toDelete = lastShownList.get(targetIndex - 1);
            deleteDirectly(toDelete.toString(), memory);
        }

        if (toDelete.isMarked()) {
            model.deleteArchive(toDelete);
        }else {
            model.deleteTask(toDelete);
        }
    }
    
```
###### /java/harmony/mastermind/logic/commands/Redoable.java
``` java
public interface Redoable {
    /**
     * Specify the redo strategy according to the nature of the corresponding class.
     * 
     * @return CommandResult, the Object contains details & feedback about the redo operation.
     */
    public CommandResult redo();
}
```
###### /java/harmony/mastermind/logic/commands/UndoCommand.java
``` java
public class UndoCommand extends Command{
    
    public static final String COMMAND_WORD = "undo";
    
    public static final String MESSAGE_SUCCESS = "Undo successfully.";
    public static final String MESSAGE_EMPTY_COMMAND_HISTORY = "There's no more action available to undo.";
    public static final String MESSAGE_COMMAND_NOT_UNDOABLE = "This command is not undoable";
    public static final String COMMAND_DESCRIPTION = "Undo an action";

    @Override
```
###### /java/harmony/mastermind/logic/commands/UndoCommand.java
``` java
    public CommandResult execute() {

        try{
            // All Command supports undo operation must implement Undoable interface
            
            // execute the undo strategy implemented by the underlying command
            CommandResult undoResult = model.undo();
            
            // display successful message and the details of the undo operations
            return new CommandResult(COMMAND_WORD, 
                    MESSAGE_SUCCESS + "\n" +
                    "=====Undo Details=====\n" +
                    undoResult.feedbackToUser + "\n"+
                    "==================");
        }catch(EmptyStackException ex){
            return new CommandResult(COMMAND_WORD, MESSAGE_EMPTY_COMMAND_HISTORY);
        }
    }
    
    

}

```
###### /java/harmony/mastermind/logic/commands/AddCommandBuilder.java
``` java
/*
 * AddCommandBuilder provides a safe way to create an AddCommand
 * 
 */
public class AddCommandBuilder {
    public String name;
    public Date startDate;
    public Date endDate;
    public Set<String> tags;
    public String recur;

    public AddCommandBuilder(String name) {
        this.name = name;
    }

    public AddCommandBuilder asEvent(Date startDate, Date endDate) throws InvalidEventDateException{
        if (startDate.after(endDate)) {
            throw new InvalidEventDateException();
        }
        
        this.startDate = startDate;
        this.endDate = endDate;
        return this;
    }

    public AddCommandBuilder asDeadline(Date endDate) {
        this.startDate = null;
        this.endDate = endDate;
        return this;
    }

    public AddCommandBuilder withTags(Set<String> tags) throws IllegalValueException {
        this.tags = tags;
        return this;
    }

    public AddCommandBuilder asRecurring(String recur) {
        this.recur = recur;
        return this;
    }

    public AddCommand build() throws IllegalValueException, InvalidEventDateException {
        return new AddCommand(this);
    }

    public boolean isFloating() {
        return startDate == null
               && endDate == null;
    }

    public boolean isDeadline() {
        return startDate == null
               && endDate != null;
    }

    public boolean isEvent() {
        return startDate != null
               && endDate != null;
    }

    public boolean isRecurring() {
        return this.recur != null;
    }

    public String getName() {
        return name;
    }

    public Date getStartDate() {
        return startDate;
    }

    public Date getEndDate() {
        return endDate;
    }

    public Set<String> getTags() {
        return tags;
    }

    public String getRecur() {
        return recur;
    }

}
```
###### /java/harmony/mastermind/logic/commands/ImportCommand.java
``` java
/**
 * Reads either ics/csv file and import the tasks into Mastermind
 */
public class ImportCommand extends Command {
    private static final int HEADER_LINE = 1;
    private static final int INDEX_NAME = 0;
    private static final int INDEX_START_DATE = 1;
    private static final int INDEX_START_TIME = 2;
    private static final int INDEX_END_DATE = 3;
    private static final int INDEX_END_TIME = 4;

    public static final String COMMAND_WORD = "import";

    public static final String MESSAGE_USAGE = COMMAND_WORD
                                               + ": Reads file and add all task from file into Mastermind\n"
                                               + "Parameters: File location\n"
                                               + "Example:\n"
                                               + "for Mac:\n"
                                               + COMMAND_WORD + "from"
                                               + " Users/Jim/Desktop/jim@gmail.com.ics\n"
                                               + "for Windows:\n"
                                               + COMMAND_WORD + "from"
                                               + " C:\\Users\\Jim\\jim@gmail.com.ics";

    public static final String COMMAND_ARGUMENTS_REGEX = "from (?<source>.+)(?<=(?<extension>txt|csv|ics))";
    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);
    
    public static final String MESSAGE_READ_SUCCESS = "Read success on imported file";
    public static final String MESSAGE_READ_FAILURE = "Invalid file path: %1$s";
    public static final String MESSAGE_CSV_READ_FAILURE = "Header in csv File is invalid\n" 
                                                            + "First row of your csv file should include headers "
                                                            + "like Subject, Start Date, Start Time, End Date, End Time";
    public static final String MESSAGE_IMPORT_TXT_SUCCESS = "Import success: %1$s tasks added";
    public static final String MESSAGE_IMPORT_TXT_FAILURE = "Import failure: %1$s tasks added \nInvalid lines: %2$s";
    public static final String MESSAGE_IMPORT_ICS_SUCCESS = "Import ics success.";
    public static final String MESSAGE_IMPORT_ICS_FAILURE = "Failed to import ics.";
    
    public static final String MESSAGE_FAILURE_DUPLICATE_TASK = "Failed to import ics. Duplicate task detected when importing.";

    public static final String COMMAND_FORMAT = "import <File Location>";
    public static final String COMMAND_DESCRIPTION = "Reads file and add all task from file into Mastermind";

    public static final String HEADER_NAME = "Subject";
    public static final String HEADER_START_DATE = "Start Date";
    public static final String HEADER_START_TIME = "Start Time";
    public static final String HEADER_END_DATE = "End Date";
    public static final String HEADER_END_TIME = "End Time";
    
    
    public static final String EXT_CSV = "csv";
    public static final String EXT_ICS = "ics";
    
    public static final String REGEX_COMMA = ",";
    
    public static final String EMPTY_ARG = "";
    
    private String fileToImport;
    private String extension;
    private ArrayList<String> lstOfCmd;

```
###### /java/harmony/mastermind/logic/commands/ImportCommand.java
``` java
    private CommandResult importIcsFile() {

        try (FileInputStream fis = new FileInputStream(fileToImport)){
            ICalendar ical = Biweekly.parse(fis).first();

            for (VEvent event : ical.getEvents()) {
                Task task = parseTask(event);
                model.addTask(task);
            }

            return new CommandResult(COMMAND_WORD, MESSAGE_IMPORT_ICS_SUCCESS);
        } catch (DuplicateTaskException e){
            return new CommandResult(COMMAND_WORD, MESSAGE_FAILURE_DUPLICATE_TASK);
        } catch (InvalidEventDateException | IOException | IllegalValueException e) {
            return new CommandResult(COMMAND_WORD, MESSAGE_IMPORT_ICS_FAILURE);
        }
    }
    
    /**
     * This method will attempt to parse a ical's VEvent to a Mastermind Task Object
     * 
     * @param event The ical VEvent Object to parse
     * @return the parsed Task object
     * @throws InvalidEventDateException if start date is after end date
     * @throws IllegalValueException if tags contains non-alphanumeric characters
     */
    private Task parseTask(VEvent event) throws InvalidEventDateException, IllegalValueException {
        Set<String> tags = new HashSet<String>();
        tags.add("ICALIMPORT");
        
        TaskBuilder taskBuilder = new TaskBuilder(event.getSummary().getValue());
        taskBuilder.asEvent(event.getDateStart().getValue(), event.getDateEnd().getValue());
        taskBuilder.withTags(tags);
        
        return taskBuilder.build();
    }
    

}
```
###### /java/harmony/mastermind/logic/commands/UnmarkCommand.java
``` java
    @Override
    /*
     * Strategy to undo unmark command
     * 
     * @see harmony.mastermind.logic.commands.Undoable#undo()
     */
    public CommandResult undo() {
        try {
            // remove the task that's previously added.
            model.markTask(taskToUnmark);
            
            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNDO_SUCCESS, taskToUnmark));
        } catch (UniqueTaskList.TaskNotFoundException e) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        }
    }

    @Override
```
###### /java/harmony/mastermind/logic/commands/UnmarkCommand.java
``` java
    /*
     * 
     * Strategy to redo unmark command
     * 
     * @see harmony.mastermind.logic.commands.Redoable#redo()
     */
    public CommandResult redo() {
        try {
            executeUnmark();
            
            model.pushToUndoHistory(this);
            
            requestHighlightLastActionedRow(taskToUnmark);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNMARK_SUCCESS, taskToUnmark));
        } catch (DuplicateTaskException dte) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_DUPLICATE_UNMARK_TASK, taskToUnmark));
        } catch (TaskNotFoundException tnfe) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

```
###### /java/harmony/mastermind/ui/ActionHistoryEntry.java
``` java
public class ActionHistoryEntry extends UiPart{

    private static final String FXML = "ActionHistoryEntry.fxml";
    
    @FXML
    private HBox actionHistoryEntry;
    
    @FXML
    private Label title;
    
    @FXML
    private Label date;
    
    public void setTitle(String title){
        this.title.setText(title);
    }
    
    public void setDate(String date){
        this.date.setText(date);
    }

    public Node getNode(){
        return actionHistoryEntry;
    }
    
    public void setTypeFail(){
        this.title.setStyle("-fx-text-fill: -fx-quaternary;");
        this.date.setStyle("-fx-text-fill: -fx-quaternary;");
    }
    
    public void setTypeSuccess(){
        this.title.setStyle("-fx-text-fill: -fx-primary;");
        this.date.setStyle("-fx-text-fill: -fx-primary;");
    }
    
    @Override
    public void setNode(Node node) {
        actionHistoryEntry = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
      
    

}

```
###### /java/harmony/mastermind/ui/ActionHistoryEntry.java
``` java
class ActionHistory {
    private final String title;
    private final String description;
    private final Date dateActioned;
    
    public ActionHistory(String title, String description){
        this.title = title;
        this.description = description;
        this.dateActioned = new Date();
    }

    public String getTitle() {
        return title;
    }

    public String getDescription() {
        return description;
    }

    public Date getDateActioned() {
        return dateActioned;
    }
}
```
###### /java/harmony/mastermind/ui/HomeTableView.java
``` java
public class HomeTableView extends DefaultTableView {
    
    private static final String FXML = "HomeTableView.fxml";
    
    private static final PrettyTime prettyTime = new PrettyTime();
    
    private AnchorPane placeholder;
    
    private Logic logic;
    
    @FXML
    private TableView<ReadOnlyTask> homeTableView;

    @FXML
    private TableColumn<ReadOnlyTask, ReadOnlyTask> indexColumn;

    @FXML
    private TableColumn<ReadOnlyTask, ReadOnlyTask> nameColumn;

    @FXML
    private TableColumn<ReadOnlyTask, ReadOnlyTask> startDateColumn;

    @FXML
    private TableColumn<ReadOnlyTask, ReadOnlyTask> endDateColumn;

    @FXML
    private TableColumn<ReadOnlyTask, ReadOnlyTask> tagsColumn;

    @FXML
    private TableColumn<ReadOnlyTask, Boolean> recurColumn;

    
    public static HomeTableView load(Stage primaryStage, AnchorPane defaultTableViewPlaceholder, Logic logic){
        HomeTableView ui = UiPartLoader.loadUiPart(primaryStage, defaultTableViewPlaceholder, new HomeTableView());
        ui.configure(logic);
        return ui;
    }
    
```
###### /java/harmony/mastermind/ui/HomeTableView.java
``` java
    /**
     * Initializes the indexing of tasks
     */
    protected void initIndex() {
        indexColumn.setSortable(false);
        indexColumn.prefWidthProperty().bind(homeTableView.widthProperty().multiply(WIDTH_MULTIPLIER_INDEX));
        indexColumn.setCellFactory(column -> renderIndexCell());
    }

```
###### /java/harmony/mastermind/ui/HomeTableView.java
``` java
    /**
     * Initialize the Names of the tasks
     */
    protected void initName() {
        nameColumn.setSortable(false);
        nameColumn.prefWidthProperty().bind(homeTableView.widthProperty().multiply(WIDTH_MULTIPLIER_NAME));
        nameColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));
        nameColumn.setCellFactory(col -> renderNameCell());
    }

```
###### /java/harmony/mastermind/ui/HomeTableView.java
``` java
    /**
     * Initialize the start dates of the tasks
     */
    protected void initStartDate() {
        startDateColumn.setSortable(false);
        startDateColumn.prefWidthProperty().bind(homeTableView.widthProperty().multiply(WIDTH_MULTIPLIER_STARTDATE));
        startDateColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));

        startDateColumn.setCellFactory(col -> renderStartDateCell());

    }

```
###### /java/harmony/mastermind/ui/HomeTableView.java
``` java
    /**
     * Initialize the end dates of the tasks
     */
    protected void initEndDate() {
        endDateColumn.setSortable(false);
        endDateColumn.prefWidthProperty().bind(homeTableView.widthProperty().multiply(WIDTH_MULTIPLIER_ENDDATE));
        endDateColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));

        endDateColumn.setCellFactory(col -> renderEndDateCell());

    }

```
###### /java/harmony/mastermind/ui/HomeTableView.java
``` java
    /**
     * Initialize the tags of the tasks
     */
    protected void initTags() {
        tagsColumn.setSortable(false);
        tagsColumn.prefWidthProperty().bind(homeTableView.widthProperty().multiply(WIDTH_MULTIPLIER_TAGS));
        tagsColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));

        tagsColumn.setCellFactory(col -> renderTagsCell());

    }

```
###### /java/harmony/mastermind/ui/HomeTableView.java
``` java
    @Subscribe
    public void highlightLastActionedRow(HighlightLastActionedRowRequestEvent event){
        homeTableView.getSelectionModel().select(event.task);
        homeTableView.scrollTo(event.task);
    }
}

```
###### /java/harmony/mastermind/ui/ActionHistoryPane.java
``` java
    protected void initActionHistory() {

        actionHistory.setOnMouseClicked(value -> {
            consoleOutput.setText(actionHistory.getSelectionModel().getSelectedItem().getDescription());
        });
        
        actionHistory.setCellFactory(listView -> {
            ListCell<ActionHistory> actionCell = new ListCell<ActionHistory>() {

                @Override
                protected void updateItem(ActionHistory item, boolean isEmpty) {
                    super.updateItem(item, isEmpty);

                    if (!isEmpty) {

                        ActionHistoryEntry actionHistoryEntry = UiPartLoader.loadUiPart(new ActionHistoryEntry());

                        actionHistoryEntry.setTitle(item.getTitle().toUpperCase());
                        actionHistoryEntry.setDate(item.getDateActioned().toString().toUpperCase());

                        if (item.getTitle().toUpperCase().equals("INVALID COMMAND")) {
                            actionHistoryEntry.setTypeFail();
                        } else {
                            actionHistoryEntry.setTypeSuccess();
                        }

                        this.setGraphic(actionHistoryEntry.getNode());

                        this.setPrefHeight(50);
                        this.setPrefWidth(250);

                        this.setContentDisplay(ContentDisplay.GRAPHIC_ONLY);
                    } else {
                        this.setGraphic(null);
                    }
                }
            };

            return actionCell;
        });
        
        
    }
```
###### /java/harmony/mastermind/ui/ActionHistoryPane.java
``` java
    public void toggleActionHistory(){
        actionHistoryPane.setExpanded(!actionHistoryPane.isExpanded());
}

    // @@A0138862W
    protected void pushToActionHistory(String title, String description) {        
        ActionHistory aHistory = new ActionHistory(title, description);

        actionHistory.getItems().add(aHistory);
        actionHistory.scrollTo(actionHistory.getItems().size()- 1);
    }
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    // init only one parser for all parsing, save memory and computation time
    private static final PrettyTime prettyTime = new PrettyTime();
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    public static MainWindow load(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {

        MainWindow mainWindow = UiPartLoader.loadUiPart(primaryStage, new MainWindow());
        mainWindow.fillInnerParts(logic);
        mainWindow.configure(config.getAppTitle(), config.getTaskManagerName(), config, prefs, logic);
        return mainWindow;
    }
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    /**
     * Configure Tables and Tabs
     * @param logic Logic Manager instance
     */
    private void configureComponents(Logic logic) {
        
        // Configure sorting algorithm for tables
        SortedList<ReadOnlyTask> sortedTasks = logic.getFilteredTaskList().sorted();
        Comparator<ReadOnlyTask> comparator = new TaskListComparator();
        sortedTasks.setComparator(comparator);
        sortedTasks.comparatorProperty().bind(homeTableView.getTableView().comparatorProperty());

        // define placeholder label for empty table
        Label placeholder = new Label("What's on your mind?\nTry adding a new task by executing \"add\" command!");
        placeholder.setAlignment(Pos.CENTER);
        placeholder.setTextAlignment(TextAlignment.CENTER);

        homeTableView.getTableView().setPlaceholder(placeholder);
        homeTableView.getTableView().setItems(sortedTasks);

        tasksTableView.getTableView().setPlaceholder(placeholder);
        tasksTableView.getTableView().setItems(logic.getFilteredFloatingTaskList());

        eventsTableView.getTableView().setPlaceholder(placeholder);
        eventsTableView.getTableView().setItems(logic.getFilteredEventList());

        deadlinesTableView.getTableView().setPlaceholder(placeholder);
        deadlinesTableView.getTableView().setItems(logic.getFilteredDeadlineList());

        archivesTableView.getTableView().setPlaceholder(placeholder);
        archivesTableView.getTableView().setItems(logic.getFilteredArchiveList());
        
        tabPane.getSelectionModel().selectedItemProperty().addListener((tabList, fromTab, toTab)->{
            this.raise(new TabChangedEvent(fromTab.getId(), toTab.getId()));
        });
    }

    public void hide() {
        primaryStage.hide();
    }

    private void setTitle(String appTitle) {
        primaryStage.setTitle(appTitle);
    }

    /**
     * Sets the default size based on user preferences.
     */
    protected void setWindowDefaultSize(UserPrefs prefs) {
        primaryStage.setHeight(prefs.getGuiSettings().getWindowHeight());
        primaryStage.setWidth(prefs.getGuiSettings().getWindowWidth());
        if (prefs.getGuiSettings().getWindowCoordinates() != null) {
            primaryStage.setX(prefs.getGuiSettings().getWindowCoordinates().getX());
            primaryStage.setY(prefs.getGuiSettings().getWindowCoordinates().getY());
        }
    }

    private void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void fillInnerParts(Logic logic) {
        commandBox = CommandBox.load(primaryStage, commandBoxPlaceholder, logic);
        actionHistoryPane = ActionHistoryPane.load(primaryStage, actionHistoryPanePlaceholder, logic);
        homeTableView = HomeTableView.load(primaryStage, homeTableViewPlaceholder, logic);
        
        tasksTableView = TasksTableView.load(primaryStage, tasksTableViewPlaceholder, logic);
        
        eventsTableView = EventsTableView.load(primaryStage, eventsTableViewPlaceholder, logic);
        
        deadlinesTableView = DeadlinesTableView.load(primaryStage, deadlinesTableViewPlaceholder, logic);
        
        archivesTableView = ArchivesTableView.load(primaryStage, archivesTableViewPlaceholder, logic);
    }
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    @Subscribe
    private void handleNewResultAvailableEvent(NewResultAvailableEvent event){
        // updates the tab when a list command is called
        this.updateTab(event.message);
        logger.info("Update tab.");
    }
    
```
###### /java/harmony/mastermind/ui/DefaultTableView.java
``` java
    protected TableCell<ReadOnlyTask, ReadOnlyTask> renderIndexCell() {
        return new TableCell<ReadOnlyTask, ReadOnlyTask>() {
            @Override
            public void updateIndex(int index) {
                super.updateIndex(index);

                Text indexText = new Text(Integer.toString(index + 1)+ ".");
                indexText.getStyleClass().add("index-column");

                if (isEmpty() || index < 0) {
                    this.setGraphic(null);
                } else {
                    this.setGraphic(indexText);
                }
            }

        };
    }
    
```
###### /java/harmony/mastermind/ui/DefaultTableView.java
``` java
    protected TableCell<ReadOnlyTask, ReadOnlyTask> renderNameCell() {
        return new TableCell<ReadOnlyTask, ReadOnlyTask>() {

            @Override
            public void updateItem(ReadOnlyTask readOnlyTask, boolean isEmpty) {
                super.updateItem(readOnlyTask, isEmpty);

                if (!isEmpty()) {

                    VBox vBox = new VBox(3);

                    Text taskName = generateStyledText(readOnlyTask, readOnlyTask.getName());
                    taskName.getStyleClass().add("task-name-column");
                    vBox.getChildren().add(taskName);

                    generateSpecialTag(readOnlyTask, vBox);

                    this.setGraphic(vBox);
                    this.setPrefHeight(50);

                } else {
                    this.setGraphic(null);
                }

            }

        };
    }
    
```
###### /java/harmony/mastermind/ui/DefaultTableView.java
``` java
    protected TableCell<ReadOnlyTask, ReadOnlyTask> renderStartDateCell() {
        return new TableCell<ReadOnlyTask, ReadOnlyTask>() {

            @Override
            public void updateItem(ReadOnlyTask readOnlyTask, boolean isEmpty) {
                super.updateItem(readOnlyTask, isEmpty);
                if (!isEmpty()
                    && readOnlyTask.getStartDate() != null) {

                    TextFlow textFlow = generateStyledDate(readOnlyTask, readOnlyTask.getStartDate());

                    this.setGraphic(textFlow);
                    this.setPrefHeight(50);

                } else {
                    this.setGraphic(null);
                }

            }

        };
    }
    
```
###### /java/harmony/mastermind/ui/DefaultTableView.java
``` java
    protected TableCell<ReadOnlyTask, ReadOnlyTask> renderEndDateCell() {
        return new TableCell<ReadOnlyTask, ReadOnlyTask>() {

            @Override
            public void updateItem(ReadOnlyTask readOnlyTask, boolean isEmpty) {
                super.updateItem(readOnlyTask, isEmpty);
                if (!isEmpty()
                    && readOnlyTask.getEndDate() != null) {

                    TextFlow textFlow = generateStyledDate(readOnlyTask, readOnlyTask.getEndDate());

                    this.setGraphic(textFlow);
                    this.setPrefHeight(50);

                } else {
                    this.setGraphic(null);
                }

            }
        };
    }
    
```
###### /java/harmony/mastermind/ui/DefaultTableView.java
``` java
    protected TableCell<ReadOnlyTask, ReadOnlyTask> renderTagsCell() {
        return new TableCell<ReadOnlyTask, ReadOnlyTask>() {

            @Override
            public void updateItem(ReadOnlyTask readOnlyTask, boolean isEmpty) {
                super.updateItem(readOnlyTask, isEmpty);
                if (!isEmpty()
                    && readOnlyTask.getTags() != null) {

                    HBox tags = new HBox(5);

                    for (Tag tag : readOnlyTask.getTags()) {
                        Button tagBubble = new Button();
                        tagBubble.setText(tag.tagName);
                        tagBubble.getStyleClass().add("tag");
                        tags.getChildren().add(tagBubble);
                    }

                    this.setGraphic(tags);
                } else {
                    this.setGraphic(null);
                }
            }
        };
    }
    
```
###### /java/harmony/mastermind/ui/DefaultTableView.java
``` java
    /*
     * Generate styled row base on the task status: due(red), happening(orange),
     * normal(blue)
     * 
     */
    protected Text generateStyledText(ReadOnlyTask readOnlyTask, String text) {
        Text taskName = new Text(text);

        if (readOnlyTask.isHappening()) {
            taskName.getStyleClass().add("happening");
        } else if (readOnlyTask.isDue()) {
            taskName.getStyleClass().add("overdue");
        } else {
            taskName.getStyleClass().add("normal");
        }
        return taskName;
    }

```
###### /java/harmony/mastermind/ui/DefaultTableView.java
``` java
    /**
     * THis method generate Due, Happening, and duration depend on the nature of the task
     * 
     * @param readOnlyTask the task object
     * @param vBox The container
     */
    protected void generateSpecialTag(ReadOnlyTask readOnlyTask, VBox vBox) {
        HBox hBox = new HBox(5);

        Button status = new Button();
        if (readOnlyTask.isHappening()) {
            status.setText("HAPPENING");
            status.getStyleClass().add("tag-happening");
            hBox.getChildren().add(status);
        } else if (readOnlyTask.isDue()) {
            status.setText("DUE");
            status.getStyleClass().add("tag-overdue");
            hBox.getChildren().add(status);
        }

        if (readOnlyTask.isEvent()) {
            Button eventDuration = new Button();
            eventDuration.setText("DURATION: " + DurationFormatUtils.formatDurationWords(readOnlyTask.getEventDuration().toMillis(), true, true).toUpperCase());
            eventDuration.getStyleClass().add("tag-event-duration");
            hBox.getChildren().add(eventDuration);
        } else if (readOnlyTask.isDeadline()
                   && !readOnlyTask.isDue()) {
            Button dueDuration = new Button();
            dueDuration.setText("DUE IN " + DurationFormatUtils.formatDurationWords(readOnlyTask.getDueDuration().toMillis(), true, true));
            dueDuration.getStyleClass().add("tag-due-duration");
            hBox.getChildren().add(dueDuration);
        }

        vBox.getChildren().add(hBox);
    }
    
    
```
###### /java/harmony/mastermind/ui/DefaultTableView.java
``` java
    /**
     * 
     * This method generate the double-line text for date column
     * 
     * @param readOnlyTask the task object
     * @return TextFlow the styled text
     */
    protected TextFlow generateStyledDate(ReadOnlyTask readOnlyTask, Date date) {
        TextFlow textFlow = new TextFlow();

        Text prettyDate = generateStyledText(readOnlyTask, prettyTime.format(date));
        prettyDate.getStyleClass().add("pretty-date");

        Text lineBreak = new Text("\n\n");
        lineBreak.setStyle("-fx-font-size:2px;");

        Text uglyDate = generateStyledText(readOnlyTask, readOnlyTask.parse(date));
        uglyDate.getStyleClass().add("ugly-date");

        textFlow.getChildren().add(prettyDate);
        textFlow.getChildren().add(lineBreak);
        textFlow.getChildren().add(uglyDate);
        return textFlow;
    }
    
}

```
