# A0138862W
###### /main/resources/view/MainWindow.css
``` css
.table-view {
    -fx-base: #1d1d1d;
    -fx-control-inner-background: #1d1d1d;
    -fx-background-color: #1d1d1d;
    -fx-table-cell-border-color: transparent;
    -fx-table-header-border-color: transparent;
    -fx-padding: 5;
}

.table-view .column-header-background {
    -fx-background-color: transparent;
}

.table-view .column-header, .table-view .filler {
    -fx-size: 35;
    -fx-border-insets: 0 10 1 0;
}

.table-view .column-header .label {
    -fx-font-size: 10pt;
    -fx-font-family: "Verdana";
    -fx-text-fill: lightGray;
    -fx-alignment: center;
    -fx-opacity: 1;
}

.table-row-cell {
    -fx-cell-size: 55px;
}

.table-row-cell:selected {
   -fx-background-color: black;
   -fx-table-cell-border-color: black;
   -fx-border-width: 2px 2px 2px 2px;
   -fx-border-color: deepSkyBlue;
   -fx-border-style: dashed;
}

.text-field{
    -fx-background-color: #3f3f3f;
    -fx-font-size: 12pt;
    -fx-font-family: "Lucida Console";
    -fx-text-fill: deepSkyBlue;
    -fx-border-radius: 0 0 0 0;
    -fx-background-radius: 0 0 0 0;
}

.tab-pane .tab-header-area .headers-region,
.tab-pane .tab-header-area .tab-header-background{
    -fx-background-color: #1d1d1d;
}

.tab-pane .tab-header-area .tab{
    -fx-background-color: #1d1d1d;
}

.tab-pane .tab-header-area .tab-label{
    -fx-text-fill: lightGray;
    -fx-font-weight: bold;
    -fx-font-style: oblique;
}

.tab-pane .tab-header-area .tab:selected .tab-label{
    -fx-text-fill: deepSkyBlue;
    -fx-font-weight: bold;
}

.split-pane:horizontal > .split-pane-divider {
    -fx-background-color: deepSkyBlue;
}

.text-area,
.text-area .content{
    -fx-background-color: #1d1d1d;
    -fx-font-size: 12pt;
    -fx-font-family: "Lucida Console";
    -fx-text-fill: deepSkyBlue;
}

.list-view{
    -fx-background-color: #1d1d1d;
}

.label{
    -fx-text-fill: white;
    -fx-font-family: "Verdana";
    -fx-font-size: 12pt;
    -fx-font-weight: bold;
    -fx-padding: 15px;
    -fx-font-style: oblique;
}

.list-cell{
    -fx-cell-size: 50;
    -fx-padding: 10 5 10 15;
    -fx-background-color: #1d1d1d;
    -fx-text-fill: white;
}

.list-cell:filled:selected:focused{
    -fx-background-color: #1a1a1a;
}

.scroll-bar,
.scroll-bar .decrement-button,
.scroll-bar .increment-button{
    -fx-background-color: #1d1d1d;
}

.scroll-bar .thumb,
.scroll-bar .decrement-button > .decrement-arrow,
.scroll-bar .increment-button > .increment-arrow{
    -fx-background-color: deepSkyBlue;
}

.action-history-item .title{
    -fx-text-fill: deepSkyBlue;
    -fx-font-weight: bold;
    -fx-font-size: 14px;
    -fx-font-style: normal;
    -fx-padding: 0px;
}

.action-history-item .date{
    -fx-text-fill: deepSkyBlue;
    -fx-font-weight: normal;
    -fx-font-size: 10px;
    -fx-font-style: normal;
    -fx-padding: 0px;
}

.action-history-item .description{
    -fx-text-fill: white;
    -fx-font-weight: normal;
    -fx-font-size: 12px;
    -fx-font-style: normal;
    -fx-padding: 0px;
}

.task-name-column{
    -fx-font-weight: bold;
    -fx-font-size: 18px;
}

.index-column{
    -fx-font-weight: bold;
    -fx-font-size: 16px;
    -fx-fill: white;
    -fx-font-style: oblique;
}

.pretty-date{
    -fx-font-weight:bold;
}

.ugly-date{
    -fx-font-size:10px;
}

.tag{
    -fx-background-color: green;
    -fx-background-radius: 30;
    -fx-background-insets: 0;
    -fx-text-fill: white;
    -fx-font-size: 10px;
    -fx-font-weight: bold;
}

.tag-overdue{
    -fx-background-color: red;
    -fx-background-radius: 30;
    -fx-background-insets: 0;
    -fx-text-fill: white;
    -fx-font-size: 8px;
    -fx-font-weight: bold;
}

.tag-happening{
    -fx-background-color: orange;
    -fx-background-radius: 30;
    -fx-background-insets: 0;
    -fx-text-fill: black;
    -fx-font-size: 8px;
    -fx-font-weight: bold;
}

.tag-due-duration,
.tag-event-duration{
    -fx-background-color: darkGray;
    -fx-background-radius: 30;
    -fx-background-insets: 0;
    -fx-text-fill: black;
    -fx-font-size: 8px;
    -fx-font-weight: bold;
}

.normal{
    -fx-fill: deepSkyBlue;
}

.overdue{
    -fx-fill: red;
}

.happening{
    -fx-fill: orange;
}

.titled-pane,
.titled-pane .title,
.titled-pane .content{
    -fx-background-color: #1d1d1d;
    -fx-border-color: #1d1d1d;
}

.titled-pane .title{
    -fx-border-width: 2px 0px 0px 0px;
    -fx-border-color: #3f3f3f;
    -fx-border-style: dashed;
}

.titled-pane > .title .text{
    -fx-fill: deepSkyBlue;
    -fx-font-family: "Lucida Console";
    -fx-font-style: oblique;
    -fx-font-weight: bold;

}

.titled-pane .title .arrow-button .arrow{
    -fx-background-color: deepSkyBlue;
}
```
###### /main/resources/view/ActionHistoryItem.fxml
``` fxml
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>

<HBox fx:id="actionHistoryItem" maxHeight="-Infinity" maxWidth="1.7976931348623157E308" styleClass="action-history-item" xmlns="http://javafx.com/javafx/8.0.101" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <VBox minWidth="200.0" prefWidth="200.0">
         <children>
            <Label fx:id="title" styleClass="title" text="TITLE" />
            <Label fx:id="date" styleClass="date" text="DATE" />
         </children>
      </VBox>
   </children>
</HBox>
```
###### /main/resources/view/MainWindow.fxml
``` fxml

<?import javafx.scene.control.ListView?>
<?import javafx.scene.control.Tab?>
<?import javafx.scene.control.TabPane?>
<?import javafx.scene.control.TableColumn?>
<?import javafx.scene.control.TableView?>
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.control.TitledPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>

```
###### /main/java/harmony/mastermind/commons/exceptions/TaskAlreadyMarkedException.java
``` java
/*
 * This exception is thrown when attempt to execute MarkCOmmand on a task that's already marked
 */
public class TaskAlreadyMarkedException extends Exception {


    public TaskAlreadyMarkedException(){
        super();
    }
}
```
###### /main/java/harmony/mastermind/commons/events/ui/ExecuteCommandEvent.java
``` java
public class ExecuteCommandEvent extends BaseEvent{

    public Date dateExecuted;
    public String title;
    public String description;

```
###### /main/java/harmony/mastermind/commons/events/ui/ExecuteCommandEvent.java
``` java
    public ExecuteCommandEvent(String title, String description){
        dateExecuted = new Date();

        this.title = title;
        this.description = description;
    }

```
###### /main/java/harmony/mastermind/commons/events/ui/ExecuteCommandEvent.java
``` java
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }



}
```
###### /main/java/harmony/mastermind/commons/events/ui/ToggleActionHistoryEvent.java
``` java
/**
 *
 * This event is raised when the ActionHistoryCommand request to toggle the UI.
 *
 */
public class ToggleActionHistoryEvent extends BaseEvent{

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /main/java/harmony/mastermind/commons/events/ui/HighlightLastActionedRowRequestEvent.java
``` java
/*
 * This event is raise when a command request UI to highlight the action row in the tableview
 *
 */
public class HighlightLastActionedRowRequestEvent extends BaseEvent {

    public Task task;

    public HighlightLastActionedRowRequestEvent(Task task){
        this.task = task;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /main/java/harmony/mastermind/model/tag/UniqueTagList.java
``` java
    public String toString(){
        // functional way to transform list of items into concatenated string joining with commas (JAVA 8)
        return this.getInternalList().stream().map(Object::toString).collect(Collectors.joining(","));
    }
}
```
###### /main/java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    /*
     * push the command to the undo history.
     * @see harmony.mastermind.model.Model#pushToUndoHistory(harmony.mastermind.logic.commands.Undoable)
     */
    public void pushToUndoHistory(Undoable command) {
        undoHistory.push(command);
    }

```
###### /main/java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    /** undo last action performed **/
    public CommandResult undo() throws EmptyStackException {
        CommandResult commandResult = undoHistory.pop().undo();
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return commandResult;
    }

    @Override
```
###### /main/java/harmony/mastermind/model/ModelManager.java
``` java
    /*
     * push the command to the redo history. Should only be called after an undo operation
     * @see harmony.mastermind.model.Model#pushToRedoHistory(harmony.mastermind.logic.commands.Redoable)
     */
    public void pushToRedoHistory(Redoable command) {
        redoHistory.push(command);
    }

    @Override
```
###### /main/java/harmony/mastermind/model/ModelManager.java
``` java
    /** redo the action that being undone function **/
    public CommandResult redo() throws EmptyStackException {
        CommandResult commandResult = redoHistory.pop().redo();
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return commandResult;
    }

    @Override
    /**
     * This method should only be called when the user entered a new command
     * other than redo/undo
     **/
```
###### /main/java/harmony/mastermind/model/ModelManager.java
``` java
    public void clearRedoHistory() {
        redoHistory.clear();
    }

```
###### /main/java/harmony/mastermind/model/Model.java
``` java
    /** undo last action performed, throws EmptyStackException is there's no more action can be undone **/
    CommandResult undo() throws EmptyStackException;

```
###### /main/java/harmony/mastermind/model/Model.java
``` java
    /** push the command to redo history */
    void pushToRedoHistory(Redoable command);

```
###### /main/java/harmony/mastermind/model/Model.java
``` java
    /** undo last action performed, throws EmptyStackException is there's no more action can be undone **/
    CommandResult redo() throws EmptyStackException;

    /** empty redoHistory **/
    // required when a new command is entered, model should throw away all remaining commands in the redo history
    void clearRedoHistory();

    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
```
###### /main/java/harmony/mastermind/model/Model.java
``` java
    /** Returns filtered task list as an {@code ObervableList<Task>} */
    ObservableList<Task> getListToMark();

    /** update current tab to the specified tab*/
    void updateCurrentTab(String tab);

    /** Updates the filter of the filtered task list for current tab to show all tasks */
    void updateFilteredListToShowAll();

    /** Updates the filter of the filtered task list for specified tab to show all tasks */
    void updateFilteredListToShow(String tab);

    /** Updates the filter of the filtered task list
     * for Home tab to show all upcoming tasks */
    void updateFilteredListToShowUpcoming(long time, String taskType);

```
###### /main/java/harmony/mastermind/model/Model.java
``` java
    /** Updates the filter of the filtered task list to filter by the given tag keywords*/
    void updateFilteredTagTaskList(Set<Tag> keywords);

    /** Search */
    void searchTask(String input);

```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    /*
     * Initialize through taskBuilder (preferred way)
     */
    protected Task(TaskBuilder taskBuilder){
        this.name = taskBuilder.getName();
        this.startDate = taskBuilder.getStartDate();
        this.endDate = taskBuilder.getEndDate();
        this.createdDate = taskBuilder.getCreatedDate();
        this.tags = taskBuilder.getTags();
        this.recur = taskBuilder.getRecur();
        this.isMarked = taskBuilder.isMarked();
    }

    // event
```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public Task(String name, Date startDate, Date endDate, UniqueTagList tags, String recur, Date createdDate) {
        this.name = name;
        this.startDate = startDate;
        this.endDate = endDate;
        this.tags = tags;
        this.isMarked = false;
        this.recur = recur;
        this.createdDate = createdDate;
    }

    // deadline
```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public Task(String name, Date endDate, UniqueTagList tags, String recur, Date createdDate) {
        this(name, null, endDate, tags, recur, createdDate);
    }

    // floating
```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public Task(String name, UniqueTagList tags, Date createdDate) {
        this(name, null, null, tags, null, createdDate);
    }

```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getStartDate(), source.getEndDate(), source.getTags(), source.getRecur(), source.getCreatedDate());
        this.isMarked = source.isMarked();
    }

    @Override
```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isFloating() {
        return startDate == null && endDate == null;
    }

    @Override
```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isDeadline() {
        return startDate == null && endDate != null;
    }

    @Override
```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isEvent() {
        return startDate != null && endDate != null;
    }

```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public Date getCreatedDate() {
        return createdDate;
    }

```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    /*
     *
     * Check if the current task is due. Applies to only deadline & event
     * - deadline: true if and only if current date is after end date
     * - event: true if and only if current date is after end date & start date
     *
     * @see harmony.mastermind.model.task.ReadOnlyTask#isDue()
     */
    public boolean isDue(){
        Date now = new Date();
        if (isDeadline() && now.after(endDate)) {
            return true;
        } else if (isEvent() && now.after(startDate) && now.after(endDate)){
            return true;
        } else {
            return false;
        }
    }

```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    /*
     *
     * Check if current task is happening at the moment.
     * Only applies to event, where the current date falls between start & end date
     *
     * @see harmony.mastermind.model.task.ReadOnlyTask#isHappening()
     */
    public boolean isHappening(){
        Date now = new Date();
        if (isEvent() && now.after(startDate) && now.before(endDate)) {
            return true;
        } else {
            return false;   
        }
    }

```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    /*
     *
     * Calculate the duration of event.
     * Applies to only event, return null otherwise.
     *
     * @see harmony.mastermind.model.task.ReadOnlyTask#getEventDuration()
     */
    public Duration getEventDuration(){
        if(isEvent()){
            long differencel = endDate.getTime() - startDate.getTime();

            return Duration.of(differencel, ChronoUnit.MILLIS);
        }else{
            return null;
        }
    }

```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    /*
     * calculate the duration until due date
     * Applies to only deadlines, return null otherwise.
     *
     */
    public Duration getDueDuration(){
        if(endDate != null){
            long nowl = System.currentTimeMillis();
            long endDatel = endDate.getTime();

            long differencel = endDatel - nowl;

            return Duration.of(differencel, ChronoUnit.MILLIS);
        }else{
            return null;
        }
    }
}
```
###### /main/java/harmony/mastermind/model/task/TaskBuilder.java
``` java
import java.util.Date;
import java.util.Set;

import harmony.mastermind.commons.exceptions.IllegalValueException;
import harmony.mastermind.commons.exceptions.InvalidEventDateException;
import harmony.mastermind.model.tag.Tag;
import harmony.mastermind.model.tag.UniqueTagList;
import harmony.mastermind.model.tag.UniqueTagList.DuplicateTagException;

/**
 * The TaskBuilder is a safe way to create a task object instead of relying on constructors.
 * The Task has numerous attributes which depends on the nature of the task (event, floating, deadline),
 * it must be build independently.
 * <br/>
 * The task builder provide a systematic way to build a task object and is future proof.
 * Task Builder mitigates the problem of having too many parameters in Task constructor.
 *
 */
public class TaskBuilder {

    private final String name;
    private Date startDate;
    private Date endDate;
    private Date createdDate;
    private UniqueTagList tags;
    private String recur;
    private boolean isMarked;

    /**
     * creation date will automatically assigned upon initializing.
     *
     * @param name is mandatory field. The task name.
     *
     */
    public TaskBuilder(String name){
        this.name = name;
        this.createdDate = new Date();
    }

    /**
     * build a floating task with both start and end dates are null
     *
     */
    public TaskBuilder asFloating(){
        startDate = null;
        endDate = null;
        return this;
    }

    /**
     * build an event with both valid start and end dates
     *
     * @param startDate is the start date of the event
     * @param endDate is the end date of the event
     *
     * @throws InvalidEventDateException if start date is after end date
     *
     */
    public TaskBuilder asEvent(Date startDate, Date endDate) throws InvalidEventDateException{
        if (startDate.after(endDate)) {
            throw new InvalidEventDateException();
        }

        this.startDate = startDate;
        this.endDate = endDate;

        return this;
    }

    /**
     * build a deadline task with only end date
     *
     *  @param endDate is the due date.
     *
     */
    public TaskBuilder asDeadline(Date endDate){
        this.startDate = null;
        this.endDate = endDate;
        return this;
    }

    public TaskBuilder withTags(Set<String> tagSet) throws IllegalValueException {
        tags = new UniqueTagList();
        for (String tag: tagSet) {
            this.tags.add(new Tag(tag));
        }
        return this;
    }

    /**
     * build a recurring task.
     *
     * @param recur can be daily, weekly, monthly, yearly
     *
     */
    public TaskBuilder asRecurring(String recur){
        this.recur = recur;
        return this;
    }

    /**
     * Set a custom creation date. This will overwrite the auto assigned date.
     *
     * @param createdDate is the customized creation date
     *
     */
    public TaskBuilder withCreationDate(Date createdDate){
        this.createdDate = createdDate;
        return this;
    }

    /**
     * build a task as marked task
     *
     */
    public TaskBuilder asMarked(){
        this.isMarked = true;
        return this;
    }


    /**
     * finalize build and return a Task object
     *
     */
    public Task build(){
        return new Task(this);
    }

```
###### /main/java/harmony/mastermind/model/task/TaskListComparator.java
``` java
public class TaskListComparator implements Comparator<ReadOnlyTask> {

    /*
     * By default, compare by creation dates.
     * This comparator use for sorting table view so edit/delete will not add to the bottom of the list
     * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
     */
    @Override
    public int compare(ReadOnlyTask o1, ReadOnlyTask o2) {
        if(o1.getCreatedDate() == null || o2.getCreatedDate() == null){
            return 0;
        }

        if (o1.getCreatedDate().after(o2.getCreatedDate())) {
            return 1;
        } else if (o1.getCreatedDate().before(o2.getCreatedDate())) {
            return -1;
        } else {
            return 0;
        }                
    }
}
```
###### /main/java/harmony/mastermind/storage/XmlAdaptedTask.java
``` java
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName();
        createdDate = source.getCreatedDate();

        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }
```
###### /main/java/harmony/mastermind/logic/parser/Parser.java
``` java
    private Command prepareAdd(String args) {
        try {

            final Matcher matcher = AddCommand.COMMAND_ARGUMENTS_PATTERN.matcher(args.trim());

            // Validate user command input
            if (!matcher.matches()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_EXAMPLES));
            }

            // mandatory field                       
            final String name = matcher.group("name");

            // at this point name variable should never be null because the regex only capture full match of mandatory components
            // check for bug in regex expression if the following throws assertion error
            assert name != null;

            // optionals
            final Optional<String> dates = Optional.ofNullable(matcher.group("dates"));
            final Optional<String> tags = Optional.ofNullable(matcher.group("tags"));
            final Optional<String> recur = Optional.ofNullable(matcher.group("recur"));

            // return internal value if present. else, return empty string
            final Set<String> tagSet = getTagsFromArgs(tags.map(val -> val).orElse(""));

            // after init every capturing groups, we start to build the command
            AddCommand addCommand = buildAddCommand(name, dates, recur, tagSet);

            return addCommand;
        } catch (IllegalValueException | InvalidEventDateException e) {
            return new IncorrectCommand(e.getMessage());
        }
    }

```
###### /main/java/harmony/mastermind/logic/parser/Parser.java
``` java
    /**
     * Build the AddCommand
     *
     * @param name is mandatory field
     * @param dates contain user input date string that has to be parsed by natural language processing library. Optional
     * @param recur contain recur input contain the keyword such as daily, weekly, monthly. Optional
     * @param tagSet unique set of tag string associated to the task
     *
     * @throws IllegalValueException if tags contain non-alphanumeric value
     * @throws InvalidEventDateException if event start date is after end date
     */
    private AddCommand buildAddCommand(final String name, final Optional<String> dates, final Optional<String> recur, final Set<String> tagSet) throws IllegalValueException, InvalidEventDateException {
        AddCommandBuilder addCommandBuilder = new AddCommandBuilder(name);
        addCommandBuilder.withTags(tagSet);
        recur.ifPresent(recurVal -> addCommandBuilder.asRecurring(recurVal));

        if(dates.isPresent()){
            PrettyTimeParser ptp = new PrettyTimeParser();
            List<DateGroup> parsedDates = ptp.parseSyntax(dates.get());

            if(!parsedDates.isEmpty()){
                List<Date> startEndDates = parsedDates.get(0).getDates();

                /*
                 * We assume two conditions after parsing nlp dates:
                 * 1. Found only 1 date, then we assume it is a deadline
                 * 2. Found 2 dates, then we assume it is an event
                 */
                if(shouldParseAsDeadline(startEndDates)){
                    addCommandBuilder.asDeadline(startEndDates.get(0));
                }else if(shouldParseAsEvent(startEndDates)){
                    addCommandBuilder.asEvent(startEndDates.get(0), startEndDates.get(1));
                }
            }
        };
        return addCommandBuilder.build();
    }

```
###### /main/java/harmony/mastermind/logic/parser/Parser.java
``` java
    /*
     * Determine the date should be parse as deadline task
     */
    private boolean shouldParseAsDeadline(List<Date> dates){
        return dates.size() == 1;
    }

```
###### /main/java/harmony/mastermind/logic/parser/Parser.java
``` java
    /*
     * Determine the date should be parse as event task
     */
    private boolean shouldParseAsEvent(List<Date> dates){
        return dates.size() == 2;
    }

```
###### /main/java/harmony/mastermind/logic/parser/Parser.java
``` java
    /*
     * Extract the source destination string and prepare the Import ICS command.
     *
     */
    private Command prepareImport(String args){
        final Matcher matcher = ImportCommand.COMMAND_ARGUMENTS_PATTERN.matcher(args.trim());

        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ImportCommand.MESSAGE_USAGE));
        }

        final String source = matcher.group("source");
        final String extension = matcher.group("extension");

        assert source != null;

        return new ImportCommand(source, extension);
    }

    /**
     * Parses arguments in the context of the edit task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
```
###### /main/java/harmony/mastermind/logic/parser/Parser.java
``` java
    private Command prepareEdit(String args) {
        final Matcher matcher = EditCommand.COMMAND_ARGUMENTS_PATTERN.matcher(args.trim());

        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        try {

            // mandatory
            // regex accept only numbers in index field, encountering NumberFormatException is impossible
            final int index = Integer.parseInt(matcher.group("index"));

            //optional
            final Optional<String> recur = Optional.ofNullable(matcher.group("recur"));
            final Optional<String> name = Optional.ofNullable(matcher.group("name"));
            final Optional<String> startDate = Optional.ofNullable(matcher.group("startDate"));
            final Optional<String> endDate = Optional.ofNullable(matcher.group("endDate"));
            final Optional<String> tags = Optional.ofNullable(matcher.group("tags"));

            Optional<Set<String>> tagSet = Optional.empty();
            if(tags.isPresent()){
                tagSet = Optional.ofNullable(getTagsFromArgs(tags.get()));
            };

            return new EditCommand(index, name, startDate, endDate, tagSet, recur);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (ParseException pe) {
            return new IncorrectCommand(pe.getMessage());
        }

    }

    private Command prepareExport(String args){
        final Matcher matcher = ExportCommand.COMMAND_ARGUMENTS_PATTERN.matcher(args.trim());

        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ExportCommand.MESSAGE_EXAMPLE));
        }

        try {
            // mandatory
            final String destination = matcher.group("destination");

            // at this point destination variable should never be null because the regex only capture full match of mandatory components
            // check for bug in regex expression if the following throws assertion error
            assert destination != null;

            // capture all matched string if present
            final Optional<String> tasks = Optional.ofNullable(matcher.group("tasks"));
            final Optional<String> deadlines = Optional.ofNullable(matcher.group("deadlines"));
            final Optional<String> events = Optional.ofNullable(matcher.group("events"));
            final Optional<String> archives = Optional.ofNullable(matcher.group("archives"));

            if(isExportingAll(tasks, deadlines, events, archives)){
                return new ExportCommand(destination, true, true, true, true);
            }else{
                boolean isExportingTasks = tasks.isPresent();
                boolean isExportingDeadlines = deadlines.isPresent();
                boolean isExportingEvents = events.isPresent();
                boolean isExportingArchives = archives.isPresent();

                return new ExportCommand(destination, isExportingTasks, isExportingDeadlines, isExportingEvents, isExportingArchives);
            }
        } catch (IOException e) {
            return new IncorrectCommand(e.getMessage());
        }
    }

    /*
     * This method return true if user did not specify any categories to export,
     * then we assume user wants to export all categories.
     * eg: export to C:\User\Jim\Workspace\mastermind.csv
     */
    private boolean isExportingAll(Optional<String> tasks, Optional<String> deadlines, Optional<String> events, Optional<String> archives){
        return tasks.isPresent() == false &&
                deadlines.isPresent() == false &&
                events.isPresent() == false &&
                archives.isPresent() == false;
    }

```
###### /main/java/harmony/mastermind/logic/commands/Command.java
``` java
    /**
     * Raises an event to highlight the last action row in table
     * This event should be subscribed by UiManager to update the table
     *
     * @param the row that contain the task that needs to be highlighted
     *
     */
    protected void requestHighlightLastActionedRow(Task task){
        EventsCenter.getInstance().post(new HighlightLastActionedRowRequestEvent(task));
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/AddCommand.java
``` java
public class AddCommand extends Command implements Undoable, Redoable {

    public static final String COMMAND_KEYWORD_ADD = "add";
    public static final String COMMAND_KEYWORD_DO = "do";

    // Better regex, support better NLP:
    // general form: add some task name from tomorrow 8pm to next friday 8pm daily #recurring,awesome
    // https://regex101.com/r/M2A3tB/8
    public static final String COMMAND_ARGUMENTS_REGEX = "(?=(?<name>(?:.(?!by|from|#))+))"
                                                        + "(?:(?=.*(?:by|from)\\s(?<dates>(?:.(?!#))+)?))?"
                                                        + "(?:(?=.*(?<recur>daily|weekly|monthly|yearly)))?"
                                                        + "(?:(?=.*#(?<tags>.+)))?.*";

    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);

    public static final String COMMAND_FORMAT = "Floating Task: (add|do) <task_name> #[<comma_separated_tags>]\n"
                                                + "Deadline: (add|do) <task_name> by <end_date> [daily|weekly|monthly|yearly] #[comma_separated_tags]\n"
                                                + "Event: (add|do) <task_name> from <start_date> to <end_date> [daily|weekly|monthly|yearly] #[comma_separated_tags]";

    public static final String MESSAGE_EXAMPLE_EVENT = "add attend workshop from today 7pm to next monday 1pm #programming,java";
    public static final String MESSAGE_EXAMPLE_DEADLINE = "add submit homework by next sunday 11pm #math,physics";
    public static final String MESSAGE_EXAMPLE_FLOATING = "do chores #cleaning";
    public static final String MESSAGE_EXAMPLE_RECUR_DEADLINE = "add submit homework by next sunday 11pm weekly #math,physics";
    public static final String MESSAGE_EXAMPLE_RECUR_EVENT = "add attend workshop from today 7pm to next monday 1pm monthly #programming,java";

    public static final String MESSAGE_EXAMPLES = new StringBuilder()
                                                    .append("[Format]\n")
                                                    .append(COMMAND_FORMAT+ "\n\n")
                                                    .append("[Examples]:\n")
                                                    .append("Event: "+ MESSAGE_EXAMPLE_EVENT+"\n")
                                                    .append("Deadline: "+MESSAGE_EXAMPLE_DEADLINE+"\n")
                                                    .append("Floating: "+MESSAGE_EXAMPLE_FLOATING+"\n")
                                                    .append("Recurring Deadline: "+MESSAGE_EXAMPLE_RECUR_DEADLINE+"\n")
                                                    .append("Recurring Event: "+MESSAGE_EXAMPLE_RECUR_EVENT+"\n")
                                                    .toString();

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_UNDO_SUCCESS = "[Undo Add Command] Task deleted: %1$s";
    public static final String MESSAGE_REDO_SUCCESS = "[Redo Add Command] Task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in Mastermind";

    private final Task toAdd;


    private static final String TASK = "Task";
    private static final String DEADLINE = "Deadline";
    private static final String EVENT = "Event";

    static GenericMemory task;
    static GenericMemory deadline;
    static GenericMemory event;

```
###### /main/java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    /**
     * Build the AddCommand using addCommandBuilder.
     * Depending on the builder attributes, the taskBuilder will return the appropriate event/floating/deadline task.
     *
     * @param addCommandBuilder to build the command safely
     *
     */
    protected AddCommand(AddCommandBuilder addCommandBuilder) throws IllegalValueException, InvalidEventDateException{
        TaskBuilder taskBuilder = new TaskBuilder(addCommandBuilder.getName());
        taskBuilder.withTags(addCommandBuilder.getTags());

        if(addCommandBuilder.isDeadline()){
            taskBuilder.asDeadline(addCommandBuilder.getEndDate());
        }else if(addCommandBuilder.isEvent()){
            taskBuilder.asEvent(addCommandBuilder.getStartDate(), addCommandBuilder.getEndDate());
        }

        if(addCommandBuilder.isRecurring()){
            taskBuilder.asRecurring(addCommandBuilder.getRecur());
        }

        toAdd = taskBuilder.build();

        Parser.mem.add(new GenericMemory(toAdd.getTags().toString(), toAdd.getName(), ""));        
    }

    @Override
```
###### /main/java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public CommandResult execute() {
        assert model != null;
        try {
            executeAdd();

            model.pushToUndoHistory(this);

            // this is a new command entered by user (not undo/redo)
            // need to clear the redoHistory Stack
            model.clearRedoHistory();

            requestHighlightLastActionedRow(toAdd);

            return new CommandResult(COMMAND_KEYWORD_ADD,String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(COMMAND_KEYWORD_ADD,MESSAGE_DUPLICATE_TASK);
        }

    }

```
###### /main/java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    /** action to perform when ModelManager requested to undo this command **/
    @Override
    public CommandResult undo() {
        try {
            model.deleteTask(toAdd);

            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_KEYWORD_ADD,String.format(MESSAGE_UNDO_SUCCESS, toAdd));
        } catch (UniqueTaskList.TaskNotFoundException pne) {
            return new CommandResult(COMMAND_KEYWORD_ADD,Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        }
    }

```
###### /main/java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    /** action to perform when ModelManager requested to redo this command**/
    @Override
    public CommandResult redo() {
        assert model != null;
        try {
            executeAdd();

            model.pushToUndoHistory(this);

            requestHighlightLastActionedRow(toAdd);

            return new CommandResult(COMMAND_KEYWORD_ADD,String.format(MESSAGE_REDO_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(COMMAND_KEYWORD_ADD,MESSAGE_DUPLICATE_TASK);
        }        
    }


```
###### /main/java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    /** extract method since it's reusable for execute() and redo()**/
    private void executeAdd() throws DuplicateTaskException {
        model.addTask(toAdd);
    }

```
###### /main/java/harmony/mastermind/logic/commands/RedoCommand.java
``` java
    public CommandResult execute() {

        try{
            // All Command supports undo operation must implement Redoable interface

            // execute the redo strategy implemented by the underlying command
            CommandResult redoResult = model.redo();

            // display successful message and the details of the undo operations
            return new CommandResult(COMMAND_WORD,
                    MESSAGE_SUCCESS + "\n" +
                    "=====Redo Details=====\n" +
                    redoResult.feedbackToUser + "\n"+
                    "==================");
        }catch(EmptyStackException ex){
            return new CommandResult(COMMAND_WORD, MESSAGE_EMPTY_COMMAND_HISTORY);
        }
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/Undoable.java
``` java
public interface Undoable {

    /**
     * Specify the undo strategy according to the nature of the corresponding class.
     * For example, to implement an undo operation on AddCommand, a delete operation should be implemented.
     * Similarly, a DeleteCommand should implement a add operation to restore the record.
     *
     * @return CommandResult, the Object contains details & feedback about the undo operation.
     */
```
###### /main/java/harmony/mastermind/logic/commands/Undoable.java
``` java
    public CommandResult undo();

}
```
###### /main/java/harmony/mastermind/logic/commands/MarkCommand.java
``` java
    @Override
    /*
     * Strategy to undo mark command
     *
     * @see harmony.mastermind.logic.commands.Undoable#undo()
     */
    public CommandResult undo() {
        try {

            for (Task t:tasksToMark) {
                model.unmarkTask(t);

                requestHighlightLastActionedRow(t);                
            }
            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNDO_SUCCESS, tasksToMark.get(0)));
        } catch (DuplicateTaskException dte) {
            return new CommandResult(COMMAND_WORD, String.format(UnmarkCommand.MESSAGE_DUPLICATE_UNMARK_TASK, tasksToMark.get(0)));
        } catch (ArchiveTaskList.TaskNotFoundException tnfe) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

```
###### /main/java/harmony/mastermind/logic/commands/MarkCommand.java
``` java
    @Override
    /*
     * Strategy to redo mark command
     *
     * @see harmony.mastermind.logic.commands.Redoable#redo()
     */
    public CommandResult redo() {
        try {
            executeMark();

            model.pushToUndoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_REDO_SUCCESS, tasksToMark.get(0)));

        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(COMMAND_WORD,Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        } catch (DuplicateTaskException | NotRecurringTaskException e) {
            return new CommandResult(COMMAND_WORD,MESSAGE_MARK_RECURRING_FAILURE);
        }
    }

```
###### /main/java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
public class ExportCommand extends Command {

    public static final String COMMAND_KEYWORD_EXPORT = "export";

    public static final String COMMAND_ARGUMENTS_REGEX = "(?:(?=.*(?<tasks>tasks)))?"
                                                         + "(?:(?=.*(?<deadlines>deadlines)))?"
                                                         + "(?:(?=.*(?<events>events)))?"
                                                         + "(?:(?=.*(?<archives>archives)))?"
                                                         + ".*to "
                                                         + "(?<destination>.+)";

    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);

    public static final String COMMAND_FORMAT = "export [tasks] [deadlines] [events] [archives] to <destination>";

    public static final String MESSAGE_EXAMPLE = "export tasks deadlines to C:\\Desktop\\mastermind.csv";

    public static final String MESSAGE_SUCCESS = "CSV exported.";

    public static final String MESSAGE_FAILURE = "Failed to export CSV.";

    private static final String NEWLINE_CHARACTER = "\n";

    private static final Object[] GOOGLE_CALENDAR_HEADER = { "Subject", "Start Date", "Start Time", "End Date", "End Time", "All Day Event", "Description", "Location", "Private" };

    private static final SimpleDateFormat GOOGLE_CALENDAR_DATE_FORMAT = new SimpleDateFormat("MM/dd/yyyy");

    private static final SimpleDateFormat GOOGLE_CALENDAR_TIME_FORMAT = new SimpleDateFormat("HH:mm");

    private final String destination;

    private final boolean isExportingTasks;

    private final boolean isExportingDeadlines;

    private final boolean isExportingEvents;

    private final boolean isExportingArchives;

```
###### /main/java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    /**
     * Create a ExportCommand
     *
     * @param destination the file output destination
     * @param isExportingTasks whether to export all floating tasks
     * @param isExportingDeadlines whether to export all deadlines
     * @param isExportingEvents whether to export all events
     * @param isExportingArchives whether to export all archives
     * @throws IOException if destination file path is invalid
     */
    public ExportCommand(String destination, boolean isExportingTasks, boolean isExportingDeadlines, boolean isExportingEvents, boolean isExportingArchives) throws IOException {
        this.destination = destination;
        this.isExportingTasks = isExportingTasks;
        this.isExportingDeadlines = isExportingDeadlines;
        this.isExportingEvents = isExportingEvents;
        this.isExportingArchives = isExportingArchives;
    }

```
###### /main/java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    @Override
    public CommandResult execute() {

        CSVFormat csvFormat = CSVFormat.EXCEL;

        try (FileWriter fileWriter = new FileWriter(destination); CSVPrinter csvPrinter = new CSVPrinter(fileWriter, csvFormat);) {
            printHeader(csvPrinter);
            printTasks(csvPrinter);
            printDeadlines(csvPrinter);
            printEvents(csvPrinter);
            printArchives(csvPrinter);
            return new CommandResult(COMMAND_KEYWORD_EXPORT, MESSAGE_SUCCESS);
        } catch (IOException e) {
            return new CommandResult(COMMAND_KEYWORD_EXPORT, MESSAGE_FAILURE);
        }
    }

```
###### /main/java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    private void printHeader(CSVPrinter csvPrinter) throws IOException {
        csvPrinter.printRecord(GOOGLE_CALENDAR_HEADER);
    }

```
###### /main/java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    private void printTasks(CSVPrinter csvPrinter) throws IOException {
        if (isExportingTasks) {
            UnmodifiableObservableList<ReadOnlyTask> tasks = model.getFilteredFloatingTaskList();
            printDataBody(csvPrinter, tasks);
        }
    }

```
###### /main/java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    private void printDeadlines(CSVPrinter csvPrinter) throws IOException{
        if(isExportingDeadlines){
            UnmodifiableObservableList<ReadOnlyTask> deadlines = model.getFilteredDeadlineList();
            printDataBody(csvPrinter, deadlines);
        }
    }

```
###### /main/java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    private void printEvents(CSVPrinter csvPrinter) throws IOException{
        if(isExportingEvents){
            UnmodifiableObservableList<ReadOnlyTask> events = model.getFilteredEventList();
            printDataBody(csvPrinter, events);
        }
    }

```
###### /main/java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    private void printArchives(CSVPrinter csvPrinter) throws IOException{
        if(isExportingArchives){
            UnmodifiableObservableList<ReadOnlyTask> archives = model.getFilteredArchiveList();
            printDataBody(csvPrinter, archives);
        }
    }

```
###### /main/java/harmony/mastermind/logic/commands/ExportCommand.java
``` java
    /**
     * A helper method to print list of tasks into csv.
     * Due to the limitation of Google Calendar (must specify start and end date):
     *
     * - Floating tasks are assigned with dummy date (exported date) as their start and end date, in addition set the all day event as true.
     * - Deadlines will share the same start and end dates
     * - Event will and distinct start and end dates
     *
     * All tags are exported under descriptions
     *
     * @param csvPrinter CSVPrinter object
     * @param tasks list of tasks to print
     * @throws IOException if file is not writable
     */
    private void printDataBody(CSVPrinter csvPrinter, UnmodifiableObservableList<ReadOnlyTask> tasks) throws IOException {
        for (ReadOnlyTask task : tasks) {
            List<Object> data = new ArrayList<>();
            data.add(task.getName());
            if(task.isFloating()){
                Date dummyDate = new Date();
                data.add(GOOGLE_CALENDAR_DATE_FORMAT.format(dummyDate));
                data.add(GOOGLE_CALENDAR_TIME_FORMAT.format(dummyDate));
                data.add(GOOGLE_CALENDAR_DATE_FORMAT.format(dummyDate));
                data.add(GOOGLE_CALENDAR_TIME_FORMAT.format(dummyDate));
            } else if (task.isDeadline()){
                data.add(GOOGLE_CALENDAR_DATE_FORMAT.format(task.getEndDate()));
                data.add(GOOGLE_CALENDAR_TIME_FORMAT.format(task.getEndDate()));
                data.add(GOOGLE_CALENDAR_DATE_FORMAT.format(task.getEndDate()));
                data.add(GOOGLE_CALENDAR_TIME_FORMAT.format(task.getEndDate()));
            } else if (task.isEvent()){
                data.add(GOOGLE_CALENDAR_DATE_FORMAT.format(task.getStartDate()));
                data.add(GOOGLE_CALENDAR_TIME_FORMAT.format(task.getStartDate()));
                data.add(GOOGLE_CALENDAR_DATE_FORMAT.format(task.getEndDate()));
                data.add(GOOGLE_CALENDAR_TIME_FORMAT.format(task.getEndDate()));
            }
            data.add((task.isFloating())? "TRUE": "FALSE");
            data.add(task.getTags().toString().replaceAll(",", " "));
            data.add(null);
            data.add("TRUE");
            csvPrinter.printRecord(data);
        }
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    public static final String COMMAND_ARGUMENTS_REGEX = "(?=(?<index>\\d+))"
                                                        + "(?:(?=.*name to (?:(?<name>.+?)(?:;|$))?))?"
                                                        + "(?:(?=.*start date to (?:(?<startDate>.+?)(?:;|$))?))?"
                                                        + "(?:(?=.*end date to (?:(?<endDate>.+?)(?:;|$))?))?"
                                                        + "(?:(?=.*tags to #(?:(?<tags>.+?)(?:;|$))?))?"
                                                        + "(?:(?=.*recur (?<recur>daily|weekly|monthly|yearly)(?:;|$)))?"
                                                        + ".+";


    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);

    public static final String COMMAND_SUMMARY = "Editting a task:\n"
            + "(edit|update|change) <index> [name to <name>;] [start date to <start_date>;] [end date to <end_date>;] [recur (daily|weekly|monthly|yearly);] [tags to #<comma_separated_tags>;]";

    public static final String MESSAGE_USAGE = COMMAND_SUMMARY
                                               + "\n"
                                               + "Edits the task identified by the index number used in the last task listing.\n"
                                               + "Example: \n"
                                               + "edit 2 name to parents with dinner; end date to tomorrow 7pm; recur daily; tags to #meal,family";

    public static final String MESSAGE_EDIT_TASK_PROMPT = "Edit the following task: %1$s";
    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Task successfully edited: %1$s";

    public static final String MESSAGE_UNDO_SUCCESS = "[Undo Edit Command] Task reverted: %1$s";
    public static final String MESSAGE_REDO_SUCCESS = "[Redo Edit Command] Edit the following task: %1$s";

    // private MainWindow window;
    private ReadOnlyTask originalTask;
    private Task editedTask;

    private final int targetIndex;
    private Optional<String> name;
    private Optional<String> startDate;
    private Optional<String> endDate;
    private Optional<String> recur;
    private Optional<Set<String>> tags;
```
###### /main/java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    /*
     * Strategy implementation to undo the edit command
     * @see harmony.mastermind.logic.commands.Undoable#undo()
     */
    public CommandResult undo() {

        try {
            model.deleteTask(editedTask);

            // add back the original task
            model.addTask((Task) originalTask);

            model.pushToRedoHistory(this);

            requestHighlightLastActionedRow((Task)originalTask);

            return new CommandResult(COMMAND_KEYWORD_EDIT, String.format(MESSAGE_UNDO_SUCCESS, originalTask));
        } catch (UniqueTaskList.TaskNotFoundException pne) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, AddCommand.MESSAGE_DUPLICATE_TASK);
        }
    }

    @Override
```
###### /main/java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    /*
     * Strategy implementation to redo the edit command
     *
     * @see harmony.mastermind.logic.commands.Redoable#redo()
     */
    public CommandResult redo() {

        try {
            executeEdit();

            model.pushToUndoHistory(this);

            requestHighlightLastActionedRow(editedTask);

            return new CommandResult(COMMAND_KEYWORD_EDIT, String.format(MESSAGE_REDO_SUCCESS, originalTask));
        } catch (TaskNotFoundException | DuplicateTaskException | IndexOutOfBoundsException ie) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

```
###### /main/java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    private void executeEdit() throws TaskNotFoundException, DuplicateTaskException, IndexOutOfBoundsException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new IndexOutOfBoundsException();
        }

        if (originalTask == null) {
            originalTask = lastShownList.get(targetIndex - 1);
        }

        // if user provides explicit field and value, we change them
        // otherwise, all user omitted field are preserve from the original
        // before edit
        String toEditName = name.map(val -> val).orElse(originalTask.getName());
        Date toEditStartDate = startDate.map(val -> prettyTimeParser.parse(val).get(0)).orElse(originalTask.getStartDate());
        Date toEditEndDate = endDate.map(val -> prettyTimeParser.parse(val).get(0)).orElse(originalTask.getEndDate());
        String toEditRecur = recur.map(val -> val).orElse(originalTask.getRecur());
        UniqueTagList toEditTags = new UniqueTagList(tags.map(val -> {
            final Set<Tag> tagSet = new HashSet<>();
            for (String tagName : val) {
                try {
                    tagSet.add(new Tag(tagName));
                } catch (IllegalValueException e) {
                    e.printStackTrace();
                }
            }
            return tagSet;
        }).orElse(originalTask.getTags().toSet()));
        Date toEditCreatedDate = originalTask.getCreatedDate();


        // initialize the new task with edited values
        if (editedTask == null) {
            editedTask = new Task(toEditName, toEditStartDate, toEditEndDate, toEditTags, toEditRecur, toEditCreatedDate);
        }

        model.deleteTask(originalTask);
        model.addTask(editedTask);
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/DeleteCommand.java
``` java
    /** action to perform when ModelManager requested to undo this delete command **/
    public CommandResult undo() {
        try {
            model.addTask((Task) toDelete);

            model.pushToRedoHistory(this);

            requestHighlightLastActionedRow((Task) toDelete);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNDO_SUCCESS, toDelete));
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_WORD, AddCommand.MESSAGE_DUPLICATE_TASK);
        }
    }

    @Override
```
###### /main/java/harmony/mastermind/logic/commands/DeleteCommand.java
``` java
    /** action to perform when ModelManager requested to redo this delete command **/
    public CommandResult redo() {
        try {
            executeDelete();

            model.pushToUndoHistory(this);

        } catch (TaskNotFoundException | IndexOutOfBoundsException | ArchiveTaskList.TaskNotFoundException tnfe) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        return new CommandResult(COMMAND_WORD, String.format(MESSAGE_REDO_SUCCESS, toDelete));
    }

    private void executeDelete() throws TaskNotFoundException, IndexOutOfBoundsException, ArchiveTaskList.TaskNotFoundException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getCurrentList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new IndexOutOfBoundsException();
        }

        if (toDelete == null) {
            toDelete = lastShownList.get(targetIndex - 1);
        }

        if (toDelete.isMarked()) {
            model.deleteArchive(toDelete);
        }else {
            model.deleteTask(toDelete);
        }
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/ImportIcsCommand.java
``` java
/*
 * This command will read a .ics file and convert into Mastermind task.
 * This command cannot be undo/redo.
 */
public class ImportIcsCommand extends Command {

    public static final String COMMAND_KEYWORD_IMPORTICS = "importics";

    public static final String COMMAND_ARGUMENTS_REGEX = "from (?<source>.+)(?<=(?<extension>txt|csv|ics))";

    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);

    public static final String MESSAGE_EXAMPLE = "hint: remember to include the extension!\nimport from C:\\Users\\Jim\\jim@gmail.com.ics";

    public static final String MESSAGE_SUCCESS = "Imported ics.";

    public static final String MESSAGE_FAILURE = "Failed to import ics.";

    public static final String MESSAGE_FAILURE_DUPLICATE_TASK = "Failed to import ics. Duplicate task detected when importing.";

    private final String source;

    public ImportIcsCommand(String source) {
        this.source = source;
    }

    @Override
    public CommandResult execute() {

        try (FileInputStream fis = new FileInputStream(source)){
            ICalendar ical = Biweekly.parse(fis).first();

            for (VEvent event : ical.getEvents()) {
                Task task = parseTask(event);
                model.addTask(task);
            }

            return new CommandResult(COMMAND_KEYWORD_IMPORTICS, MESSAGE_SUCCESS);
        } catch (InvalidEventDateException | IOException e) {
            return new CommandResult(COMMAND_KEYWORD_IMPORTICS, MESSAGE_FAILURE);
        } catch (DuplicateTaskException e){
            return new CommandResult(COMMAND_KEYWORD_IMPORTICS, MESSAGE_FAILURE_DUPLICATE_TASK);
        } catch (IllegalValueException e){
            return new CommandResult(COMMAND_KEYWORD_IMPORTICS, MESSAGE_FAILURE);
        }
    }

    /**
     * This method will attempt to parse a ical's VEvent to a Mastermind Task Object
     *
     * @param event The ical VEvent Object to parse
     * @return the parsed Task object
     * @throws InvalidEventDateException if start date is after end date
     * @throws IllegalValueException if tags contains non-alphanumeric characters
     */
    private Task parseTask(VEvent event) throws InvalidEventDateException, IllegalValueException {
        TaskBuilder taskBuilder = new TaskBuilder(event.getSummary().getValue());
        taskBuilder.asEvent(event.getDateStart().getValue(), event.getDateEnd().getValue());
        taskBuilder.withTags(new HashSet<String>());
        return taskBuilder.build();
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/Redoable.java
``` java
public interface Redoable {
    /**
     * Specify the redo strategy according to the nature of the corresponding class.
     *
     * @return CommandResult, the Object contains details & feedback about the redo operation.
     */
    public CommandResult redo();
}
```
###### /main/java/harmony/mastermind/logic/commands/UndoCommand.java
``` java
public class UndoCommand extends Command{

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_SUCCESS = "Undo successfully.";
    public static final String MESSAGE_EMPTY_COMMAND_HISTORY = "There's no more action available to undo.";
    public static final String MESSAGE_COMMAND_NOT_UNDOABLE = "This command is not undoable";
    public static final String COMMAND_SUMMARY = "Undoing a command:"
            + "\n" + COMMAND_WORD;

    @Override
```
###### /main/java/harmony/mastermind/logic/commands/UndoCommand.java
``` java
    public CommandResult execute() {

        try{
            // All Command supports undo operation must implement Undoable interface

            // execute the undo strategy implemented by the underlying command
            CommandResult undoResult = model.undo();

            // display successful message and the details of the undo operations
            return new CommandResult(COMMAND_WORD,
                    MESSAGE_SUCCESS + "\n" +
                    "=====Undo Details=====\n" +
                    undoResult.feedbackToUser + "\n"+
                    "==================");
        }catch(EmptyStackException ex){
            return new CommandResult(COMMAND_WORD, MESSAGE_EMPTY_COMMAND_HISTORY);
        }
    }



}

```
###### /main/java/harmony/mastermind/logic/commands/AddCommandBuilder.java
``` java
/*
 * AddCommandBuilder provides a safe way to create an AddCommand
 *
 */
public class AddCommandBuilder {
    public String name;
    public Date startDate;
    public Date endDate;
    public Set<String> tags;
    public String recur;

    public AddCommandBuilder(String name) {
        this.name = name;
    }

    public AddCommandBuilder asEvent(Date startDate, Date endDate) throws InvalidEventDateException{
        if (startDate.after(endDate)) {
            throw new InvalidEventDateException();
        }

        this.startDate = startDate;
        this.endDate = endDate;
        return this;
    }

    public AddCommandBuilder asDeadline(Date endDate) {
        this.startDate = null;
        this.endDate = endDate;
        return this;
    }

    public AddCommandBuilder withTags(Set<String> tags) throws IllegalValueException {
        this.tags = tags;
        return this;
    }

    public AddCommandBuilder asRecurring(String recur) {
        this.recur = recur;
        return this;
    }

    public AddCommand build() throws IllegalValueException, InvalidEventDateException {
        return new AddCommand(this);
    }

    public boolean isFloating() {
        return startDate == null
               && endDate == null;
    }

    public boolean isDeadline() {
        return startDate == null
               && endDate != null;
    }

    public boolean isEvent() {
        return startDate != null
               && endDate != null;
    }

    public boolean isRecurring() {
        return this.recur != null;
    }

    public String getName() {
        return name;
    }

    public Date getStartDate() {
        return startDate;
    }

    public Date getEndDate() {
        return endDate;
    }

    public Set<String> getTags() {
        return tags;
    }

    public String getRecur() {
        return recur;
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/ImportCommand.java
``` java
/**
 * Reads either ics/csv/txt file and import the tasks into Mastermind
 */
public class ImportCommand extends Command {
    private static final int COUNT_ONE = 1;

    public static final String COMMAND_WORD = "import";

    public static final String MESSAGE_USAGE = COMMAND_WORD
                                               + ": Reads file and add all task from file into Mastermind\n"
                                               + "Parameters: File location\n"
                                               + "Example:\n"
                                               + "for Mac:\n"
                                               + COMMAND_WORD + "from"
                                               + " Users/Jim/Desktop/jim@gmail.com.ics\n"
                                               + "for Windows:\n"
                                               + COMMAND_WORD + "from"
                                               + " C:\\Users\\Jim\\jim@gmail.com.ics";

    public static final String COMMAND_ARGUMENTS_REGEX = "from (?<source>.+)(?<=(?<extension>txt|csv|ics))";
    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);

    public static final String MESSAGE_READ_SUCCESS = "Read success on imported file";
    public static final String MESSAGE_READ_FAILURE = "Invalid file path: %1$s";
    private static final String MESSAGE_CSV_READ_FAILURE = "Header in csv File is invalid\n"
                                                            + "First row of your csv file should include headers "
                                                            + "like Subject, Start Date, Start Time, End Date, End Time";
    public static final String MESSAGE_IMPORT_TXT_SUCCESS = "Import success: %1$s tasks added";
    public static final String MESSAGE_IMPORT_TXT_FAILURE = "Import failure: %1$s tasks added \nInvalid lines: %2$s";
    public static final String MESSAGE_IMPORT_ICS_SUCCESS = "Import ics success.";
    public static final String MESSAGE_IMPORT_ICS_FAILURE = "Failed to import ics.";

    public static final String MESSAGE_FAILURE_DUPLICATE_TASK = "Failed to import ics. Duplicate task detected when importing.";


    public static final String EXT_CSV = "csv";
    public static final String EXT_ICS = "ics";
    public static final String EXT_TXT = "txt";

    public static final String REGEX_COMMA = ",";

    public static final int NUMBER_TASK_ARGUMENTS = 5;

    public static final MimetypesFileTypeMap fileTypeMap = new MimetypesFileTypeMap();

    private String fileToImport;
    private String extension;
    private ArrayList<String> lstOfCmd;

    public ImportCommand(String filePath, String extension) {
        this.fileToImport = filePath.trim();
        this.extension = extension;
        lstOfCmd = new ArrayList<String>();
    }

```
###### /main/java/harmony/mastermind/logic/commands/ImportCommand.java
``` java
    private CommandResult importIcsFile() {

        try (FileInputStream fis = new FileInputStream(fileToImport)){
            ICalendar ical = Biweekly.parse(fis).first();

            for (VEvent event : ical.getEvents()) {
                Task task = parseTask(event);
                model.addTask(task);
            }

            return new CommandResult(COMMAND_WORD, MESSAGE_IMPORT_ICS_SUCCESS);
        } catch (DuplicateTaskException e){
            return new CommandResult(COMMAND_WORD, MESSAGE_FAILURE_DUPLICATE_TASK);
        } catch (InvalidEventDateException | IOException | IllegalValueException e) {
            return new CommandResult(COMMAND_WORD, MESSAGE_IMPORT_ICS_FAILURE);
        }
    }

    /**
     * This method will attempt to parse a ical's VEvent to a Mastermind Task Object
     *
     * @param event The ical VEvent Object to parse
     * @return the parsed Task object
     * @throws InvalidEventDateException if start date is after end date
     * @throws IllegalValueException if tags contains non-alphanumeric characters
     */
    private Task parseTask(VEvent event) throws InvalidEventDateException, IllegalValueException {
        TaskBuilder taskBuilder = new TaskBuilder(event.getSummary().getValue());
        taskBuilder.asEvent(event.getDateStart().getValue(), event.getDateEnd().getValue());
        taskBuilder.withTags(new HashSet<String>());
        return taskBuilder.build();
    }


}
```
###### /main/java/harmony/mastermind/logic/commands/ActionHistoryCommand.java
``` java
/**
 *
 * Command to toggle ActionHistory in UI
 *
 * This command takes no parameter.
 * @author kfwong
 *
 */
public class ActionHistoryCommand extends Command {

    public static final String COMMAND_KEYWORD_ACTIONHISTORY = "actionhistory";

    public static final String MESSAGE_SUCCESS = "Action history toggled.";

    @Override
    public CommandResult execute() {

        requestToggleActionHistory();
        return new CommandResult(COMMAND_KEYWORD_ACTIONHISTORY, MESSAGE_SUCCESS);

    }

    private void requestToggleActionHistory() {
        EventsCenter.getInstance().post(new ToggleActionHistoryEvent());
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/UnmarkCommand.java
``` java
    @Override
    /*
     * Strategy to undo unmark command
     *
     * @see harmony.mastermind.logic.commands.Undoable#undo()
     */
    public CommandResult undo() {
        try {
            // remove the task that's previously added.
            model.markTask(taskToUnmark);

            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNDO_SUCCESS, taskToUnmark));
        } catch (UniqueTaskList.TaskNotFoundException e) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        }
    }

    @Override
```
###### /main/java/harmony/mastermind/logic/commands/UnmarkCommand.java
``` java
    /*
     *
     * Strategy to redo unmark command
     *
     * @see harmony.mastermind.logic.commands.Redoable#redo()
     */
    public CommandResult redo() {
        try {
            executeUnmark();

            model.pushToUndoHistory(this);

            requestHighlightLastActionedRow(taskToUnmark);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNMARK_SUCCESS, taskToUnmark));
        } catch (DuplicateTaskException dte) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_DUPLICATE_UNMARK_TASK, taskToUnmark));
        } catch (TaskNotFoundException tnfe) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

```
###### /main/java/harmony/mastermind/ui/ActionHistoryEntry.java
``` java
public class ActionHistoryEntry extends UiPart{

    private static final String FXML = "ActionHistoryItem.fxml";

    @FXML
    private HBox actionHistoryItem;

    @FXML
    private Label title;

    @FXML
    private Label date;

    public void setTitle(String title){
        this.title.setText(title);
    }

    public void setDate(String date){
        this.date.setText(date);
    }

    public Node getNode(){
        return actionHistoryItem;
    }

    public void setTypeFail(){
        this.title.setStyle("-fx-text-fill: crimson;");
        this.date.setStyle("-fx-text-fill: crimson;");
    }

    public void setTypeSuccess(){
        this.title.setStyle("-fx-text-fill: deepSkyBlue;");
        this.date.setStyle("-fx-text-fill: deepSkyBlue;");
    }

    @Override
    public void setNode(Node node) {
        actionHistoryItem = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }



}

```
###### /main/java/harmony/mastermind/ui/ActionHistoryEntry.java
``` java
class ActionHistory {
    private final String title;
    private final String description;
    private final Date dateActioned;

    public ActionHistory(String title, String description){
        this.title = title;
        this.description = description;
        this.dateActioned = new Date();
    }

    public String getTitle() {
        return title;
    }

    public String getDescription() {
        return description;
    }

    public Date getDateActioned() {
        return dateActioned;
    }
}
```
###### /main/java/harmony/mastermind/ui/UiManager.java
``` java
    @Subscribe
    private void handleExecuteCommandEvent(ExecuteCommandEvent event){
        mainWindow.pushToActionHistory(event.title, event.description);
    }
```
###### /main/java/harmony/mastermind/ui/UiManager.java
``` java
    @Subscribe
    private void handleHighlightLastActionedRowRequestEvent(HighlightLastActionedRowRequestEvent event){
        mainWindow.highlightLastActionedRow(event.task);
    }
```
###### /main/java/harmony/mastermind/ui/UiManager.java
``` java
    @Subscribe
    private void handleToggleActionHistoryRequest(ToggleActionHistoryEvent event){
        mainWindow.toggleActionHistory();
    }
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    // init only one parser for all parsing, save memory and computation time
    private static final PrettyTime prettyTime = new PrettyTime();
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    public static MainWindow load(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {

        MainWindow mainWindow = UiPartLoader.loadUiPart(primaryStage, new MainWindow());
        mainWindow.configure(config.getAppTitle(), config.getTaskManagerName(), config, prefs, logic);
        return mainWindow;
    }
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initActionHistory(ListView<ActionHistory> actionHistory) {

        actionHistory.setOnMouseClicked(value -> {
            consoleOutput.setText(actionHistory.getSelectionModel().getSelectedItem().getDescription());
        });
        actionHistory.setCellFactory(listView -> {
            ListCell<ActionHistory> actionCell = new ListCell<ActionHistory>() {

                @Override
                protected void updateItem(ActionHistory item, boolean isEmpty) {
                    super.updateItem(item, isEmpty);

                    if (!isEmpty) {

                        ActionHistoryEntry actionHistoryEntry = UiPartLoader.loadUiPart(new ActionHistoryEntry());

                        actionHistoryEntry.setTitle(item.getTitle().toUpperCase());
                        actionHistoryEntry.setDate(item.getDateActioned().toString().toUpperCase());

                        if (item.getTitle().toUpperCase().equals("INVALID COMMAND")) {
                            actionHistoryEntry.setTypeFail();
                        } else {
                            actionHistoryEntry.setTypeSuccess();
                        }

                        this.setGraphic(actionHistoryEntry.getNode());

                        this.setPrefHeight(50);
                        this.setPrefWidth(250);

                        this.setContentDisplay(ContentDisplay.GRAPHIC_ONLY);
                    } else {
                        this.setGraphic(null);
                    }
                }
            };

            return actionCell;
        });
    }

    /**
     * Initializes the indexing of tasks
     */
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initIndex(TableColumn<ReadOnlyTask, ReadOnlyTask> indexColumn) {
        indexColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_INDEX));

        indexColumn.setCellFactory(column -> new TableCell<ReadOnlyTask, ReadOnlyTask>() {
            @Override
            public void updateIndex(int index) {
                super.updateIndex(index);

                Text indexText = new Text(Integer.toString(index+ 1)+".");
                indexText.getStyleClass().add("index-column");


                if (isEmpty()
                    || index < 0) {
                    this.setGraphic(null);
                } else {
                    this.setGraphic(indexText);
                }
            }

        });
    }

    /**
     * Initialize the Names of the tasks
     */
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initName(TableColumn<ReadOnlyTask, ReadOnlyTask> nameColumn) {
        nameColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_NAME));
        nameColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));

        nameColumn.setCellFactory(col -> new TableCell<ReadOnlyTask, ReadOnlyTask>() {

            @Override
            public void updateItem(ReadOnlyTask readOnlyTask, boolean isEmpty) {
                super.updateItem(readOnlyTask, isEmpty);

                if (!isEmpty()) {

                    VBox vBox = new VBox(3);

                    Text taskName = generateStyledText(readOnlyTask, readOnlyTask.getName());
                    taskName.getStyleClass().add("task-name-column");
                    vBox.getChildren().add(taskName);

                    HBox hBox = new HBox(5);

                    Button status = new Button();
                    if (readOnlyTask.isHappening()) {
                        status.setText("HAPPENING");
                        status.getStyleClass().add("tag-happening");
                        hBox.getChildren().add(status);
                    } else if (readOnlyTask.isDue()) {
                        status.setText("DUE");
                        status.getStyleClass().add("tag-overdue");
                        hBox.getChildren().add(status);
                    }

                    if (readOnlyTask.isEvent()) {
                        Button eventDuration = new Button();
                        eventDuration.setText("DURATION: "
                                              + DurationFormatUtils.formatDurationWords(readOnlyTask.getEventDuration().toMillis(), true, true).toUpperCase());
                        eventDuration.getStyleClass().add("tag-event-duration");
                        hBox.getChildren().add(eventDuration);
                    } else if (readOnlyTask.isDeadline()
                               && !readOnlyTask.isDue()) {
                        Button dueDuration = new Button();
                        dueDuration.setText("DUE IN "
                                            + DurationFormatUtils.formatDurationWords(readOnlyTask.getDueDuration().toMillis(), true, true));
                        dueDuration.getStyleClass().add("tag-due-duration");
                        hBox.getChildren().add(dueDuration);
                    }

                    vBox.getChildren().add(hBox);

                    this.setGraphic(vBox);
                    this.setPrefHeight(50);

                } else {
                    this.setGraphic(null);
                }

            }
        });

    }

    /*
     * Generate styled row base on the task status: due(red), happening(orange),
     * normal(blue)
     *
     */
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private Text generateStyledText(ReadOnlyTask readOnlyTask, String text) {
        Text taskName = new Text(text);

        if (readOnlyTask.isHappening()) {
            taskName.getStyleClass().add("happening");
        } else if (readOnlyTask.isDue()) {
            taskName.getStyleClass().add("overdue");
        } else {
            taskName.getStyleClass().add("normal");
        }
        return taskName;
    }

    /**
     * Initialize the start dates of the tasks
     */
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initStartDate(TableColumn<ReadOnlyTask, ReadOnlyTask> startDateColumn) {
        startDateColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_STARTDATE));
        startDateColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));

        startDateColumn.setCellFactory(col -> new TableCell<ReadOnlyTask, ReadOnlyTask>() {

            @Override
            public void updateItem(ReadOnlyTask readOnlyTask, boolean isEmpty) {
                super.updateItem(readOnlyTask, isEmpty);
                if (!isEmpty()
                    && readOnlyTask.getStartDate() != null) {

                    TextFlow textFlow = new TextFlow();

                    Text prettyDate = generateStyledText(readOnlyTask, prettyTime.format(readOnlyTask.getStartDate()));
                    prettyDate.getStyleClass().add("pretty-date");

                    Text lineBreak = new Text("\n\n");
                    lineBreak.setStyle("-fx-font-size:2px;");

                    Text uglyDate = generateStyledText(readOnlyTask, readOnlyTask.parse(readOnlyTask.getStartDate()));
                    uglyDate.getStyleClass().add("ugly-date");

                    textFlow.getChildren().add(prettyDate);
                    textFlow.getChildren().add(lineBreak);
                    textFlow.getChildren().add(uglyDate);

                    this.setGraphic(textFlow);
                    this.setPrefHeight(50);

                } else {
                    this.setGraphic(null);
                }

            }
        });

    }

    /**
     * Initialize the end dates of the tasks
     */
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initEndDate(TableColumn<ReadOnlyTask, ReadOnlyTask> endDateColumn) {
        endDateColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_ENDDATE));
        endDateColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));

        endDateColumn.setCellFactory(col -> new TableCell<ReadOnlyTask, ReadOnlyTask>() {

            @Override
            public void updateItem(ReadOnlyTask readOnlyTask, boolean isEmpty) {
                super.updateItem(readOnlyTask, isEmpty);
                if (!isEmpty()
                    && readOnlyTask.getEndDate() != null) {

                    TextFlow textFlow = new TextFlow();

                    Text prettyDate = generateStyledText(readOnlyTask, prettyTime.format(readOnlyTask.getEndDate()));
                    prettyDate.getStyleClass().add("pretty-date");

                    Text lineBreak = new Text("\n\n");
                    lineBreak.setStyle("-fx-font-size:2px;");

                    Text uglyDate = generateStyledText(readOnlyTask, readOnlyTask.parse(readOnlyTask.getEndDate()));
                    uglyDate.getStyleClass().add("ugly-date");

                    textFlow.getChildren().add(prettyDate);
                    textFlow.getChildren().add(lineBreak);
                    textFlow.getChildren().add(uglyDate);

                    this.setGraphic(textFlow);
                    this.setPrefHeight(50);

                } else {
                    this.setGraphic(null);
                }

            }
        });

    }

    /**
     * Initialize the tags of the tasks
     */
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initTags(TableColumn<ReadOnlyTask, ReadOnlyTask> tagsColumn) {
        tagsColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_TAGS));
        tagsColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));

        tagsColumn.setCellFactory(col -> new TableCell<ReadOnlyTask, ReadOnlyTask>() {

            @Override
            public void updateItem(ReadOnlyTask readOnlyTask, boolean isEmpty) {
                super.updateItem(readOnlyTask, isEmpty);
                if (!isEmpty()
                    && readOnlyTask.getTags() != null) {

                    HBox tags = new HBox(5);

                    for (Tag tag : readOnlyTask.getTags()) {
                        Button tagBubble = new Button();
                        tagBubble.setText(tag.tagName);
                        tagBubble.getStyleClass().add("tag");
                        tags.getChildren().add(tagBubble);
                    }

                    this.setGraphic(tags);
                } else {
                    this.setGraphic(null);
                }
            }
        });

    }

```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    public void highlightLastActionedRow(Task task){
        taskTableHome.getSelectionModel().select(task);
        taskTableHome.scrollTo(task);
    }

```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    public void toggleActionHistory(){
        actionHistoryMini.setExpanded(!actionHistoryMini.isExpanded());
    }
```
