# A0138862W
###### /java/harmony/mastermind/commons/events/ui/ExecuteCommandEvent.java
``` java
public class ExecuteCommandEvent extends BaseEvent{

    public Date dateExecuted;
    public String title;
    public String description;
    
```
###### /java/harmony/mastermind/commons/events/ui/ExecuteCommandEvent.java
``` java
    public ExecuteCommandEvent(String title, String description){
        dateExecuted = new Date();
        
        this.title = title;
        this.description = description;
    }

```
###### /java/harmony/mastermind/commons/events/ui/ExecuteCommandEvent.java
``` java
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    
    

}
```
###### /java/harmony/mastermind/commons/exceptions/TaskAlreadyMarkedException.java
``` java
    public TaskAlreadyMarkedException(){
        super();
    }
}
```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
public class AddCommand extends Command implements Undoable, Redoable {

    public static final String COMMAND_KEYWORD_ADD = "add";
    public static final String COMMAND_KEYWORD_DO = "do";
    public static final String[] COMMAND_KEYWORDS_RECUR = {"daily", "weekly", "biweekly", "monthly", "yearly"};

    // The main idea of capturing parameters in any order is inspired by (author
    // velop):
    // http://stackoverflow.com/questions/1177081/mulitple-words-in-any-order-using-regex

    // As for capturing optional group AND in any order:
    // http://stackoverflow.com/questions/24472120/match-optional-components-in-any-order

    // We wrote the regular expression and tested at:
    // https://regex101.com/r/bFQrP6/1
```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public static final String COMMAND_ARGUMENTS_REGEX = "(?=(?:.*?r\\/'(?<recur>.+?)')?)" 
                                                         + "(?=(?:.*?\\s\\'(?<name>.+?)'))"
                                                         + "(?=(?:.*?sd\\/'(?<startDate>.+?)')?)"
                                                         + "(?=(?:.*?ed\\/'(?<endDate>.+?)')?)"
                                                         + "(?=(?:.*t\\/'(?<tags>\\w+(?:,\\w+)*)?')?)"
                                                         + ".*";

    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);

    public static final String COMMAND_FORMAT = "(add|do) [r/'<recur>'] '<name>' [sd/'<startDate>'] [ed/'<endDate>'] [t/'<tags>...']";

    public static final String MESSAGE_EXAMPLE_EVENT = "add 'attend workshop' sd/'today 7pm' ed/'next monday 1pm' t/'programming,java'";
    public static final String MESSAGE_EXAMPLE_DEADLINE = "add 'submit homework' ed/'next sunday 11pm' t/'math,physics'";
    public static final String MESSAGE_EXAMPLE_FLOATING = "do 'chores' t/'cleaning'";
    public static final String MESSAGE_EXAMPLE_RECUR_DEADLINE = "add r/'weekly' 'submit homework' ed/'next sunday 11pm' t/'math,physics'";
    public static final String MESSAGE_EXAMPLE_RECUR_EVENT = "add r/'daily 2' 'attend workshop' sd/'today 7pm' ed/'next monday 1pm' t/'programming,java'";
    
    public static final String MESSAGE_EXAMPLES = new StringBuilder()
                                                    .append("[Format]\n")
                                                    .append(COMMAND_FORMAT+ "\n\n")
                                                    .append("[Examples]:\n")
                                                    .append("Event: "+ MESSAGE_EXAMPLE_EVENT+"\n")
                                                    .append("Deadline: "+MESSAGE_EXAMPLE_DEADLINE+"\n")
                                                    .append("Floating: "+MESSAGE_EXAMPLE_FLOATING)
                                                    .append("Recurring Deadline: "+MESSAGE_EXAMPLE_RECUR_DEADLINE)
                                                    .append("Recur Event twice: "+MESSAGE_EXAMPLE_RECUR_EVENT)
                                                    .toString();

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_UNDO_SUCCESS = "[Undo Add Command] Task deleted: %1$s";
    public static final String MESSAGE_REDO_SUCCESS = "[Redo Add Command] Task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in Mastermind";

    private final Task toAdd;

    /**
     * Convenience constructor using raw values.<br><br>
     *
     * Throws IllegalValueException if any of the raw values are invalid<br>
     * Throws InvalidEventDateException if event type has start date after end date
     */
    // event
```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public AddCommand(String name, String endDateStr, Set<String> tags, String recur) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }

        // fix for #132
        List<Date> endDates = prettyTimeParser.parse(endDateStr);
        Date endDate = (endDates.isEmpty())? null: endDates.get(0);
        
        this.toAdd = new Task(name, endDate, new UniqueTagList(tagSet), recur);

    }

    // floating
```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public AddCommand(String name, Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }

        this.toAdd = new Task(name, new UniqueTagList(tagSet));
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            executeAdd();
            
            // push this command into undoHistory
            model.pushToUndoHistory(this);
            
            // this is a new command entered by user (not undo/redo)
            // need to clear the redoHistory Stack 
            model.clearRedoHistory();

            return new CommandResult(COMMAND_KEYWORD_ADD,String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(COMMAND_KEYWORD_ADD,MESSAGE_DUPLICATE_TASK);
        }

    }

    @Override
    /** action to perform when ModelManager requested to undo this command **/
```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public CommandResult undo() {
        try {
            // remove the task that's previously added.
            model.deleteTask(toAdd);
            
            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_KEYWORD_ADD,String.format(MESSAGE_UNDO_SUCCESS, toAdd));
        } catch (UniqueTaskList.TaskNotFoundException pne) {
            return new CommandResult(COMMAND_KEYWORD_ADD,Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        }
    }

    @Override
    /** action to perform when ModelManager requested to redo this command**/
```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public CommandResult redo() {
        assert model != null;
        try {
            executeAdd();
            
            model.pushToUndoHistory(this);

            return new CommandResult(COMMAND_KEYWORD_ADD,String.format(MESSAGE_REDO_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(COMMAND_KEYWORD_ADD,MESSAGE_DUPLICATE_TASK);
        }        
    }
    
    /** extract method since it's reusable for execute() and redo()**/
    private void executeAdd() throws DuplicateTaskException {
        model.addTask(toAdd);
    }

}
```
###### /java/harmony/mastermind/logic/commands/Command.java
``` java
    protected static final PrettyTimeParser prettyTimeParser = new PrettyTimeParser();
    
    protected Model model;
    protected Storage storage;

    /**
     * Constructs a feedback message to summarise an operation that displayed a listing of tasks.
     *
     * @param displaySize used to generate summary
     * @return summary message for tasks displayed
     */
    public static String getMessageForTaskListShownSummary(int displaySize) {
        return String.format(Messages.MESSAGE_TASKS_LISTED_OVERVIEW, displaySize);
    }

    /**
     * Executes the command and returns the result message.
     *
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult execute();

    /**
     * Provides any needed dependencies to the command.
     * Commands making use of any of these should override this method to gain
     * access to the dependencies.
     */
    public void setData(Model model, Storage storage) {
        this.model = model;
        this.storage = storage;
    }

    /**
     * Raises an event to indicate an attempt to execute an incorrect command
     */
    protected void indicateAttemptToExecuteIncorrectCommand() {
        EventsCenter.getInstance().post(new IncorrectCommandAttemptedEvent(this));
    }
    
}
```
###### /java/harmony/mastermind/logic/commands/DeleteCommand.java
``` java
    public CommandResult undo() {
        try {
            // add back the task that's previously added.
            model.addTask((Task) toDelete);

            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNDO_SUCCESS, toDelete));
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_WORD, AddCommand.MESSAGE_DUPLICATE_TASK);
        }
    }

    @Override
```
###### /java/harmony/mastermind/logic/commands/DeleteCommand.java
``` java
    public CommandResult redo() {
        try {
            executeDelete();

            model.pushToUndoHistory(this);

        } catch (TaskNotFoundException | IndexOutOfBoundsException | ArchiveTaskList.TaskNotFoundException tnfe) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        return new CommandResult(COMMAND_WORD, String.format(MESSAGE_REDO_SUCCESS, toDelete));
    }

    private void executeDelete() throws TaskNotFoundException, IndexOutOfBoundsException, ArchiveTaskList.TaskNotFoundException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getCurrentList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new IndexOutOfBoundsException();
        }

        if (toDelete == null) {
            toDelete = lastShownList.get(targetIndex - 1);
        }

        if (toDelete.isMarked()) {
            model.deleteArchive(toDelete);
        }else {
            model.deleteTask(toDelete);
        }
    }

}
```
###### /java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    public CommandResult undo() {

        try {
            // remove the task that's previously edited
            model.deleteTask(editedTask);

            // add back the original task
            model.addTask((Task) originalTask);

            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_KEYWORD_EDIT, String.format(MESSAGE_UNDO_SUCCESS, originalTask));
        } catch (UniqueTaskList.TaskNotFoundException pne) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, AddCommand.MESSAGE_DUPLICATE_TASK);
        }
    }

    @Override
```
###### /java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    public CommandResult redo() {

        try {
            executeEdit();

            model.pushToUndoHistory(this);

            return new CommandResult(COMMAND_KEYWORD_EDIT, String.format(MESSAGE_REDO_SUCCESS, originalTask));
        } catch (TaskNotFoundException | DuplicateTaskException | IndexOutOfBoundsException ie) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

    private void executeEdit() throws TaskNotFoundException, DuplicateTaskException, IndexOutOfBoundsException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new IndexOutOfBoundsException();
        }

        if (originalTask == null) {
            originalTask = lastShownList.get(targetIndex
                                             - 1);
        }

        // if user provides explicit field and value, we change them
        // otherwise, all user omitted field are preserve from the original
        // before edit
        String toEditName = name.map(val -> val).orElse(originalTask.getName());
        Date toEditStartDate = startDate.map(val -> prettyTimeParser.parse(val).get(0)).orElse(originalTask.getStartDate());
        Date toEditEndDate = endDate.map(val -> prettyTimeParser.parse(val).get(0)).orElse(originalTask.getEndDate());
        String toEditRecur = recur.map(val -> val).orElse(originalTask.getRecur());
        UniqueTagList toEditTags = new UniqueTagList(tags.map(val -> {
            final Set<Tag> tagSet = new HashSet<>();
            for (String tagName : val) {
                try {
                    tagSet.add(new Tag(tagName));
                } catch (IllegalValueException e) {
                    e.printStackTrace();
                }
            }
            return tagSet;
        }).orElse(originalTask.getTags().toSet()));

        // initialize the new task with edited values
        if (editedTask == null) {
            editedTask = new Task(toEditName, toEditStartDate, toEditEndDate, toEditTags, toEditRecur);
        }

        model.deleteTask(originalTask);
        model.addTask(editedTask);
    }

}
```
###### /java/harmony/mastermind/logic/commands/MarkCommand.java
``` java
    public CommandResult undo() {
        try {
            // remove the task that's previously added.
            model.unmarkTask(taskToMark);

            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNDO_SUCCESS, taskToMark));
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_WORD, String.format(UnmarkCommand.MESSAGE_DUPLICATE_UNMARK_TASK, taskToMark));
        } catch (ArchiveTaskList.TaskNotFoundException e) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        }
    }

    @Override
```
###### /java/harmony/mastermind/logic/commands/MarkCommand.java
``` java
    public CommandResult redo() {
        try {
            executeMark();

            model.pushToUndoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_REDO_SUCCESS, taskToMark));
        } catch (TaskAlreadyMarkedException ex) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_MARKED_TASK, taskToMark));
        } catch (IndexOutOfBoundsException ex) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(COMMAND_WORD,Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_WORD,MESSAGE_MARK_RECURRING_FAILURE);
        } catch (NotRecurringTaskException e) {
            return new CommandResult(COMMAND_WORD,MESSAGE_MARK_RECURRING_FAILURE);

        }
    }

```
###### /java/harmony/mastermind/logic/commands/Redoable.java
``` java
    public CommandResult redo();
}
```
###### /java/harmony/mastermind/logic/commands/RedoCommand.java
``` java
    public CommandResult execute() {

        try{
            // All Command supports undo operation must implement Redoable interface
            
            // execute the redo implementation
            CommandResult redoResult = model.redo();
            
            // display successful message and the details of the undo operations
            return new CommandResult(COMMAND_WORD, 
                    MESSAGE_SUCCESS + "\n" +
                    "=====Redo Details=====\n" +
                    redoResult.feedbackToUser + "\n"+
                    "==================");
        }catch(EmptyStackException ex){
            return new CommandResult(COMMAND_WORD, MESSAGE_EMPTY_COMMAND_HISTORY);
        }
    }

}
```
###### /java/harmony/mastermind/logic/commands/Undoable.java
``` java
    public CommandResult undo();
    
}
```
###### /java/harmony/mastermind/logic/commands/UndoCommand.java
``` java
    public CommandResult execute() {

        try{
            // All Command supports undo operation must implement Undoable interface
            
            // execute the undo implementation
            CommandResult undoResult = model.undo();
            
            // display successful message and the details of the undo operations
            return new CommandResult(COMMAND_WORD, 
                    MESSAGE_SUCCESS + "\n" +
                    "=====Undo Details=====\n" +
                    undoResult.feedbackToUser + "\n"+
                    "==================");
        }catch(EmptyStackException ex){
            return new CommandResult(COMMAND_WORD, MESSAGE_EMPTY_COMMAND_HISTORY);
        }
    }
    
    

}

```
###### /java/harmony/mastermind/logic/commands/UnmarkCommand.java
``` java
    public CommandResult undo() {
        try {
            // remove the task that's previously added.
            model.markTask(taskToUnmark);
            
            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNDO_SUCCESS, taskToUnmark));
        } catch (UniqueTaskList.TaskNotFoundException e) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        }
    }

    @Override
```
###### /java/harmony/mastermind/logic/commands/UnmarkCommand.java
``` java
    public CommandResult redo() {
        try {
            executeUnmark();
            
            model.pushToUndoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNMARK_TASK_SUCCESS, taskToUnmark));
        } catch (TaskAlreadyUnmarkedException tau) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNMARK_TASK_FAILURE, taskToUnmark));
        } catch (DuplicateTaskException dte) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_DUPLICATE_UNMARK_TASK, taskToUnmark));
        } catch (TaskNotFoundException tnfe) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    private Command prepareAdd(String args) {
        final Matcher matcher = AddCommand.COMMAND_ARGUMENTS_PATTERN.matcher(args);

        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_EXAMPLES));
        }

        try {

            // mandatory
            // there's no need to check for existence as the regex only capture full match of mandatory components
            final String name = matcher.group("name");

            // optionals
            final Optional<String> recur = Optional.ofNullable(matcher.group("recur"));
            final Optional<String> startDate = Optional.ofNullable(matcher.group("startDate"));
            final Optional<String> endDate = Optional.ofNullable(matcher.group("endDate"));
            final Optional<String> tags = Optional.ofNullable(matcher.group("tags"));
           
            
            // return internal value if present. else, return empty string
            Set<String> tagSet = getTagsFromArgs(tags.map(val -> val).orElse(""));
            String recurVal = null;
            
            //check if recur has a valid keyword
            if (recur.isPresent()) {
                String key = recur.get().split(" ")[0];
                if (!Arrays.asList(AddCommand.COMMAND_KEYWORDS_RECUR).contains(key)) {
                    return new IncorrectCommand("invalid recurring value");
                }
                recurVal = recur.get();
            }
            
            if (startDate.isPresent() && endDate.isPresent()) {
                // event
                String start = startDate.get().toLowerCase();
                String end = endDate.get().toLowerCase();
                
                if (start.equals("today")) {
                    start += " 2359";
                }else if (start.equals("tomorrow")) {
                    start += " 2359";
                }
                if (end.equals("today")) {
                    end += " 2359";
                }else if (start.equals("tomorrow")) {
                    end += " 2359";
                }
                
                
                try {
                    return new AddCommand(name, start, end, tagSet, recurVal);
                } catch (InvalidEventDateException iede) {
                    return new IncorrectCommand(iede.getMessage());
                }
            } else if (!startDate.isPresent() && endDate.isPresent()) {
                // deadline
                String end = endDate.get().toLowerCase();
                
                if (end.equals("today")) {
                    end += " 2359";
                }else if (end.equals("tomorrow")) {
                    end += " 2359";
                }
                
                return new AddCommand(name, end, tagSet, recurVal);
            } else if (startDate.isPresent() && !endDate.isPresent()) {
                // task with only startdate is not supported.
                throw new IllegalValueException("Cannot create a task with only start date.");
            } else {
                // floating
                return new AddCommand(name, tagSet);
            }

        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
    
    /**
     * Parses arguments in the context of the edit task command.
     * 
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareEdit(String args) {
        final Matcher matcher = EditCommand.COMMAND_ARGUMENTS_PATTERN.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        try {
            
            // mandatory
            // regex accept only numbers in index field, encountering NumberFormatException is impossible
            final int index = Integer.parseInt(matcher.group("index"));
            
            //optional
            final Optional<String> recur = Optional.ofNullable(matcher.group("recur"));
            final Optional<String> name = Optional.ofNullable(matcher.group("name"));
            final Optional<String> startDate = Optional.ofNullable(matcher.group("startDate"));
            final Optional<String> endDate = Optional.ofNullable(matcher.group("endDate"));
            final Optional<String> tags = Optional.ofNullable(matcher.group("tags"));
            
            Optional<Set<String>> tagSet = Optional.empty();
            if(tags.isPresent()){
                tagSet = Optional.ofNullable(getTagsFromArgs(tags.get()));
            };
            
            return new EditCommand(index, name, startDate, endDate, tagSet, recur);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (ParseException pe) {
            return new IncorrectCommand(pe.getMessage());

        }

    }

    /**
     * Extracts the new task's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     */
    private static Set<String> getTagsFromArgs(String tagArguments) throws IllegalValueException {
        // no tags
        if (Strings.isNullOrEmpty(tagArguments)) {
            return Collections.emptySet();
        }
        // replace first delimiter prefix, then split
        final Collection<String> tagStrings = Arrays.asList(tagArguments.split(","));
        return new HashSet<>(tagStrings);
    }

    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }
        Command result = new DeleteCommand(index.get());

        return result;
    }

    /**
     * Parses arguments in the context of the mark task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public void pushToUndoHistory(Undoable command) {
        undoHistory.push(command);
    }
    
    @Override
    
    /** undo last action performed**/
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public CommandResult undo() throws EmptyStackException{
        CommandResult commandResult = undoHistory.pop().undo();
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return commandResult;
    }
    
    @Override
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public void pushToRedoHistory(Redoable command){
        redoHistory.push(command);
    }
    
    @Override
    /** redo the action that being undone function**/
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public CommandResult redo() throws EmptyStackException{
        CommandResult commandResult = redoHistory.pop().redo();
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return commandResult;
    }
    
    @Override
    /** This method should only be called when the user entered a new command other than redo/undo **/
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public void clearRedoHistory(){
        redoHistory.clear();
    }
    
```
###### /java/harmony/mastermind/model/tag/UniqueTagList.java
``` java
    public String toString(){
        // functional way to transform list of items into concatenated string joining with commas (JAVA 8)
        return this.getInternalList().stream().map(Object::toString).collect(Collectors.joining(","));
    }
}
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public Task(String name, Date startDate, Date endDate, UniqueTagList tags, String recur) {
        this.name = name;
        this.startDate = startDate;
        this.endDate = endDate;
        this.tags = tags;
        this.marked = false;
        this.recur = recur;
    }

    // deadline
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public Task(String name, Date endDate, UniqueTagList tags, String recur) {
        this(name, null, endDate, tags, recur);
    }

    // floating
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public Task(String name, UniqueTagList tags) {
        this(name, null, null, tags, null);
    }

```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getStartDate(), source.getEndDate(), source.getTags(), source.getRecur());
        this.marked = source.isMarked();
    }

    @Override
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isFloating() {
        return startDate == null && endDate == null;
    }

    @Override
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isDeadline() {
        return startDate == null && endDate != null;
    }

    @Override
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isEvent() {
        return startDate != null && endDate != null;
    }

```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isDue(){        
        if(isDeadline()){
            Date now = new Date();
            if(now.after(endDate)){
                return true;
            }else{
                return false;
            }
        }else if(isEvent()){
            Date now = new Date();
            if(now.after(startDate) && now.after(endDate)){
                return true;
            }else{
                return false;
            }
        }else{
            return false;
        }
    }

```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isHappening(){
        if(isEvent()){
            Date now = new Date();
            if(now.after(startDate) && now.before(endDate)){
                return true;
            }else{
                return false;
            }
        }
        return false;
    }
    
    public Duration getEventDuration(){
        if(isEvent()){
            long differencel = endDate.getTime() - startDate.getTime();
            
            return Duration.of(differencel, ChronoUnit.MILLIS);
        }else{
            return null;
        }
    }
    
    /*
     * calculate the duration until due date
     * 
     */
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public Duration getDueDuration(){
        if(endDate != null){
            long nowl = System.currentTimeMillis();
            long endDatel = endDate.getTime();
            
            long differencel = endDatel - nowl;
            
            return Duration.of(differencel, ChronoUnit.MILLIS);
        }else{
            return null;
        }
    }
}
```
###### /java/harmony/mastermind/storage/XmlAdaptedTask.java
``` java
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName();

        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        
        final String name = this.name;
        final UniqueTagList tags = new UniqueTagList(taskTags);
        
        return new Task(name, tags);
    }
}
```
###### /java/harmony/mastermind/ui/ActionHistoryEntry.java
``` java
public class ActionHistoryEntry extends UiPart{

    private static final String FXML = "ActionHistoryItem.fxml";
    
    @FXML
    private HBox actionHistoryItem;
    
    @FXML
    private Label title;
    
    @FXML
    private Label date;
    
    @FXML
    private Label description;
    
    public void setTitle(String title){
        this.title.setText(title);
    }
    
    public void setDate(String date){
        this.date.setText(date);
    }
    
    public void setDescription(String description){
        this.description.setText(description);
    }
    
    public Node getNode(){
        return actionHistoryItem;
    }
    
    public void setTypeFail(){
        this.title.setStyle("-fx-text-fill: crimson;");
        this.date.setStyle("-fx-text-fill: crimson;");
    }
    
    public void setTypeSuccess(){
        this.title.setStyle("-fx-text-fill: deepSkyBlue;");
        this.date.setStyle("-fx-text-fill: deepSkyBlue;");
    }
    
    @Override
    public void setNode(Node node) {
        actionHistoryItem = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
      
    

}

```
###### /java/harmony/mastermind/ui/ActionHistoryEntry.java
``` java
class ActionHistory {
    private final String title;
    private final String description;
    private final Date dateActioned;
    
    public ActionHistory(String title, String description){
        this.title = title;
        this.description = description;
        this.dateActioned = new Date();
    }

    public String getTitle() {
        return title;
    }

    public String getDescription() {
        return description;
    }

    public Date getDateActioned() {
        return dateActioned;
    }
}
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    public static MainWindow load(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {

        MainWindow mainWindow = UiPartLoader.loadUiPart(primaryStage, new MainWindow());
        mainWindow.configure(config.getAppTitle(), config.getTaskManagerName(), config, prefs, logic);
        return mainWindow;
    }

    private void configure(String appTitle, String taskManagerName, Config config, UserPrefs prefs, Logic logic) {

        // Set dependencies
        this.logic = logic;
        this.taskManagerName = taskManagerName;
        this.config = config;
        this.userPrefs = prefs;

        // Configure the UI
        setTitle(appTitle);
        setIcon(ICON);
        setWindowMinSize();
        setWindowDefaultSize(prefs);
        scene = new Scene(rootLayout);
        primaryStage.setScene(scene);
        
        tabLst = tabPane.getTabs();
        updateTabTitle();
        taskTableHome.setItems(logic.getFilteredTaskList());
        taskTableTask.setItems(logic.getFilteredFloatingTaskList());
        taskTableEvent.setItems(logic.getFilteredEventList());
        taskTableDeadline.setItems(logic.getFilteredDeadlineList());
        taskTableArchive.setItems(logic.getFilteredArchiveList());
        

        registerAsAnEventHandler(this);
    }

    public void hide() {
        primaryStage.hide();
    }

    private void setTitle(String appTitle) {
        primaryStage.setTitle(appTitle);
    }
    
    //@@A0138862W
    public void pushToActionHistory(String title, String description){
        ActionHistory aHistory = new ActionHistory(title, description);
        
        actionHistory.getItems().add(aHistory);
        actionHistory.scrollTo(actionHistory.getItems().size()-1);
    }

    /**
     * Sets the default size based on user preferences.
     */
    protected void setWindowDefaultSize(UserPrefs prefs) {
        primaryStage.setHeight(prefs.getGuiSettings().getWindowHeight());
        primaryStage.setWidth(prefs.getGuiSettings().getWindowWidth());
        if (prefs.getGuiSettings().getWindowCoordinates() != null) {
            primaryStage.setX(prefs.getGuiSettings().getWindowCoordinates().getX());
            primaryStage.setY(prefs.getGuiSettings().getWindowCoordinates().getY());
        }
    }

    private void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }
    
    public String getCurrentTab() {
        return tabPane.getSelectionModel().getSelectedItem().getId();
    }

    /**
     * Returns the current size and the position of the main Window.
     */
    public GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(), (int) primaryStage.getX(),
                (int) primaryStage.getY());
    }

    public void show() {
        primaryStage.show();
    }

    // ==================================

```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initActionHistory(ListView<ActionHistory> actionHistory){

        actionHistory.setOnMouseClicked(value->{
            consoleOutput.setText(actionHistory.getSelectionModel().getSelectedItem().getDescription());
        });
        actionHistory.setCellFactory(listView -> {
            ListCell<ActionHistory> actionCell = new ListCell<ActionHistory>(){
              
                @Override
                protected void updateItem(ActionHistory item, boolean isEmpty){
                    super.updateItem(item, isEmpty);
                    
                    if(!isEmpty){
                        
                        ActionHistoryEntry actionHistoryEntry = UiPartLoader.loadUiPart(new ActionHistoryEntry());
                        
                        
                        actionHistoryEntry.setTitle(item.getTitle().toUpperCase());
                        actionHistoryEntry.setDescription(item.getDescription());
                        actionHistoryEntry.setDate(item.getDateActioned().toString().toUpperCase());
                        
                        
                        if(item.getTitle().toUpperCase().equals("INVALID COMMAND")){
                            actionHistoryEntry.setTypeFail();
                        }else{
                            actionHistoryEntry.setTypeSuccess();
                        }
                        
                        this.setGraphic(actionHistoryEntry.getNode());
                        
                        this.setPrefHeight(50);
                        this.setPrefWidth(250);
                        
                        this.setContentDisplay(ContentDisplay.GRAPHIC_ONLY);
                    }else{
                        this.setGraphic(null);
                    }
                }
            };
            
            
            return actionCell;
        });
    }
    
    /**
     * Initializes the indexing of tasks
     */
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initIndex(TableColumn<ReadOnlyTask, ReadOnlyTask> indexColumn) {
        indexColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_INDEX));
        
        indexColumn.setCellFactory(column -> new TableCell<ReadOnlyTask, ReadOnlyTask>() {
            @Override
            public void updateIndex(int index) {
                super.updateIndex(index);

                if (isEmpty() || index < 0) {
                    setText(null);
                } else {
                    setText(Integer.toString(index + 1));
                }
            }
            
        });
    }

    /**
     * Initialize the Names of the tasks
     */
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initName(TableColumn<ReadOnlyTask, ReadOnlyTask> nameColumn) {
        nameColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_NAME));
        nameColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));
        
        nameColumn.setCellFactory( col -> new TableCell<ReadOnlyTask, ReadOnlyTask>(){
            
            @Override
            public void updateItem(ReadOnlyTask readOnlyTask , boolean isEmpty){
                super.updateItem(readOnlyTask, isEmpty);
                
                if(!isEmpty()){
                    
                    VBox vBox = new VBox(3);                   
                    
                    Text taskName = generateStyledText(readOnlyTask, readOnlyTask.getName());
                    taskName.getStyleClass().add("task-name-column");
                    vBox.getChildren().add(taskName);
                    
                    HBox hBox = new HBox(5);
                    
                    Button status = new Button();
                    if(readOnlyTask.isHappening()){
                        status.setText("HAPPENING");
                        status.getStyleClass().add("tag-happening");
                        hBox.getChildren().add(status);
                    }else if(readOnlyTask.isDue()){
                        status.setText("DUE");
                        status.getStyleClass().add("tag-overdue");
                        hBox.getChildren().add(status);
                    }
                    
                    if(readOnlyTask.isEvent()){
                        Button eventDuration = new Button();
                        eventDuration.setText(readOnlyTask.getEventDuration().toDays()+" DAY(S) EVENT");
                        eventDuration.getStyleClass().add("tag-event-duration");
                        hBox.getChildren().add(eventDuration);
                    }else if(readOnlyTask.isDeadline() && !readOnlyTask.isDue()){
                        Button dueDuration = new Button();
                        dueDuration.setText("DUE IN "+readOnlyTask.getDueDuration().toDays()+" DAY(S)");
                        dueDuration.getStyleClass().add("tag-due-duration");
                        hBox.getChildren().add(dueDuration);
                    }
                    
                    vBox.getChildren().add(hBox);
                    
                    this.setGraphic(vBox);
                    this.setPrefHeight(50);
                    
                }else{
                    this.setGraphic(null);
                }
                
            }
        });
        
    }
    
    /*
     * Generate styled row base on the task status: due(red), happening(orange), normal(blue)
     * 
     */
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private Text generateStyledText(ReadOnlyTask readOnlyTask, String text){
        Text taskName = new Text(text);
        
        if(readOnlyTask.isHappening()){
            taskName.getStyleClass().add("happening");
        }else if(readOnlyTask.isDue()){
            taskName.getStyleClass().add("overdue");
        }else{
            taskName.getStyleClass().add("normal");
        }
        return taskName;
    }
    
    
    /**
     * Initialize the start dates of the tasks
     */
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initStartDate(TableColumn<ReadOnlyTask, ReadOnlyTask> startDateColumn) {
        startDateColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_STARTDATE));
        startDateColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));
        
        startDateColumn.setCellFactory( col -> new TableCell<ReadOnlyTask, ReadOnlyTask>(){
            
            @Override
            public void updateItem(ReadOnlyTask readOnlyTask , boolean isEmpty){
                super.updateItem(readOnlyTask, isEmpty);
                if(!isEmpty() && readOnlyTask.getStartDate()!= null){
                    
                    TextFlow textFlow = new TextFlow();
                    
                    Text prettyDate = generateStyledText(readOnlyTask, prettyTime.format(readOnlyTask.getStartDate()));
                    prettyDate.getStyleClass().add("pretty-date");
                    
                    Text lineBreak = new Text("\n\n");
                    lineBreak.setStyle("-fx-font-size:2px;");
                    
                    Text uglyDate = generateStyledText(readOnlyTask, readOnlyTask.parse(readOnlyTask.getStartDate()));
                    uglyDate.getStyleClass().add("ugly-date");
                    
                    textFlow.getChildren().add(prettyDate);
                    textFlow.getChildren().add(lineBreak);
                    textFlow.getChildren().add(uglyDate);
                    
                    
                    this.setGraphic(textFlow);
                    this.setPrefHeight(50);
                    
                }else{
                    this.setGraphic(null);
                }
                
            }
        });
        
    }
    
    /**
     * Initialize the end dates of the tasks
     */
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initEndDate(TableColumn<ReadOnlyTask, ReadOnlyTask> endDateColumn) {
        endDateColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_ENDDATE));
        endDateColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));
        
        endDateColumn.setCellFactory( col -> new TableCell<ReadOnlyTask, ReadOnlyTask>(){
            
            @Override
            public void updateItem(ReadOnlyTask readOnlyTask , boolean isEmpty){
                super.updateItem(readOnlyTask, isEmpty);
                if(!isEmpty() && readOnlyTask.getEndDate() != null){
                    
                    TextFlow textFlow = new TextFlow();
                    
                    Text prettyDate = generateStyledText(readOnlyTask, prettyTime.format(readOnlyTask.getEndDate()));
                    prettyDate.getStyleClass().add("pretty-date");
                    
                    Text lineBreak = new Text("\n\n");
                    lineBreak.setStyle("-fx-font-size:2px;");
                    
                    Text uglyDate = generateStyledText(readOnlyTask,readOnlyTask.parse(readOnlyTask.getEndDate()));
                    uglyDate.getStyleClass().add("ugly-date");
                    
                    textFlow.getChildren().add(prettyDate);
                    textFlow.getChildren().add(lineBreak);
                    textFlow.getChildren().add(uglyDate);
                    
                    
                    this.setGraphic(textFlow);
                    this.setPrefHeight(50);
                    
                }else{
                    this.setGraphic(null);
                }
                
            }
        });
        
    }
    
    /**
     * Initialize the tags of the tasks
     */
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initTags(TableColumn<ReadOnlyTask, ReadOnlyTask> tagsColumn) {
        tagsColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_TAGS));
        tagsColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));
        
        tagsColumn.setCellFactory( col -> new TableCell<ReadOnlyTask, ReadOnlyTask>(){
            
            @Override
            public void updateItem(ReadOnlyTask readOnlyTask , boolean isEmpty){
                super.updateItem(readOnlyTask, isEmpty);
                if(!isEmpty() && readOnlyTask.getTags()!=null){
                    
                    HBox tags = new HBox(5);
                    
                    for(Tag tag : readOnlyTask.getTags()){
                        Button tagBubble = new Button();
                        tagBubble.setText(tag.tagName);
                        tagBubble.getStyleClass().add("tag");
                        tags.getChildren().add(tagBubble);
                    }
                    
                    this.setGraphic(tags);
                }else{
                    this.setGraphic(null);
                }
            }
        });
        
    }
    
    
    /**
     * Initialize a checkbox to determine whether task is recurring
     */
```
