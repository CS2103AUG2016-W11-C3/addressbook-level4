# A0138862W
###### /main/resources/view/MainWindow.css
``` css
.table-view {
    -fx-base: #1d1d1d;
    -fx-control-inner-background: #1d1d1d;
    -fx-background-color: #1d1d1d;
    -fx-table-cell-border-color: transparent;
    -fx-table-header-border-color: transparent;
    -fx-padding: 5;
}

.table-view .column-header-background {
    -fx-background-color: transparent;
}

.table-view .column-header, .table-view .filler {
    -fx-size: 35;
    -fx-border-insets: 0 10 1 0;
}

.table-view .column-header .label {
    -fx-font-size: 10pt;
    -fx-font-family: "Verdana";
    -fx-text-fill: lightGray;
    -fx-alignment: center;
    -fx-opacity: 1;
}

.table-row-cell {
    -fx-cell-size: 50px;
}

.table-row-cell:selected {
   -fx-background-color: transparent;
   -fx-table-cell-border-color:transparent;
}

.text-field{
    -fx-background-color: #3f3f3f;
    -fx-font-size: 12pt;
    -fx-font-family: "Lucida Console";
    -fx-text-fill: deepSkyBlue;
    -fx-border-radius: 0 0 0 0;
    -fx-background-radius: 0 0 0 0;
}

.tab-pane .tab-header-area .headers-region,
.tab-pane .tab-header-area .tab-header-background{
    -fx-background-color: #1d1d1d;
}

.tab-pane .tab-header-area .tab{
    -fx-background-color: #1d1d1d;
}

.tab-pane .tab-header-area .tab-label{
    -fx-text-fill: lightGray;
    -fx-font-weight: bold;
    -fx-font-style: oblique;
}

.tab-pane .tab-header-area .tab:selected .tab-label{
    -fx-text-fill: deepSkyBlue;
    -fx-font-weight: bold;
}

.split-pane:horizontal > .split-pane-divider {
    -fx-background-color: deepSkyBlue;
}

.text-area,
.text-area .content{
    -fx-background-color: #1d1d1d;
    -fx-font-size: 12pt;
    -fx-font-family: "Lucida Console";
    -fx-text-fill: deepSkyBlue;
}

.list-view{
    -fx-background-color: #1d1d1d;
}

.label{
    -fx-text-fill: white;
    -fx-font-family: "Verdana";
    -fx-font-size: 12pt;
    -fx-font-weight: bold;
    -fx-padding: 15px;
    -fx-font-style: oblique;
}

.list-cell{
    -fx-cell-size: 50;
    -fx-padding: 10 5 10 15;
    -fx-background-color: #1d1d1d;
    -fx-text-fill: white;
}

.list-cell:filled:selected:focused{
    -fx-background-color: #1a1a1a;
}

.scroll-bar,
.scroll-bar .decrement-button,
.scroll-bar .increment-button{
    -fx-background-color: #1d1d1d;
}

.scroll-bar .thumb,
.scroll-bar .decrement-button > .decrement-arrow,
.scroll-bar .increment-button > .increment-arrow{
    -fx-background-color: deepSkyBlue;
}

.action-history-item .title{
    -fx-text-fill: deepSkyBlue;
    -fx-font-weight: bold;
    -fx-font-size: 14px;
    -fx-font-style: normal;
    -fx-padding: 0px;
}

.action-history-item .date{
    -fx-text-fill: deepSkyBlue;
    -fx-font-weight: normal;
    -fx-font-size: 10px;
    -fx-font-style: normal;
    -fx-padding: 0px;
}

.action-history-item .description{
    -fx-text-fill: white;
    -fx-font-weight: normal;
    -fx-font-size: 12px;
    -fx-font-style: normal;
    -fx-padding: 0px;
}

.task-name-column{
    -fx-font-weight: bold;
    -fx-font-size: 18px;
}

.pretty-date{
    -fx-font-weight:bold;
}

.ugly-date{
    -fx-font-size:10px;
}

.tag{
    -fx-background-color: green;
    -fx-background-radius: 30;
    -fx-background-insets: 0;
    -fx-text-fill: white;
    -fx-font-size: 10px;
    -fx-font-weight: bold;
}

.tag-overdue{
    -fx-background-color: red;
    -fx-background-radius: 30;
    -fx-background-insets: 0;
    -fx-text-fill: white;
    -fx-font-size: 8px;
    -fx-font-weight: bold;
}

.tag-happening{
    -fx-background-color: orange;
    -fx-background-radius: 30;
    -fx-background-insets: 0;
    -fx-text-fill: black;
    -fx-font-size: 8px;
    -fx-font-weight: bold;
}

.tag-due-duration,
.tag-event-duration{
    -fx-background-color: lightGray;
    -fx-background-radius: 30;
    -fx-background-insets: 0;
    -fx-text-fill: black;
    -fx-font-size: 8px;
    -fx-font-weight: bold;
}

.normal{
    -fx-fill: deepSkyBlue;
}

.overdue{
    -fx-fill: red;
}

.happening{
    -fx-fill: orange;
}
```
###### /main/resources/view/ActionHistoryItem.fxml
``` fxml
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>

<HBox fx:id="actionHistoryItem" maxHeight="-Infinity" maxWidth="1.7976931348623157E308" styleClass="action-history-item" xmlns="http://javafx.com/javafx/8.0.102" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <VBox minWidth="200.0" prefWidth="200.0">
         <children>
            <Label fx:id="title" styleClass="title" text="TITLE" />
            <Label fx:id="date" styleClass="date" text="DATE" />
         </children>
      </VBox>
      <Label fx:id="description" styleClass="description" HBox.hgrow="ALWAYS" />
   </children>
</HBox>
```
###### /main/resources/view/MainWindow.fxml
``` fxml
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.control.SplitPane?>
<?import javafx.scene.control.Tab?>
<?import javafx.scene.control.TabPane?>
<?import javafx.scene.control.TableColumn?>
<?import javafx.scene.control.TableView?>
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="800.0" prefWidth="1280.0" styleClass="root" stylesheets="@MainWindow.css" xmlns="http://javafx.com/javafx/8.0.101" xmlns:fx="http://javafx.com/fxml/1" fx:controller="harmony.mastermind.ui.MainWindow">
    <children>
        <SplitPane dividerPositions="0.689358372456964" style="-fx-background-color: #1d1d1d;" VBox.vgrow="ALWAYS">
            <items>
                <AnchorPane prefHeight="369.0" prefWidth="485.0">
                    <children>
                        <BorderPane prefHeight="200.0" prefWidth="200.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                            <center>
                                <TabPane fx:id="tabPane" prefHeight="200.0" prefWidth="200.0" tabClosingPolicy="UNAVAILABLE" BorderPane.alignment="CENTER">
                                    <tabs>
                                        <Tab text="Home">
                                            <content>
                                                <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="180.0" prefWidth="200.0">
                                                    <children>
                                                        <TableView fx:id="taskTableHome" prefHeight="200.0" prefWidth="200.0" styleClass="table-view" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                                            <columns>
                                                                <TableColumn fx:id="indexHome" resizable="false" text="#" />
                                                                <TableColumn fx:id="taskNameHome" text="Task Name" />
                                                                <TableColumn fx:id="startDateHome" text="Start Date" />
                                                                <TableColumn fx:id="endDateHome" text="End Date" />
                                                                <TableColumn fx:id="tagsHome" text="Tags" />
                                                                <TableColumn fx:id="recurHome" text="Recur" />
                                                            </columns>
                                                        </TableView>
                                                    </children>
                                                </AnchorPane>
                                            </content>
                                        </Tab>
```
###### /main/resources/view/MainWindow.fxml
``` fxml
                            <bottom>
                                <TextField fx:id="commandField" onAction="#handleCommandInputChanged" onKeyPressed="#handleKeyPressed" promptText="Enter command here..." BorderPane.alignment="CENTER" />
                            </bottom>
                        </BorderPane>
                    </children>
                </AnchorPane>
                <AnchorPane maxHeight="-1.0" maxWidth="-1.0" prefHeight="369.0" prefWidth="68.0">
                    <children>
                  <VBox prefHeight="200.0" prefWidth="100.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                     <children>
                        <AnchorPane prefHeight="200.0">
                           <children>
                              <Label text="Date &amp; Time" />
                           </children>
                        </AnchorPane>
                        <VBox>
                           <children>
                              <Label text="Action History" VBox.vgrow="ALWAYS" />
                              <ListView fx:id="actionHistory" prefHeight="200.0" VBox.vgrow="ALWAYS" />
                           </children>
                        </VBox>
                        <VBox prefHeight="200.0" prefWidth="100.0" VBox.vgrow="ALWAYS">
                           <children>
                              <Label text="Console Output" VBox.vgrow="ALWAYS" />
                                      <TextArea fx:id="consoleOutput" editable="false" wrapText="true" VBox.vgrow="ALWAYS" />
                           </children>
                        </VBox>
                     </children>
                  </VBox>
                    </children>
                </AnchorPane>
            </items>
        </SplitPane>
    </children>
</VBox>
```
###### /main/java/harmony/mastermind/commons/exceptions/TaskAlreadyMarkedException.java
``` java
    public TaskAlreadyMarkedException(){
        super();
    }
}
```
###### /main/java/harmony/mastermind/commons/events/ui/ExecuteCommandEvent.java
``` java
public class ExecuteCommandEvent extends BaseEvent{

    public Date dateExecuted;
    public String title;
    public String description;

```
###### /main/java/harmony/mastermind/commons/events/ui/ExecuteCommandEvent.java
``` java
    public ExecuteCommandEvent(String title, String description){
        dateExecuted = new Date();

        this.title = title;
        this.description = description;
    }

```
###### /main/java/harmony/mastermind/commons/events/ui/ExecuteCommandEvent.java
``` java
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }



}
```
###### /main/java/harmony/mastermind/model/tag/UniqueTagList.java
``` java
    public String toString(){
        // functional way to transform list of items into concatenated string joining with commas (JAVA 8)
        return this.getInternalList().stream().map(Object::toString).collect(Collectors.joining(","));
    }
}
```
###### /main/java/harmony/mastermind/model/ModelManager.java
``` java
    public void pushToUndoHistory(Undoable command) {
        undoHistory.push(command);
    }

    @Override

    /** undo last action performed**/
```
###### /main/java/harmony/mastermind/model/ModelManager.java
``` java
    public CommandResult undo() throws EmptyStackException{
        CommandResult commandResult = undoHistory.pop().undo();
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return commandResult;
    }

    @Override
```
###### /main/java/harmony/mastermind/model/ModelManager.java
``` java
    public void pushToRedoHistory(Redoable command){
        redoHistory.push(command);
    }

    @Override
    /** redo the action that being undone function**/
```
###### /main/java/harmony/mastermind/model/ModelManager.java
``` java
    public CommandResult redo() throws EmptyStackException{
        CommandResult commandResult = redoHistory.pop().redo();
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return commandResult;
    }

    @Override
    /** This method should only be called when the user entered a new command other than redo/undo **/
```
###### /main/java/harmony/mastermind/model/ModelManager.java
``` java
    public void clearRedoHistory(){
        redoHistory.clear();
    }

```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public Task(String name, Date startDate, Date endDate, UniqueTagList tags, String recur) {
        this.name = name;
        this.startDate = startDate;
        this.endDate = endDate;
        this.tags = tags;
        this.marked = false;
        this.recur = recur;
    }

    // deadline
```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public Task(String name, Date endDate, UniqueTagList tags, String recur) {
        this(name, null, endDate, tags, recur);
    }

    // floating
```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public Task(String name, UniqueTagList tags) {
        this(name, null, null, tags, null);
    }

```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getStartDate(), source.getEndDate(), source.getTags(), source.getRecur());
        this.marked = source.isMarked();
    }

    @Override
```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isFloating() {
        return startDate == null && endDate == null;
    }

    @Override
```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isDeadline() {
        return startDate == null && endDate != null;
    }

    @Override
```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isEvent() {
        return startDate != null && endDate != null;
    }

```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isDue(){        
        if(isDeadline()){
            Date now = new Date();
            if(now.after(endDate)){
                return true;
            }else{
                return false;
            }
        }else if(isEvent()){
            Date now = new Date();
            if(now.after(startDate) && now.after(endDate)){
                return true;
            }else{
                return false;
            }
        }else{
            return false;
        }
    }

```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isHappening(){
        if(isEvent()){
            Date now = new Date();
            if(now.after(startDate) && now.before(endDate)){
                return true;
            }else{
                return false;
            }
        }
        return false;
    }

```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public Duration getEventDuration(){
        if(isEvent()){
            long differencel = endDate.getTime() - startDate.getTime();

            return Duration.of(differencel, ChronoUnit.MILLIS);
        }else{
            return null;
        }
    }

    /*
     * calculate the duration until due date
     *
     */
```
###### /main/java/harmony/mastermind/model/task/Task.java
``` java
    public Duration getDueDuration(){
        if(endDate != null){
            long nowl = System.currentTimeMillis();
            long endDatel = endDate.getTime();

            long differencel = endDatel - nowl;

            return Duration.of(differencel, ChronoUnit.MILLIS);
        }else{
            return null;
        }
    }
}
```
###### /main/java/harmony/mastermind/storage/XmlAdaptedTask.java
``` java
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName();

        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }
```
###### /main/java/harmony/mastermind/logic/parser/Parser.java
``` java
    private Command prepareAdd(String args) {
        final Matcher matcher = AddCommand.COMMAND_ARGUMENTS_PATTERN.matcher(args);

        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_EXAMPLES));
        }

        try {

            // mandatory
            // there's no need to check for existence as the regex only capture full match of mandatory components
            final String name = matcher.group("name");

            // optionals
            final Optional<String> recur = Optional.ofNullable(matcher.group("recur"));
            final Optional<String> startDate = Optional.ofNullable(matcher.group("startDate"));
            final Optional<String> endDate = Optional.ofNullable(matcher.group("endDate"));
            final Optional<String> tags = Optional.ofNullable(matcher.group("tags"));


            // return internal value if present. else, return empty string
            Set<String> tagSet = getTagsFromArgs(tags.map(val -> val).orElse(""));
            String recurVal = null;

            //check if recur has a valid keyword
            if (recur.isPresent()) {
                String key = recur.get().split(" ")[0];
                if (!Arrays.asList(AddCommand.COMMAND_KEYWORDS_RECUR).contains(key)) {
                    return new IncorrectCommand("invalid recurring value");
                }
                recurVal = recur.get();
            }

            if (startDate.isPresent() && endDate.isPresent()) {
                // event
                String start = startDate.get().toLowerCase();
                String end = endDate.get().toLowerCase();

                if (start.equals("today")) {
                    start += " 2359";
                }else if (start.equals("tomorrow")) {
                    start += " 2359";
                }
                if (end.equals("today")) {
                    end += " 2359";
                }else if (start.equals("tomorrow")) {
                    end += " 2359";
                }


                try {
                    return new AddCommand(name, start, end, tagSet, recurVal);
                } catch (InvalidEventDateException iede) {
                    return new IncorrectCommand(iede.getMessage());
                }
            } else if (!startDate.isPresent() && endDate.isPresent()) {
                // deadline
                String end = endDate.get().toLowerCase();

                if (end.equals("today")) {
                    end += " 2359";
                }else if (end.equals("tomorrow")) {
                    end += " 2359";
                }

                return new AddCommand(name, end, tagSet, recurVal);
            } else if (startDate.isPresent() && !endDate.isPresent()) {
                // task with only startdate is not supported.
                throw new IllegalValueException("Cannot create a task with only start date.");
            } else {
                // floating
                return new AddCommand(name, tagSet);
            }

        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Parses arguments in the context of the edit task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
```
###### /main/java/harmony/mastermind/logic/parser/Parser.java
``` java
    private Command prepareEdit(String args) {
        final Matcher matcher = EditCommand.COMMAND_ARGUMENTS_PATTERN.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        try {

            // mandatory
            // regex accept only numbers in index field, encountering NumberFormatException is impossible
            final int index = Integer.parseInt(matcher.group("index"));

            //optional
            final Optional<String> recur = Optional.ofNullable(matcher.group("recur"));
            final Optional<String> name = Optional.ofNullable(matcher.group("name"));
            final Optional<String> startDate = Optional.ofNullable(matcher.group("startDate"));
            final Optional<String> endDate = Optional.ofNullable(matcher.group("endDate"));
            final Optional<String> tags = Optional.ofNullable(matcher.group("tags"));

            Optional<Set<String>> tagSet = Optional.empty();
            if(tags.isPresent()){
                tagSet = Optional.ofNullable(getTagsFromArgs(tags.get()));
            };

            return new EditCommand(index, name, startDate, endDate, tagSet, recur);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (ParseException pe) {
            return new IncorrectCommand(pe.getMessage());

        }

    }
```
###### /main/java/harmony/mastermind/logic/commands/Command.java
``` java
    protected static final PrettyTimeParser prettyTimeParser = new PrettyTimeParser();

    protected Model model;
    protected Storage storage;

    /**
     * Constructs a feedback message to summarise an operation that displayed a listing of tasks.
     *
     * @param displaySize used to generate summary
     * @return summary message for tasks displayed
     */
    public static String getMessageForTaskListShownSummary(int displaySize) {
        return String.format(Messages.MESSAGE_TASKS_LISTED_OVERVIEW, displaySize);
    }

    /**
     * Executes the command and returns the result message.
     *
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult execute();

    /**
     * Provides any needed dependencies to the command.
     * Commands making use of any of these should override this method to gain
     * access to the dependencies.
     */
    public void setData(Model model, Storage storage) {
        this.model = model;
        this.storage = storage;
    }

    /**
     * Raises an event to indicate an attempt to execute an incorrect command
     */
    protected void indicateAttemptToExecuteIncorrectCommand() {
        EventsCenter.getInstance().post(new IncorrectCommandAttemptedEvent(this));
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/AddCommand.java
``` java
public class AddCommand extends Command implements Undoable, Redoable {

    public static final String COMMAND_KEYWORD_ADD = "add";
    public static final String COMMAND_KEYWORD_DO = "do";
    public static final String[] COMMAND_KEYWORDS_RECUR = {"daily", "weekly", "biweekly", "monthly", "yearly"};

    // The main idea of capturing parameters in any order is inspired by (author
    // velop):
    // http://stackoverflow.com/questions/1177081/mulitple-words-in-any-order-using-regex

    // As for capturing optional group AND in any order:
    // http://stackoverflow.com/questions/24472120/match-optional-components-in-any-order

    // We wrote the regular expression and tested at:
    // https://regex101.com/r/bFQrP6/1
```
###### /main/java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public static final String COMMAND_ARGUMENTS_REGEX = "(?=(?:.*?r\\/'(?<recur>.+?)')?)"
                                                         + "(?=(?:.*?\\s\\'(?<name>.+?)'))"
                                                         + "(?=(?:.*?sd\\/'(?<startDate>.+?)')?)"
                                                         + "(?=(?:.*?ed\\/'(?<endDate>.+?)')?)"
                                                         + "(?=(?:.*t\\/'(?<tags>\\w+(?:,\\w+)*)?')?)"
                                                         + ".*";

    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);

    public static final String COMMAND_FORMAT = "(add|do) [r/'<recur>'] '<name>' [sd/'<startDate>'] [ed/'<endDate>'] [t/'<tags>...']";

    public static final String MESSAGE_EXAMPLE_EVENT = "add 'attend workshop' sd/'today 7pm' ed/'next monday 1pm' t/'programming,java'";
    public static final String MESSAGE_EXAMPLE_DEADLINE = "add 'submit homework' ed/'next sunday 11pm' t/'math,physics'";
    public static final String MESSAGE_EXAMPLE_FLOATING = "do 'chores' t/'cleaning'";
    public static final String MESSAGE_EXAMPLE_RECUR_DEADLINE = "add r/'weekly' 'submit homework' ed/'next sunday 11pm' t/'math,physics'";
    public static final String MESSAGE_EXAMPLE_RECUR_EVENT = "add r/'daily 2' 'attend workshop' sd/'today 7pm' ed/'next monday 1pm' t/'programming,java'";

    public static final String MESSAGE_EXAMPLES = new StringBuilder()
                                                    .append("[Format]\n")
                                                    .append(COMMAND_FORMAT+ "\n\n")
                                                    .append("[Examples]:\n")
                                                    .append("Event: "+ MESSAGE_EXAMPLE_EVENT+"\n")
                                                    .append("Deadline: "+MESSAGE_EXAMPLE_DEADLINE+"\n")
                                                    .append("Floating: "+MESSAGE_EXAMPLE_FLOATING)
                                                    .append("Recurring Deadline: "+MESSAGE_EXAMPLE_RECUR_DEADLINE)
                                                    .append("Recur Event twice: "+MESSAGE_EXAMPLE_RECUR_EVENT)
                                                    .toString();

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_UNDO_SUCCESS = "[Undo Add Command] Task deleted: %1$s";
    public static final String MESSAGE_REDO_SUCCESS = "[Redo Add Command] Task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in Mastermind";

    private final Task toAdd;

    /**
     * Convenience constructor using raw values.<br><br>
     *
     * Throws IllegalValueException if any of the raw values are invalid<br>
     * Throws InvalidEventDateException if event type has start date after end date
     */
    // event
```
###### /main/java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public AddCommand(String name, String endDateStr, Set<String> tags, String recur) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }

        // fix for #132
        List<Date> endDates = prettyTimeParser.parse(endDateStr);
        Date endDate = (endDates.isEmpty())? null: endDates.get(0);

        this.toAdd = new Task(name, endDate, new UniqueTagList(tagSet), recur);

    }

    // floating
```
###### /main/java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public AddCommand(String name, Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }

        this.toAdd = new Task(name, new UniqueTagList(tagSet));
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            executeAdd();

            // push this command into undoHistory
            model.pushToUndoHistory(this);

            // this is a new command entered by user (not undo/redo)
            // need to clear the redoHistory Stack
            model.clearRedoHistory();

            return new CommandResult(COMMAND_KEYWORD_ADD,String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(COMMAND_KEYWORD_ADD,MESSAGE_DUPLICATE_TASK);
        }

    }

    @Override
    /** action to perform when ModelManager requested to undo this command **/
```
###### /main/java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public CommandResult undo() {
        try {
            // remove the task that's previously added.
            model.deleteTask(toAdd);

            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_KEYWORD_ADD,String.format(MESSAGE_UNDO_SUCCESS, toAdd));
        } catch (UniqueTaskList.TaskNotFoundException pne) {
            return new CommandResult(COMMAND_KEYWORD_ADD,Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        }
    }

    @Override
    /** action to perform when ModelManager requested to redo this command**/
```
###### /main/java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public CommandResult redo() {
        assert model != null;
        try {
            executeAdd();

            model.pushToUndoHistory(this);

            return new CommandResult(COMMAND_KEYWORD_ADD,String.format(MESSAGE_REDO_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(COMMAND_KEYWORD_ADD,MESSAGE_DUPLICATE_TASK);
        }        
    }

    /** extract method since it's reusable for execute() and redo()**/
    private void executeAdd() throws DuplicateTaskException {
        model.addTask(toAdd);
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/RedoCommand.java
``` java
    public CommandResult execute() {

        try{
            // All Command supports undo operation must implement Redoable interface

            // execute the redo implementation
            CommandResult redoResult = model.redo();

            // display successful message and the details of the undo operations
            return new CommandResult(COMMAND_WORD,
                    MESSAGE_SUCCESS + "\n" +
                    "=====Redo Details=====\n" +
                    redoResult.feedbackToUser + "\n"+
                    "==================");
        }catch(EmptyStackException ex){
            return new CommandResult(COMMAND_WORD, MESSAGE_EMPTY_COMMAND_HISTORY);
        }
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/Undoable.java
``` java
public interface Undoable {

    /**
     * Specify the undo operation according to the nature of the corresponding class.
     * For example, to implement an undo operation on AddCommand, a delete operation should be implemented.
     * Similarly, a DeleteCommand should implement a add operation to restore the record.
     *
     * @return CommandResult, the Object contains details & feedback about the undo operation.
     */
```
###### /main/java/harmony/mastermind/logic/commands/Undoable.java
``` java
    public CommandResult undo();

}
```
###### /main/java/harmony/mastermind/logic/commands/MarkCommand.java
``` java
    public CommandResult undo() {
        try {
            // remove the task that's previously added.
            model.unmarkTask(taskToMark);

            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNDO_SUCCESS, taskToMark));
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_WORD, String.format(UnmarkCommand.MESSAGE_DUPLICATE_UNMARK_TASK, taskToMark));
        } catch (ArchiveTaskList.TaskNotFoundException e) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        }
    }

    @Override
```
###### /main/java/harmony/mastermind/logic/commands/MarkCommand.java
``` java
    public CommandResult redo() {
        try {
            executeMark();

            model.pushToUndoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_REDO_SUCCESS, taskToMark));
        } catch (TaskAlreadyMarkedException ex) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_MARKED_TASK, taskToMark));
        } catch (IndexOutOfBoundsException ex) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(COMMAND_WORD,Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_WORD,MESSAGE_MARK_RECURRING_FAILURE);
        } catch (NotRecurringTaskException e) {
            return new CommandResult(COMMAND_WORD,MESSAGE_MARK_RECURRING_FAILURE);

        }
    }

```
###### /main/java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    public static final String COMMAND_ARGUMENTS_REGEX = "(?=(?<index>\\d+))"
                                                        + "(?=(?:.*?r\\/'(?<recur>.+?)')?)"
                                                        + "(?=(?:.*?\\s\\'(?<name>.+?)')?)"
                                                        + "(?=(?:.*?sd\\/'(?<startDate>.+?)')?)"
                                                        + "(?=(?:.*?ed\\/'(?<endDate>.+?)')?)"
                                                        + "(?=(?:.*t\\/'(?<tags>\\w+(?:,\\w+)*)?')?)"
                                                        + ".*";


    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);

    public static final String COMMAND_SUMMARY = "Editting a task:"
                                                 + "\n"
                                                 + "("
                                                 + COMMAND_KEYWORD_EDIT
                                                 + " | "
                                                 + COMMAND_KEYWORD_UPDATE
                                                 + ") "
                                                 + "<index> ['<task_name>'] [sd/'<start_date>'] [ed/<end_date>'] [t/'<comma_spearated_tags>']";

    public static final String MESSAGE_USAGE = COMMAND_SUMMARY
                                               + "\n"
                                               + "Edits the task identified by the index number used in the last task listing.\n"
                                               + "Example: "
                                               + COMMAND_KEYWORD_EDIT
                                               + " 1 'I change the task name to this, unspecified field are preserved.'";

    public static final String MESSAGE_EDIT_TASK_PROMPT = "Edit the following task: %1$s";
    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Task successfully edited: %1$s";

    public static final String MESSAGE_UNDO_SUCCESS = "[Undo Edit Command] Task reverted: %1$s";
    public static final String MESSAGE_REDO_SUCCESS = "[Redo Edit Command] Edit the following task: %1$s";

    // private MainWindow window;
    private ReadOnlyTask originalTask;
    private Task editedTask;

    private final int targetIndex;
    private Optional<String> name;
    private Optional<String> startDate;
    private Optional<String> endDate;
    private Optional<String> recur;
    private Optional<Set<String>> tags;

    public EditCommand(int targetIndex, Optional<String> name, Optional<String> startDate, Optional<String> endDate, Optional<Set<String>> tags, Optional<String> recur) throws IllegalValueException, ParseException {
        this.targetIndex = targetIndex;
        this.name = name;
        this.startDate = startDate;
        this.endDate = endDate;
        this.recur = recur;
        this.tags = tags;
    }

    @Override
    public CommandResult execute() {

        try {
            // grabbing the origin task (before edit)
            executeEdit();

            model.pushToUndoHistory(this);

            // this is a new command entered by user (not undo/redo)
            // need to clear the redoHistory Stack
            model.clearRedoHistory();

            return new CommandResult(COMMAND_KEYWORD_EDIT, String.format(MESSAGE_EDIT_TASK_PROMPT, originalTask));

        } catch (TaskNotFoundException | DuplicateTaskException | IndexOutOfBoundsException ie) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

    }

    @Override
```
###### /main/java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    public CommandResult undo() {

        try {
            // remove the task that's previously edited
            model.deleteTask(editedTask);

            // add back the original task
            model.addTask((Task) originalTask);

            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_KEYWORD_EDIT, String.format(MESSAGE_UNDO_SUCCESS, originalTask));
        } catch (UniqueTaskList.TaskNotFoundException pne) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, AddCommand.MESSAGE_DUPLICATE_TASK);
        }
    }

    @Override
```
###### /main/java/harmony/mastermind/logic/commands/EditCommand.java
``` java
    public CommandResult redo() {

        try {
            executeEdit();

            model.pushToUndoHistory(this);

            return new CommandResult(COMMAND_KEYWORD_EDIT, String.format(MESSAGE_REDO_SUCCESS, originalTask));
        } catch (TaskNotFoundException | DuplicateTaskException | IndexOutOfBoundsException ie) {
            return new CommandResult(COMMAND_KEYWORD_EDIT, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

    private void executeEdit() throws TaskNotFoundException, DuplicateTaskException, IndexOutOfBoundsException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new IndexOutOfBoundsException();
        }

        if (originalTask == null) {
            originalTask = lastShownList.get(targetIndex
                                             - 1);
        }

        // if user provides explicit field and value, we change them
        // otherwise, all user omitted field are preserve from the original
        // before edit
        String toEditName = name.map(val -> val).orElse(originalTask.getName());
        Date toEditStartDate = startDate.map(val -> prettyTimeParser.parse(val).get(0)).orElse(originalTask.getStartDate());
        Date toEditEndDate = endDate.map(val -> prettyTimeParser.parse(val).get(0)).orElse(originalTask.getEndDate());
        String toEditRecur = recur.map(val -> val).orElse(originalTask.getRecur());
        UniqueTagList toEditTags = new UniqueTagList(tags.map(val -> {
            final Set<Tag> tagSet = new HashSet<>();
            for (String tagName : val) {
                try {
                    tagSet.add(new Tag(tagName));
                } catch (IllegalValueException e) {
                    e.printStackTrace();
                }
            }
            return tagSet;
        }).orElse(originalTask.getTags().toSet()));

        // initialize the new task with edited values
        if (editedTask == null) {
            editedTask = new Task(toEditName, toEditStartDate, toEditEndDate, toEditTags, toEditRecur);
        }

        model.deleteTask(originalTask);
        model.addTask(editedTask);
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/DeleteCommand.java
``` java
    public CommandResult undo() {
        try {
            // add back the task that's previously added.
            model.addTask((Task) toDelete);

            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNDO_SUCCESS, toDelete));
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_WORD, AddCommand.MESSAGE_DUPLICATE_TASK);
        }
    }

    @Override
```
###### /main/java/harmony/mastermind/logic/commands/DeleteCommand.java
``` java
    public CommandResult redo() {
        try {
            executeDelete();

            model.pushToUndoHistory(this);

        } catch (TaskNotFoundException | IndexOutOfBoundsException | ArchiveTaskList.TaskNotFoundException tnfe) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        return new CommandResult(COMMAND_WORD, String.format(MESSAGE_REDO_SUCCESS, toDelete));
    }

    private void executeDelete() throws TaskNotFoundException, IndexOutOfBoundsException, ArchiveTaskList.TaskNotFoundException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getCurrentList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new IndexOutOfBoundsException();
        }

        if (toDelete == null) {
            toDelete = lastShownList.get(targetIndex - 1);
        }

        if (toDelete.isMarked()) {
            model.deleteArchive(toDelete);
        }else {
            model.deleteTask(toDelete);
        }
    }

}
```
###### /main/java/harmony/mastermind/logic/commands/Redoable.java
``` java
public interface Redoable {
    /**
     * Specify the redo operation according to the nature of the corresponding class.
     *
     * @return CommandResult, the Object contains details & feedback about the redo operation.
     */
    public CommandResult redo();
}
```
###### /main/java/harmony/mastermind/logic/commands/UndoCommand.java
``` java
public class UndoCommand extends Command{

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_SUCCESS = "Undo successfully.";
    public static final String MESSAGE_EMPTY_COMMAND_HISTORY = "There's no more action available to undo.";
    public static final String MESSAGE_COMMAND_NOT_UNDOABLE = "This command is not undoable";
    public static final String COMMAND_SUMMARY = "Undoing a command:"
            + "\n" + COMMAND_WORD;

    @Override
```
###### /main/java/harmony/mastermind/logic/commands/UndoCommand.java
``` java
    public CommandResult execute() {

        try{
            // All Command supports undo operation must implement Undoable interface

            // execute the undo implementation
            CommandResult undoResult = model.undo();

            // display successful message and the details of the undo operations
            return new CommandResult(COMMAND_WORD,
                    MESSAGE_SUCCESS + "\n" +
                    "=====Undo Details=====\n" +
                    undoResult.feedbackToUser + "\n"+
                    "==================");
        }catch(EmptyStackException ex){
            return new CommandResult(COMMAND_WORD, MESSAGE_EMPTY_COMMAND_HISTORY);
        }
    }



}

```
###### /main/java/harmony/mastermind/logic/commands/UnmarkCommand.java
``` java
    public CommandResult undo() {
        try {
            // remove the task that's previously added.
            model.markTask(taskToUnmark);

            model.pushToRedoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNDO_SUCCESS, taskToUnmark));
        } catch (UniqueTaskList.TaskNotFoundException e) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        }
    }

    @Override
```
###### /main/java/harmony/mastermind/logic/commands/UnmarkCommand.java
``` java
    public CommandResult redo() {
        try {
            executeUnmark();

            model.pushToUndoHistory(this);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNMARK_TASK_SUCCESS, taskToUnmark));
        } catch (TaskAlreadyUnmarkedException tau) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNMARK_TASK_FAILURE, taskToUnmark));
        } catch (DuplicateTaskException dte) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_DUPLICATE_UNMARK_TASK, taskToUnmark));
        } catch (TaskNotFoundException tnfe) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

```
###### /main/java/harmony/mastermind/ui/ActionHistoryEntry.java
``` java
public class ActionHistoryEntry extends UiPart{

    private static final String FXML = "ActionHistoryItem.fxml";

    @FXML
    private HBox actionHistoryItem;

    @FXML
    private Label title;

    @FXML
    private Label date;

    @FXML
    private Label description;

    public void setTitle(String title){
        this.title.setText(title);
    }

    public void setDate(String date){
        this.date.setText(date);
    }

    public void setDescription(String description){
        this.description.setText(description);
    }

    public Node getNode(){
        return actionHistoryItem;
    }

    public void setTypeFail(){
        this.title.setStyle("-fx-text-fill: crimson;");
        this.date.setStyle("-fx-text-fill: crimson;");
    }

    public void setTypeSuccess(){
        this.title.setStyle("-fx-text-fill: deepSkyBlue;");
        this.date.setStyle("-fx-text-fill: deepSkyBlue;");
    }

    @Override
    public void setNode(Node node) {
        actionHistoryItem = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }



}

```
###### /main/java/harmony/mastermind/ui/ActionHistoryEntry.java
``` java
class ActionHistory {
    private final String title;
    private final String description;
    private final Date dateActioned;

    public ActionHistory(String title, String description){
        this.title = title;
        this.description = description;
        this.dateActioned = new Date();
    }

    public String getTitle() {
        return title;
    }

    public String getDescription() {
        return description;
    }

    public Date getDateActioned() {
        return dateActioned;
    }
}
```
###### /main/java/harmony/mastermind/ui/UiManager.java
``` java
    @Subscribe
    private void handleExecuteCommandEvent(ExecuteCommandEvent event){
        mainWindow.pushToActionHistory(event.title, event.description);
    }
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    // init only one parser for all parsing, save memory and computation time
    private static final PrettyTime prettyTime = new PrettyTime();
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    public static MainWindow load(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {

        MainWindow mainWindow = UiPartLoader.loadUiPart(primaryStage, new MainWindow());
        mainWindow.configure(config.getAppTitle(), config.getTaskManagerName(), config, prefs, logic);
        return mainWindow;
    }
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initActionHistory(ListView<ActionHistory> actionHistory){

        actionHistory.setOnMouseClicked(value->{
            consoleOutput.setText(actionHistory.getSelectionModel().getSelectedItem().getDescription());
        });
        actionHistory.setCellFactory(listView -> {
            ListCell<ActionHistory> actionCell = new ListCell<ActionHistory>(){

                @Override
                protected void updateItem(ActionHistory item, boolean isEmpty){
                    super.updateItem(item, isEmpty);

                    if(!isEmpty){

                        ActionHistoryEntry actionHistoryEntry = UiPartLoader.loadUiPart(new ActionHistoryEntry());


                        actionHistoryEntry.setTitle(item.getTitle().toUpperCase());
                        actionHistoryEntry.setDescription(item.getDescription());
                        actionHistoryEntry.setDate(item.getDateActioned().toString().toUpperCase());


                        if(item.getTitle().toUpperCase().equals("INVALID COMMAND")){
                            actionHistoryEntry.setTypeFail();
                        }else{
                            actionHistoryEntry.setTypeSuccess();
                        }

                        this.setGraphic(actionHistoryEntry.getNode());

                        this.setPrefHeight(50);
                        this.setPrefWidth(250);

                        this.setContentDisplay(ContentDisplay.GRAPHIC_ONLY);
                    }else{
                        this.setGraphic(null);
                    }
                }
            };


            return actionCell;
        });
    }

    /**
     * Initializes the indexing of tasks
     */
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initIndex(TableColumn<ReadOnlyTask, ReadOnlyTask> indexColumn) {
        indexColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_INDEX));

        indexColumn.setCellFactory(column -> new TableCell<ReadOnlyTask, ReadOnlyTask>() {
            @Override
            public void updateIndex(int index) {
                super.updateIndex(index);

                if (isEmpty() || index < 0) {
                    setText(null);
                } else {
                    setText(Integer.toString(index + 1));
                }
            }

        });
    }

    /**
     * Initialize the Names of the tasks
     */
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initName(TableColumn<ReadOnlyTask, ReadOnlyTask> nameColumn) {
        nameColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_NAME));
        nameColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));

        nameColumn.setCellFactory( col -> new TableCell<ReadOnlyTask, ReadOnlyTask>(){

            @Override
            public void updateItem(ReadOnlyTask readOnlyTask , boolean isEmpty){
                super.updateItem(readOnlyTask, isEmpty);

                if(!isEmpty()){

                    VBox vBox = new VBox(3);                   

                    Text taskName = generateStyledText(readOnlyTask, readOnlyTask.getName());
                    taskName.getStyleClass().add("task-name-column");
                    vBox.getChildren().add(taskName);

                    HBox hBox = new HBox(5);

                    Button status = new Button();
                    if(readOnlyTask.isHappening()){
                        status.setText("HAPPENING");
                        status.getStyleClass().add("tag-happening");
                        hBox.getChildren().add(status);
                    }else if(readOnlyTask.isDue()){
                        status.setText("DUE");
                        status.getStyleClass().add("tag-overdue");
                        hBox.getChildren().add(status);
                    }

                    if(readOnlyTask.isEvent()){
                        Button eventDuration = new Button();
                        eventDuration.setText(readOnlyTask.getEventDuration().toDays()+" DAY(S) EVENT");
                        eventDuration.getStyleClass().add("tag-event-duration");
                        hBox.getChildren().add(eventDuration);
                    }else if(readOnlyTask.isDeadline() && !readOnlyTask.isDue()){
                        Button dueDuration = new Button();
                        dueDuration.setText("DUE IN "+readOnlyTask.getDueDuration().toDays()+" DAY(S)");
                        dueDuration.getStyleClass().add("tag-due-duration");
                        hBox.getChildren().add(dueDuration);
                    }

                    vBox.getChildren().add(hBox);

                    this.setGraphic(vBox);
                    this.setPrefHeight(50);

                }else{
                    this.setGraphic(null);
                }

            }
        });

    }

    /*
     * Generate styled row base on the task status: due(red), happening(orange), normal(blue)
     *
     */
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private Text generateStyledText(ReadOnlyTask readOnlyTask, String text){
        Text taskName = new Text(text);

        if(readOnlyTask.isHappening()){
            taskName.getStyleClass().add("happening");
        }else if(readOnlyTask.isDue()){
            taskName.getStyleClass().add("overdue");
        }else{
            taskName.getStyleClass().add("normal");
        }
        return taskName;
    }


    /**
     * Initialize the start dates of the tasks
     */
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initStartDate(TableColumn<ReadOnlyTask, ReadOnlyTask> startDateColumn) {
        startDateColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_STARTDATE));
        startDateColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));

        startDateColumn.setCellFactory( col -> new TableCell<ReadOnlyTask, ReadOnlyTask>(){

            @Override
            public void updateItem(ReadOnlyTask readOnlyTask , boolean isEmpty){
                super.updateItem(readOnlyTask, isEmpty);
                if(!isEmpty() && readOnlyTask.getStartDate()!= null){

                    TextFlow textFlow = new TextFlow();

                    Text prettyDate = generateStyledText(readOnlyTask, prettyTime.format(readOnlyTask.getStartDate()));
                    prettyDate.getStyleClass().add("pretty-date");

                    Text lineBreak = new Text("\n\n");
                    lineBreak.setStyle("-fx-font-size:2px;");

                    Text uglyDate = generateStyledText(readOnlyTask, readOnlyTask.parse(readOnlyTask.getStartDate()));
                    uglyDate.getStyleClass().add("ugly-date");

                    textFlow.getChildren().add(prettyDate);
                    textFlow.getChildren().add(lineBreak);
                    textFlow.getChildren().add(uglyDate);


                    this.setGraphic(textFlow);
                    this.setPrefHeight(50);

                }else{
                    this.setGraphic(null);
                }

            }
        });

    }

    /**
     * Initialize the end dates of the tasks
     */
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initEndDate(TableColumn<ReadOnlyTask, ReadOnlyTask> endDateColumn) {
        endDateColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_ENDDATE));
        endDateColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));

        endDateColumn.setCellFactory( col -> new TableCell<ReadOnlyTask, ReadOnlyTask>(){

            @Override
            public void updateItem(ReadOnlyTask readOnlyTask , boolean isEmpty){
                super.updateItem(readOnlyTask, isEmpty);
                if(!isEmpty() && readOnlyTask.getEndDate() != null){

                    TextFlow textFlow = new TextFlow();

                    Text prettyDate = generateStyledText(readOnlyTask, prettyTime.format(readOnlyTask.getEndDate()));
                    prettyDate.getStyleClass().add("pretty-date");

                    Text lineBreak = new Text("\n\n");
                    lineBreak.setStyle("-fx-font-size:2px;");

                    Text uglyDate = generateStyledText(readOnlyTask,readOnlyTask.parse(readOnlyTask.getEndDate()));
                    uglyDate.getStyleClass().add("ugly-date");

                    textFlow.getChildren().add(prettyDate);
                    textFlow.getChildren().add(lineBreak);
                    textFlow.getChildren().add(uglyDate);


                    this.setGraphic(textFlow);
                    this.setPrefHeight(50);

                }else{
                    this.setGraphic(null);
                }

            }
        });

    }

    /**
     * Initialize the tags of the tasks
     */
```
###### /main/java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initTags(TableColumn<ReadOnlyTask, ReadOnlyTask> tagsColumn) {
        tagsColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_TAGS));
        tagsColumn.setCellValueFactory(cellValue -> new SimpleObjectProperty<>(cellValue.getValue()));

        tagsColumn.setCellFactory( col -> new TableCell<ReadOnlyTask, ReadOnlyTask>(){

            @Override
            public void updateItem(ReadOnlyTask readOnlyTask , boolean isEmpty){
                super.updateItem(readOnlyTask, isEmpty);
                if(!isEmpty() && readOnlyTask.getTags()!=null){

                    HBox tags = new HBox(5);

                    for(Tag tag : readOnlyTask.getTags()){
                        Button tagBubble = new Button();
                        tagBubble.setText(tag.tagName);
                        tagBubble.getStyleClass().add("tag");
                        tags.getChildren().add(tagBubble);
                    }

                    this.setGraphic(tags);
                }else{
                    this.setGraphic(null);
                }
            }
        });

    }
