# A0143378Y
###### /java/harmony/mastermind/storage/StorageMemory.java
``` java
    public static void saveToStorage(Memory memory) { 
        try {
            PrintWriter pw = new PrintWriter(SAVE_FILE);
            for (int i=0; i<memory.getSize(); i++) {
                pw.println(memory.get(i).getType());
                pw.println(memory.get(i).getName());
                printDescription(memory, pw, i);
                printStart(memory, pw, i);
                printEnd(memory, pw, i);
                pw.println(memory.get(i).getState());

                pw.println("");
            }
            pw.close();
        } catch (FileNotFoundException e) {
            System.out.println(ERROR_NOT_FOUND);
            e.printStackTrace();
        }
    }

```
###### /java/harmony/mastermind/storage/StorageMemory.java
``` java
    private static void printEnd(Memory memory, PrintWriter pw, int i) { 
        if (memory.get(i).getEnd() != null) {
            pw.println(calendarToString(memory.get(i).getEnd()));
        } else {
            pw.println(NULL);
        }
    }

```
###### /java/harmony/mastermind/storage/StorageMemory.java
``` java
    private static void printStart(Memory memory, PrintWriter pw, int i) { 
        if (memory.get(i).getStart() != null) {
            pw.println(calendarToString(memory.get(i).getStart()));
        } else {
            pw.println(NULL);
        }
    }

    private static String calendarToString(Calendar a) { 
        String dateTime = "";
        dateTime = a.get(Calendar.YEAR) + SPACE + a.get(Calendar.MONTH) + SPACE + a.get(Calendar.DATE);
        if(a.isSet(Calendar.HOUR_OF_DAY)){
            dateTime = dateTime + SPACE + a.get(Calendar.HOUR_OF_DAY) + SPACE + a.get(Calendar.MINUTE) + SPACE + a.get(Calendar.SECOND);
        }
        return dateTime;
    }

```
###### /java/harmony/mastermind/storage/StorageMemory.java
``` java
    private static void printDescription(Memory memory, PrintWriter pw, int i) {
        if (memory.get(i).getDescription() != null) {
            pw.println(memory.get(i).getDescription());
        } else {
            pw.println(NULL);
        }
    }

```
###### /java/harmony/mastermind/storage/StorageMemory.java
``` java
    public static void checkForFileExists(Memory memory) { 
        File file = new File(SAVE_FILE);
        if (!file.exists()) {
            try {
                file.createNewFile();
            } catch (IOException e) {
                System.out.println(ERROR_CREATE);
                System.exit(0);
            }
        }
        readFromFile(memory);
    }

```
###### /java/harmony/mastermind/storage/StorageMemory.java
``` java
    private static void readFromFile(Memory memory) { 
        try {
            BufferedReader br = new BufferedReader(new FileReader(SAVE_FILE));
            String line = br.readLine();

            while (line != null) {
                String type = null;
                String name = null;
                String description = null;
                Calendar startCal = null;
                Calendar endCal = null;
                int state = 0;

                type = line;
                name = br.readLine();
                description = readDescription(br);
                startCal = readCalendar(br, startCal);
                endCal = readCalendar(br, endCal);
                state = readState(br);

                br.readLine(); //blank line
                memory.memory.add(new GenericMemory(type, name, description, startCal, endCal, state));
                line = br.readLine();

            }
            br.close();
        } catch (IOException | NumberFormatException | NullPointerException e) {
            System.out.println(ERROR_READ);
        }
    }

```
###### /java/harmony/mastermind/storage/StorageMemory.java
``` java
    // Read line for integer for state
    private static int readState(BufferedReader br) throws IOException {
        int state;
        String stateString = br.readLine();
        state=Integer.parseInt(reduceToInt(stateString));
        return state;
    }
    
```
###### /java/harmony/mastermind/storage/StorageMemory.java
``` java
    private static String reduceToInt(String stateString) { 
        return stateString.replaceAll("[^0-9]", "");
    }

```
###### /java/harmony/mastermind/storage/StorageMemory.java
``` java
    // Read line for calendar for start and end dates
    private static Calendar readCalendar(BufferedReader br, Calendar startCal) throws IOException {
        String start = br.readLine();
        if (start.equals(NULL)) {
            start = null;
        } else {
            startCal = stringToCalendar(start);
        }
        return startCal;
    }

```
###### /java/harmony/mastermind/storage/StorageMemory.java
``` java
    // Converts string representation of date and time back into Calendar object
    private static Calendar stringToCalendar(String b){
        Calendar setNew = new GregorianCalendar();

        String[] details = b.split(SPACE);
        try {
            setNew.set(Integer.parseInt(details[0]), Integer.parseInt(details[1]), Integer.parseInt(details[2]));

            if(details.length == 6){
                setNew.set(Calendar.HOUR_OF_DAY,Integer.parseInt(details[3]));
                setNew.set(Calendar.MINUTE, Integer.parseInt(details[4]));
                setNew.set(Calendar.SECOND, Integer.parseInt(details[5]));
            }
        } catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
            System.out.println(ERROR_READ);
            e.printStackTrace();
        }

        return setNew;
    }

```
###### /java/harmony/mastermind/storage/StorageMemory.java
``` java
    private static String readDescription(BufferedReader br) throws IOException {
        String description;
        description = br.readLine();
        if (description.equals(NULL)) {
            description = null;
        }
        return description;
    }

    // To change file name of save file
    public static void setSaveFileAddress(String add){
        SAVE_FILE = add;
    }
}
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * General getters and setters
     */
    public static String getCommand() { 
        return command;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static void setCommand(String newCommand) { 
        command = newCommand;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static void setTaskName(String newName) { 
        taskName = newName;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static String getTaskName() { 
        return taskName;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static void setDescription(String newDescription) { 
        description = newDescription;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static String getDescription() { 
        return description;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static void setLength(int newLength) { 
        length = newLength;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static int getLength() { 
        return length;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static void setType(int newType) {
        type = newType;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static int getType() { 
        return type;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static void setContainsDescription(boolean cd) { 
        containsDescription = cd;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static void setProper(boolean sp) { 
        setProper = sp;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * Set date to a calendar object setEvent
     * If set, return true.
     */
    public static boolean setDate(String date, Calendar setEvent) { 
        boolean isValid = false;
        
        initialiseDate();
        getDate(date);
        
        isValid = setDateIfContainDDMMYY(day, month, year, setEvent);
        
        return isValid;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static boolean setTime(String time, Calendar setEvent) { 
        int newTime = INT_INVALID;
        int hour = 23, minute = 59; 
        boolean isValid = false;
        
        String timeReduced = reduceToInt(time);
        newTime = convertToInt(timeReduced);
        
        //Checks that time string has exactly 4 digit.
        if(timeReduced.length() == 4 && newTime != INVALID_INT){
            minute = newTime%100;
            hour = newTime/100;
        }
        
        //Checks that the time set is valid
        if(!(invalidMinute(minute)||invalidHour(hour)||timeReduced.length()!=4)){
            isValid = setTimeIfHHMMSS(hour, minute, setEvent);
        }
        
        return isValid;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * Check the format the date is in
     * dd/mm/yy or dd-mm-yy and parse accordingly
     */
    protected static void getDate(String date){
        
        if(date.contains("/")){
            getInt("/", date);
            
        }else if(date.contains("-")){
            getInt("-", date);
            
        }
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * Parse the date string with the symbol "/" or "-"
     */
    protected static void getInt(String symbol, String date){
        
        String[] details = date.split(symbol);
        
        boolean dateIsNumeric = true;
        
        //Check that date has all 3 component: day, month and year
        if(details.length == 3){
            dateIsNumeric = checkIfDateIsNumeric(details);
        }
            
        if(dateIsNumeric){
            setDDMMYY(details);
        }
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * Returns true if user command is an empty string or contains symbols only
     */
    public static Boolean isUselessCommand(String input){

        if(reduceToIntAndChar(input).length()==0){
            return true;
        }else{
            return false;
        }
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * Returns true if end date and time is before start date and time
     */
    protected static Boolean endIsBeforeStart(Calendar start, Calendar end){
        return end.before(start);
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * Checks if string contains number only
     * Returns true if it does
     */
    protected static boolean isNumeric(String temp){
        try{
            Integer.parseInt(temp);
        }catch(NumberFormatException e){
            return false;
        }
        return true;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * Prints error message and set setProper as false
     */
    protected static void generalError(){
        System.out.println(INVALID_COMMAND);
        setProper(false);
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    protected static String removeAllInt(String name){
        return name.replaceAll("[0-9 ]", "");
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static String reduceToInt(String name){
        return name.replaceAll("[^0-9]", "");
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    public static String reduceToIntAndChar(String name){
        return name.replaceAll("[^a-zA-Z0-9]", "");
    }   
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    protected static String reduceToChar(String name){
        return name.replaceAll("[^a-zA-Z]", "");
    }   
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * set dates
     * If day and month are appropriate, returns true
     */
    private static boolean setDateIfContainDDMMYY(int day, int mth, int yr, Calendar setEvent){
        int year = 2000 + yr;
        int month = mth -1;
        if(!(invalidMonth(month)||invalidDay(day))){
            setEvent.set(Calendar.DATE, day);
            setEvent.set(Calendar.MONTH, month);
            setEvent.set(Calendar.YEAR, year);
            return true;
        }else{
            return false;
        }
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * Converts string to integer
     * If string is empty or contains non-number, print error message.
     */
    private static int convertToInt(String value){
        int i = INVALID_INT;
        try{
            i= Integer.parseInt(value);
        }catch(NumberFormatException e){
            System.err.println(INVALID_DATE_TIME+ e.getMessage());     
        }
        return i;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * Month is invalid if
     * Month is less than 0
     * Month is greater than 11
     */
    private static boolean invalidMonth(int month){
        return (month<0||month>11);
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * returns true is day is 0 or greater than 31 
     */
    private static boolean invalidDay(int day){
        return (day<=0||day>31);
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * returns true if time is set properly
     */
    private static boolean setTimeIfHHMMSS(int hour, int minute, Calendar setEvent){
        setEvent.set(Calendar.HOUR_OF_DAY, hour);
        setEvent.set(Calendar.MINUTE, minute);
        if(hour == 23 && minute == 59){
            setEvent.set(Calendar.SECOND, 59);
        }else{
            setEvent.set(Calendar.SECOND, 0);
        }
        return true;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * returns true if minute is negative or more than 59
     */
    private static boolean invalidMinute(int minute){
        return (minute<0||minute>=60);
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * returns true if hour is negative or more than 23
     */
    private static boolean invalidHour(int hour){
        return (hour<0||hour>=24);
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * Check that the word is a command word for date
     */
    protected static int isCommandWord(String word){
        switch(word){
        case STRING_DEADLINE:
            return DEADLINE;
        case STRING_BY:
            return BY;
        case STRING_UNTIL:
            return UNTIL;
        case STRING_TILL:
            return TILL;
        case STRING_BEFORE:
            return BEFORE;
        case STRING_BETWEEN:
            return BETWEEN;
        case STRING_TO:
            return TO;
        case STRING_FROM:
            return FROM;
        case STRING_ON:
            return ON;
        case STRING_AND:
            return AND;
            default:
                return INVALID_STRING;   
        }
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * remove additional space between each word in case of typo
     */
    protected static void removeAdditionalSpacesInCommand(){
        String[] temp = command.split(" ");
        String newCommand = "";
        for (int i = 0; i < temp.length; i++){
            if(temp[i].length() != 0){
                newCommand = newCommand + temp[i] + " ";
            }
        }
        setCommand(newCommand.trim());
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * Returns true if the command word is a command for start date
     */
    protected static boolean isStartCommand(String word){
        return (isCommandWord(word)>= FROM &&
                isCommandWord(word)<= BETWEEN);
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    /*
     * Returns true if the command word is a command for end date
     */
    protected static boolean isEndCommand(String word){
        return (isCommandWord(word)>= BY &&
                isCommandWord(word)<= AND);
    }
    
    //author A0143378Y
    private static void setDDMMYY(String[] details){
        day = Integer.parseInt(details[0]);
        month = Integer.parseInt(details[1]);
        year = Integer.parseInt(details[2]);
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    private static void initialiseDate(){
        day = INT_INVALID;
        month = INT_INVALID;
        year = INT_INVALID;
    }
    
```
###### /java/harmony/mastermind/logic/parser/ParserMemoryMain.java
``` java
    private static boolean checkIfDateIsNumeric(String[] details){
        for(int i = 0; i < 3; i++ ){
            if(!isNumeric(details[i])){
                return false;
            }
        }
        
        return true;
    }
}
```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    private Memory initializeMemory() {
        Memory memory = new Memory();
        mem = memory;
        memory.loadFromFile(memory);
        return memory;
    }
}
```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    private Calendar dateToCalendar(Date date) { 
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        return cal;
    }


}
```
###### /java/harmony/mastermind/logic/commands/DeleteCommand.java
``` java
    /*
     * Perform a delete by name operation
     */
    public static void deleteDirectly(String name, Memory memory) {
        ArrayList<GenericMemory> searchResult = FindCommand.searchExact(name, memory);
        if (searchResult.size() == 1){
            deleteItem(searchResult.get(0), memory);
            History.advance(memory);
        } 
    }
    
```
###### /java/harmony/mastermind/logic/commands/DeleteCommand.java
``` java
    /*
     * Delete given GenericMemory item from memory
     */
    private static void deleteItem(GenericMemory item, Memory memory) {
        assert item != null;
        memory.remove(item);
    }
}
```
###### /java/harmony/mastermind/logic/commands/Sort.java
``` java
    /* Sort all items in memory by urgency.
     * Items arranged by Event, Deadline, Task
     * Event sorted by earliest start date followed by end date
     * Deadline sorted by earliest due date
     * Task sorted by alphabet 
     */
    public static void sort(ArrayList<GenericMemory> list) { 
        task = new ArrayList<GenericMemory>();
        deadline = new ArrayList<GenericMemory>();
        event = new ArrayList<GenericMemory>();
        splitMemory(list);
        
        sortAllList();
        
        joinList(list);
    }
    
```
###### /java/harmony/mastermind/logic/commands/Sort.java
``` java
    /*
     * Reform list by adding Event, Deadline, Task items in sorted order
     */
    private static void joinList(ArrayList<GenericMemory> list) {
        list.removeAll(list);
        assert list.size() == 0;
        for (int i = 0; i < event.size(); i++) { 
            list.add(event.get(i));
        }
        
        for (int i = 0; i < deadline.size(); i++) { 
            list.add(deadline.get(i));
        }
        
        for (int i = 0; i < task.size(); i++) { 
            list.add(task.get(i));
        }
    }
    
```
###### /java/harmony/mastermind/logic/commands/Sort.java
``` java
    /*
     * Sorts the 3 lists 
     */
    private static void sortAllList() { 
        Collections.sort(task);
        Collections.sort(deadline);
        Collections.sort(event);
    }
    
```
###### /java/harmony/mastermind/logic/commands/Sort.java
``` java
    /*
     * Split all items into their own list for sorting
     */
    public static void splitMemory(ArrayList<GenericMemory> list) { 
        for (int i = 0; i < list.size(); i++) { 
            switch (list.get(i).getType()) { 
            case "Task":
                task.add(list.get(i));
                break;
                
            case "Deadline":
                deadline.add(list.get(i));
                break;
                
            case "Event":
                event.add(list.get(i));
                break;
            }
        }
    }
}
```
###### /java/harmony/mastermind/logic/commands/History.java
``` java
    /*
     * Creates a snapshot of changes in the memory and moves previous state into the back stack. forward stack is reinitialized
     */
    public static void advance(Memory memory) {
        forward = new Stack<ArrayList<GenericMemory>>();
        back.push(current);
        current = new ArrayList<GenericMemory>();
        duplicateMemory(memory);
    }

```
###### /java/harmony/mastermind/logic/commands/History.java
``` java
    /*
     * Duplicates memory into the current ArrayList
     */
    private static void duplicateMemory(Memory memory) {
        for (int i = 0; i< memory.getSize(); i++) { // Duplicating of memory into snapshot
            current.add(new GenericMemory(memory.get(i).getType(),
                    memory.get(i).getName(),
                    memory.get(i).getDescription(),
                    memory.get(i).getStart(),
                    memory.get(i).getEnd(),
                    memory.get(i).getState()));
        }
    }
    
    /*
     * Unused code: 
     * Reason: For future implementations of Memory 
```
###### /java/harmony/mastermind/logic/commands/History.java
``` java
    // Swaps memory used for redo
    private static void redoMemorySwap(Memory memory) {
        assert forward.size() > 0;
        back.push(current);
        current = forward.pop();
        memory.setList(current);
    }

```
###### /java/harmony/mastermind/logic/commands/History.java
``` java
    // Retrieves most recent snapshot in the back stack and swap it with current memory. Current memory gets pushed into forward stack
    public static void undo(Memory memory) {
        if (back.isEmpty() || (back.peek() == null)) {
            System.out.println("Nothing to undo!");
            return;
        }

        ArrayList<GenericMemory> temp = duplicateTemp(memory);
        undoMemorySwap(memory, temp);
        StorageMemory.saveToStorage(memory);
        System.out.println("Undo successful.");
    }
    
```
###### /java/harmony/mastermind/logic/commands/History.java
``` java
    // Swaps memory used for undo
    private static void undoMemorySwap(Memory memory, ArrayList<GenericMemory> temp) {
        forward.push(temp);
        current = back.pop();
        assert current != null;
        memory.setList(current);
    }

```
###### /java/harmony/mastermind/logic/commands/History.java
``` java
    // Duplicate current memory into temp ArrayList
    private static ArrayList<GenericMemory> duplicateTemp(Memory memory) {
        ArrayList<GenericMemory> temp = new ArrayList<GenericMemory>(); // Duplicating of memory into forward stack
        for (int i = 0; i < memory.getSize(); i++) {
            temp.add(new GenericMemory(memory.get(i).getType(),
                    memory.get(i).getName(),
                    memory.get(i).getDescription(),
                    memory.get(i).getStart(),
                    memory.get(i).getEnd(),
                    memory.get(i).getState()));
        }
        return temp;
    }
    */

}
```
###### /java/harmony/mastermind/logic/commands/FindCommand.java
``` java
    /*
     * Checks if memory item contains the keyword.
     * If contains, add to exactResult
     */
    private static void containsKeyword(String keyword, Memory memory, ArrayList<GenericMemory> exactResult, int i) {
        if (memory.get(i).getName().equals(keyword)) { // found exact matching name item
            exactResult.add(memory.get(i));
        }
    }

```
###### /java/harmony/mastermind/logic/commands/FindCommand.java
``` java
    /*
     * Only for delete and update direct commands to search for exact matching names
     * Should only return list of 1 item ideally
     */
    public static ArrayList<GenericMemory> searchExact(String keyword, Memory memory) {
        assert keyword.length() != 0;
        ArrayList<GenericMemory> exactResult = new ArrayList<GenericMemory>();
        for (int i=0; i<memory.getSize(); i++) {
            containsKeyword(keyword, memory, exactResult, i);
        }
        return exactResult;
    }
    
```
###### /java/harmony/mastermind/logic/commands/FindCommand.java
``` java
    /*
     * Returns ArrayList of GenericEvents found containing keywords in their name or description
     */
    public static ArrayList<GenericMemory> searchTerms(String[] keywords, Memory memory) {
        ArrayList<GenericMemory> result = new ArrayList<GenericMemory>(memory.getList());
        findResult = recursiveSearchTerms(keywords, 0, result); // calls recursive search to narrow down results
        if (findResult.size() >= 1) { 
            assert findResult.size() > 1;
            String title = formatSearchTitle(keywords);
            ListCommand.displayList(findResult, title);
        }
        
        return findResult;
    }

```
###### /java/harmony/mastermind/logic/commands/FindCommand.java
``` java
    /*
     * Formats search title with keywords used to perform the search
     */
    private static String formatSearchTitle(String[] keywords) {
        String title = "Search Keywords Result: " + keywords[0];
        for (int i=1; i<keywords.length; i++) {
            title += ", " + keywords[i];
        }
        return title;
    }

```
###### /java/harmony/mastermind/logic/commands/FindCommand.java
``` java
    public static ArrayList<GenericMemory> recursiveSearchTerms(String[] keywords, int index, ArrayList<GenericMemory> result) {
        ArrayList<GenericMemory> newResult = new ArrayList<GenericMemory>();
        if (index >= keywords.length) { // Base case: no more terms to search
            return result;
        } else { // Narrowing down results
            assert index < keywords.length;
            for (int i=0; i < result.size(); i++) {
                if (result.get(i).getName().contains(keywords[index])) { // Found term in name
                    newResult.add(result.get(i));
                } else if ((result.get(i).getDescription()!= null) && result.get(i).getDescription().contains(keywords[index])) { // has description and found term in description
                    newResult.add(result.get(i));
                }
            }
            return recursiveSearchTerms(keywords, index+1, newResult);
        }
    }

```
###### /java/harmony/mastermind/logic/commands/FindCommand.java
``` java
    public static ArrayList<GenericMemory> findDate(Calendar date, Memory memory) {
        assert date != null;
        findResult = new ArrayList<GenericMemory>();
        for (int i=0; i < memory.getSize(); i++) {
            Calendar start = memory.get(i).getStart();
            Calendar end = memory.get(i).getEnd();

            if (testTwoCalendar(date, start) || // Checks if given date is equals or between item's start and end date
                    testTwoCalendar(date, end) ||
                    (date.after(start) && date.before(end)) ) {
                findResult.add(memory.get(i));
            }
        }

        return findResult;
    }

```
###### /java/harmony/mastermind/logic/commands/FindCommand.java
``` java
    /*
     * Returns true if two dates are the same
     */
    private static boolean testTwoCalendar(Calendar a, Calendar b) {
        if (b == null) {
            return false;
        } else {
            assert (a != null) && (b != null);
            return (a.get(Calendar.YEAR)== b.get(Calendar.YEAR))&&
                    (a.get(Calendar.MONTH) == b.get(Calendar.MONTH))&&
                    (a.get(Calendar.DATE)== b.get(Calendar.DATE));
        }
    }

}
```
###### /java/harmony/mastermind/memory/Memory.java
``` java
    /*
     * Adds a given GenericMemory item into the memory ArrayList
     * Updates quick view and saves to file
     */ 
    public void add(GenericMemory item){
        assert item != null;

        String type = item.getType();

        memory.add(item);
        StorageMemory.saveToStorage(this);
    }

```
###### /java/harmony/mastermind/memory/Memory.java
``` java
    /*
     * Returns GenericMemory object at index
     */
    public GenericMemory get(int index){
        return memory.get(index);
    }

```
###### /java/harmony/mastermind/memory/Memory.java
``` java
    /*
     * Returns ArrayList of GenericMemory used by memory
     */
    public ArrayList<GenericMemory> getList(){
        return memory;
    }

```
###### /java/harmony/mastermind/memory/Memory.java
``` java
    /*
     * Returns number of GenericMemory in memory (size)
     */
    public int getSize(){
        return memory.size();
    }

```
###### /java/harmony/mastermind/memory/Memory.java
``` java
    /*
     * Loads GenericMemory from save file into memory
     */
    public void loadFromFile(Memory memory){
        assert memory != null;
        StorageMemory.checkForFileExists(memory);
    }

```
###### /java/harmony/mastermind/memory/Memory.java
``` java
    /*
     * Removes given item from memory
     */
    public void remove(GenericMemory item){
        assert item != null;

        String type = item.getType();

        memory.remove(item);
        StorageMemory.saveToStorage(this);
    }

```
###### /java/harmony/mastermind/memory/Memory.java
``` java
    /*
     * Swap out ArrayList used by memory with new given list
     */
    public void setList(ArrayList<GenericMemory> list){
        memory = list;
    }

}
```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Setting up deadlines 
     */
    public GenericMemory(String type, String name, String description, Calendar end) {
        this.type = type;
        this.name = name;
        this.description = description;
        this.end = end;
        this.state = 0;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Events and constructor used to load from storage
     */
    public GenericMemory(String type, String name, String description, Calendar startDate, Calendar end, int state) {
        this.type = type;
        this.name = name;
        this.description = description;
        this.start = startDate;
        this.end = end;
        this.state = state;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Returns type of the to do item
     */
    public String getType() {
        return type;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Returns name of the to do item
     */
    public String getName() {
        return name;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Returns description of the to do item
     */
    public String getDescription() {
        return description;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Returns Calendar start of the to do item
     */
    public Calendar getStart() {
        return start;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Returns Calendar end of the to do item
     */
    public Calendar getEnd() {
        return end;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Returns the state of the to do item
     */ 
    public int getState() {
        return state;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Initializes start calendar - having a real calendar instead of hard coding everything
     */
    public void initStart(){
        start = new GregorianCalendar();
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Initializes end calendar
     */
    public void initEnd(){
        end = new GregorianCalendar();
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Set type of to do item
     */
    public void setType(String type) {
        this.type = type;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Set name of to do item
     */
    public void setName(String name) {
        this.name = name;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Set description of to do item
     */
    public void setDescription(String description) {
        this.description  = description;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Set start time of to do item using hours and minutes
     */
    public void setStartTime(int hourOfDay, int minute) {
        start.set(Calendar.HOUR_OF_DAY, hourOfDay);
        start.set(Calendar.MINUTE, minute);
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Set start time of to do item using hours, minutes and seconds
     */
    public void setStartTime(int hourOfDay, int minute, int second) {
        start.set(Calendar.HOUR_OF_DAY, hourOfDay);
        start.set(Calendar.MINUTE, minute);
        start.set(Calendar.SECOND, second);
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Set end time of to do item using hours and minutes
     */
    public void setEndTime(int hourOfDay, int minute) {
        end.set(Calendar.HOUR_OF_DAY, hourOfDay);
        end.set(Calendar.MINUTE, minute);
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Set end time of to do item using hours, minutes and seconds
     */
    public void setEndTime(int hourOfDay, int minute, int second) {
        end.set(Calendar.HOUR_OF_DAY, hourOfDay);
        end.set(Calendar.MINUTE, minute);
        end.set(Calendar.SECOND, second);
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Set start date of to do item
     */
    public void setStartDate(int year, int month, int date) {
        start.set(Calendar.YEAR, year);
        start.set(Calendar.MONTH, month);
        start.set(Calendar.DATE, date);
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Set end date of to do item
     */
    public void setEndDate(int year, int month, int date) {
        end.set(Calendar.YEAR, year);
        end.set(Calendar.MONTH, month);
        end.set(Calendar.DATE, date);
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Set state of to do item
     */
    public void setState(int newstate) {
        this.state = newstate;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /* Converts GenericEvents object into string representation
     * Outputs in the format
     * Name
     * Description
     * Start
     * End
     * State
     * (non-Javadoc)
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        String output = TYPE_STRING + getType() + 
                        NAME_STRING + getName();
        output = descriptionToString(output);

        if (getType().equals(TASK)) { // Task
            output = taskDeadlineStateToString(output);
            return output;
        }

        if (getType().equals(DEADLINE)) { // Deadline
            output = deadlineDateToString(output);
            output = taskDeadlineStateToString(output);
            return output;
        }

        if (getType().equals(EVENT)) { // Event
            output = eventDatesToString(output);
            output = eventStateToString(output);
            return output;
        }
        return output;
    }
    
```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Converts description into string representation
     */
    public String descriptionToString(String output) {
        if (description != null) { // If description exists
            output +=   DESCRIPTION_STRING + getDescription();
        }
        return output;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Converts due date into string representation
     */
    public String deadlineDateToString(String output) {
        if (end != null) {
            output += DUE_BY + getDate(end) + " " + getTime(end);
        }
        return output;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Converts event start and end dates into string representation
     */
    public String eventDatesToString(String output) {
        if (start != null) {
            output += START_STRING + getDate(start) + " " + getTime(start);
        }
        if (end != null) {
            output += END_STRING + getDate(end) + " " + getTime(end);
        }
        return output;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Converts event state into string representation
     */ 
    public String eventStateToString(String output) {
        if (getState() == 0) { // Printing of state into string
            output+= STATUS_UPCOMING;
        } else if (getState() == 1) {
            output+= STATUS_OVER;
        } else {
            output+= STATUS_ONGOING;
        }
        return output;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Converts task or deadline state into string representation
     */
    public String taskDeadlineStateToString(String output) {
        if (getState() == 0) { // Printing of state into string
            output+= STATUS_INCOMPLETE;
        } else if (getState() == 1) {
            output+= STATUS_COMPLETED;
        } else {
            output+= STATUS_OVERDUE;
        }
        return output;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Returns string representation of date as DD/MM/YY
     */
    public static String getDate(Calendar item){
        if(item != null){
            return item.get(Calendar.DATE) + "/"
                    + (item.get(Calendar.MONTH) + 1) + "/"
                    + (item.get(Calendar.YEAR)%100) + " "
                    + dayOfTheWeek(item);
        }else{
            return null;
        }
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Returns string representation of time as HH:MM AM/PM
     */
    public static String getTime(Calendar item){
        if(item != null){
            return hour(item) + ":"
                    + min(item) + " "
                    + AM_PM(item);
        }else{
            return null;
        }
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Return string representation of day of the week of calendar object
     */
    public static String dayOfTheWeek(Calendar item){
        int dayOfTheWeek = item.get(Calendar.DAY_OF_WEEK);

        switch(dayOfTheWeek){
        case Calendar.MONDAY:
            return MON;

        case Calendar.TUESDAY:
            return TUES;

        case Calendar.WEDNESDAY:
            return WED;

        case Calendar.THURSDAY:
            return THURS;

        case Calendar.FRIDAY:
            return FRI;

        case Calendar.SATURDAY:
            return SAT;

        case Calendar.SUNDAY:
            return SUN;
        }
        return null;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Check item for AM/PM and return the correct time period
     */
    public static String AM_PM(Calendar item){
        if(item.get(Calendar.AM_PM) == Calendar.AM){
            return AM;
        }else{
            return PM;
        }
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Return the hour of time to form of HH
     */
    public static String hour(Calendar item){
        if(item.get(Calendar.HOUR_OF_DAY)==12){
            return "12";
        }else if( item.get(Calendar.HOUR)<10){
            return "0" + item.get(Calendar.HOUR);
        }else{
            return Integer.toString(item.get(Calendar.HOUR));
        }
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Return minute of time to form of MM
     */
    public static String min(Calendar item){
        if( item.get(Calendar.MINUTE)<10){
            return "0" + item.get(Calendar.MINUTE);
        }else{
            return Integer.toString(item.get(Calendar.MINUTE));
        }
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /* Comparator between to do item and o
     * Only valid when comparing items of the same type
     * eg. Task vs Task, Deadline vs Deadline, Event vs Event
     * Task: Compare names lexicographically, ignoring case differences -> alphabetical order 
     * Deadline: Compare due dates
     *  Event: Compare start dates, else end dates
     */
    public int compareTo(GenericMemory o) {
        if (this.start == null && this.end == null && o.start == null && o.end == null){ //both task
            return this.name.compareToIgnoreCase(o.name);
        }

        if (this.start == null && this.end != null && o.start == null && o.end != null){ //both deadline
            return this.end.compareTo(o.end);
        }

        if (this.start != null && this.end != null && o.start != null && o.end != null){ //both event
            return eventCompare(o);
        }
        return 0;
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Compare's start date followed by end dates
     */
    int eventCompare(GenericMemory o) {
        if (this.start.compareTo(o.start) != 0) {
            return this.start.compareTo(o.start);
        } else {
            return this.end.compareTo(o.end);
        }
    }

```
###### /java/harmony/mastermind/memory/GenericMemory.java
``` java
    /*
     * Return state of the item in the form of a string
     */
    public String getStateType(){

        if(type.equals(DEADLINE)|| type.equals(TASK)){
            if(state == INT_INCOMPLETE){
                return INCOMPLETE;
            }else if (state == INT_COMPLETED){
                return COMPLETED;
            }else if (state == INT_OVERDUE){
                return OVERDUE;
            }
        }
        if(type.equals(EVENT)){
            if(state == INT_UPCOMING){
                return UPCOMING;
            }else if(state == INT_OVER){
                return OVER;
            }else if (state == INT_ONGOING){
                return ONGOING;
            }
        }
        return null;
    }
}
```
###### /java/harmony/mastermind/ui/CommandBox.java
``` java
    @FXML
    private void initAutoComplete() {
        // Autocomplete function
        Collections.addAll(listOfWords, words);
        autoCompletionBinding = TextFields.bindAutoCompletion(commandField, listOfWords);
        autoCompletionBinding.setPrefWidth(500);
        autoCompletionBinding.setVisibleRowCount(5);
        autoCompletionBinding.setHideOnEscape(true);

    }

```
###### /java/harmony/mastermind/ui/CommandBox.java
``` java
    // This function takes in whatever the user has "ENTER"-ed, and save in a
    // dictionary of words
    // These words will be in the autocomplete list of words
    private void learnWord(String text) {
        listOfWords.add(text);

        if (autoCompletionBinding != null) {
            autoCompletionBinding.dispose();
        }

        autoCompletionBinding = TextFields.bindAutoCompletion(commandField, listOfWords);
    }

```
