# A0139194X
###### \java\harmony\mastermind\commons\core\Config.java
``` java
    public void setAppTitle(String appTitle) {
        assert appTitle != null;
        this.appTitle = appTitle;
    }

```
###### \java\harmony\mastermind\commons\core\Config.java
``` java
    public void setUserPrefsFilePath(String userPrefsFilePath) {
        assert userPrefsFilePath != null;
        this.userPrefsFilePath = userPrefsFilePath;
    }

```
###### \java\harmony\mastermind\commons\core\Config.java
``` java
    public void setTaskManagerFilePath(String taskManagerFilePath) {
        assert taskManagerFilePath != null;
        this.taskManagerFilePath = taskManagerFilePath;
    }

    public String getTaskManagerName() {
        return taskManagerName;
    }

```
###### \java\harmony\mastermind\commons\core\Config.java
``` java
    public void setTaskManagerName(String taskManagerName) {
        assert taskManagerName != null;
        this.taskManagerName = taskManagerName;
    }


```
###### \java\harmony\mastermind\commons\events\model\ExpectingConfirmationEvent.java
``` java
//Currently not in used yet. Will be used for enhancement to clear command
public class ExpectingConfirmationEvent extends BaseEvent {

    public ExpectingConfirmationEvent() {}
    
    @Override
    public String toString() {
        return "Expecting user confirmation next.";
    }
    
}
```
###### \java\harmony\mastermind\commons\events\storage\RelocateFilePathEvent.java
``` java
/*
 * Event that holds the new file path the user wants to relocate to
 */
public class RelocateFilePathEvent extends BaseEvent {

    private final String newFilePath;
    
    public RelocateFilePathEvent(String newFilePath) {
        this.newFilePath = newFilePath;
    }
    
    @Override
    public String toString() {
        return "Change save location file path to: " + newFilePath;
    }
    
    public String getFilePath() {
        return this.newFilePath;
    }
}
```
###### \java\harmony\mastermind\commons\events\ui\ShowHelpRequestEvent.java
``` java
 * An event requesting to view the help page.
 */
public class ShowHelpRequestEvent extends BaseEvent {

    private final ArrayList<HelpPopupEntry> helpEntries;


    
    public ShowHelpRequestEvent(ArrayList<HelpPopupEntry> helpEntries) {
        this.helpEntries = helpEntries;
    }
    
    public ArrayList<HelpPopupEntry> getHelpEntries() {
        return this.helpEntries;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\harmony\mastermind\commons\exceptions\UnwrittableFolderException.java
``` java
public class UnwrittableFolderException extends Exception {
    
    public UnwrittableFolderException(String message) {
        super(message);
    }
    
}
```
###### \java\harmony\mastermind\commons\util\FileUtil.java
``` java
    //Checks if directory is writable
    public static void checkWrittableDirectory(String newFilePath) throws UnwrittableFolderException {
        assert newFilePath != null;
        File newFile = new File(newFilePath);
        if (!(newFile.isDirectory() && newFile.canWrite())) {
            throw new UnwrittableFolderException(newFilePath + " is not writtable.");
        }
    }
    
```
###### \java\harmony\mastermind\commons\util\FileUtil.java
``` java
    //Checks if file path string exists
    public static void checkSaveLocation(String newFilePath) throws FolderDoesNotExistException {
        assert newFilePath != null;
        Path filePath = Paths.get(newFilePath);
        
        if (!Files.exists(filePath)) {
            throw new FolderDoesNotExistException(newFilePath + " does not exist");
        }
    }
}
```
###### \java\harmony\mastermind\logic\commands\ClearCommand.java
``` java
/**
 * Clears the task manager.
 */
public class ClearCommand extends Command  {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_SUCCESS = "Mastermind has been cleared!";
    public static final String COMMAND_DESCRIPTION = "Clearing all of Mastermind's data";

    public ClearCommand() {}

    @Override
    public CommandResult execute() {
        assert model != null;
        model.resetData(TaskManager.getEmptyTaskManager());
        
        return new CommandResult(COMMAND_WORD, MESSAGE_SUCCESS);
    }
}
```
###### \java\harmony\mastermind\logic\commands\HelpCommand.java
``` java
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = "help";

    public static final String COMMAND_DESCRIPTION = "Shows program usage instructions";
    
    public static final String COMMAND_SUMMARY = "Getting help:"
            + "\n" + COMMAND_WORD;
    
    private ArrayList<String> commandList;
    private ArrayList<String> formatList;
    private ArrayList<String> descriptionList;
    private ArrayList<HelpPopupEntry> helpEntries;
    
    public static final String SUCCESSFULLY_SHOWN = "Command summary displayed.";

    public HelpCommand() {
        initInfo();
    }

    private void initInfo() {
        if (helpEntries == null) {
            initCommandWords();
            initFormat();
            initDescription();
            initEntries();
        }
    }
    
    private void initEntries() {
        helpEntries = new ArrayList<HelpPopupEntry>();
        for (int i = 0; i < commandList.size(); i++) {
            helpEntries.add(new HelpPopupEntry(commandList.get(i), formatList.get(i), descriptionList.get(i)));
        }
    }

    private void initCommandWords() {
        commandList = new ArrayList<String>();
        commandList.add(AddCommand.COMMAND_KEYWORD_ADD + ", " + AddCommand.COMMAND_KEYWORD_DO);
        commandList.add(EditCommand.COMMAND_KEYWORD_EDIT + ", " 
        + EditCommand.COMMAND_KEYWORD_UPDATE + ", "
        + EditCommand.COMMAND_KEYWORD_CHANGE);
        commandList.add(UndoCommand.COMMAND_WORD);
        commandList.add(RedoCommand.COMMAND_WORD);
        commandList.add(MarkCommand.COMMAND_WORD);
        commandList.add(UnmarkCommand.COMMAND_WORD);
        commandList.add(DeleteCommand.COMMAND_WORD);
        commandList.add(ClearCommand.COMMAND_WORD);
        commandList.add(FindCommand.COMMAND_WORD);
        commandList.add(ListCommand.COMMAND_WORD);
        commandList.add(UpcomingCommand.COMMAND_WORD);
        commandList.add(RelocateCommand.COMMAND_WORD);
        commandList.add(ImportCommand.COMMAND_WORD);
        commandList.add(ExportCommand.COMMAND_KEYWORD_EXPORT);
        commandList.add(ActionHistoryCommand.COMMAND_KEYWORD_ACTIONHISTORY);
        commandList.add(HelpCommand.COMMAND_WORD);
        commandList.add(ExitCommand.COMMAND_WORD);
    }
    
    private void initFormat() {
        formatList = new ArrayList<String>();
        formatList.add(AddCommand.COMMAND_FORMAT);
        formatList.add(EditCommand.COMMAND_FORMAT);
        formatList.add(UndoCommand.COMMAND_WORD);
        formatList.add(RedoCommand.COMMAND_WORD);
        formatList.add(MarkCommand.COMMAND_FORMAT);
        formatList.add(UnmarkCommand.COMMAND_FORMAT);
        formatList.add(DeleteCommand.COMMAND_FORMAT);
        formatList.add(ClearCommand.COMMAND_WORD);
        formatList.add(FindCommand.COMMAND_FORMAT);
        formatList.add(ListCommand.COMMAND_FORMAT);
        formatList.add(UpcomingCommand.COMMAND_FORMAT);
        formatList.add(RelocateCommand.COMMAND_FORMAT);
        formatList.add(ImportCommand.COMMAND_FORMAT);
        formatList.add(ExportCommand.COMMAND_FORMAT);
        formatList.add(ActionHistoryCommand.COMMAND_KEYWORD_ACTIONHISTORY);
        formatList.add(HelpCommand.COMMAND_WORD);
        formatList.add(ExitCommand.COMMAND_WORD);
    }
    
    private void initDescription() {
        descriptionList = new ArrayList<String>();
        descriptionList.add(AddCommand.COMMAND_DESCRIPTION);
        descriptionList.add(EditCommand.COMMAND_DESCRIPTION);
        descriptionList.add(UndoCommand.COMMAND_DESCRIPTION);
        descriptionList.add(RedoCommand.COMMAND_DESCRIPTION);
        descriptionList.add(MarkCommand.COMMAND_DESCRIPTION);
        descriptionList.add(UnmarkCommand.COMMAND_DESCRIPTION);
        descriptionList.add(DeleteCommand.COMMAND_DESCRIPTION);
        descriptionList.add(ClearCommand.COMMAND_DESCRIPTION);
        descriptionList.add(FindCommand.COMMAND_DESCRIPTION);
        descriptionList.add(ListCommand.COMMAND_DESCRIPTION);
        descriptionList.add(UpcomingCommand.COMMAND_DESCRIPTION);
        descriptionList.add(RelocateCommand.COMMAND_DESCRIPTION);
        descriptionList.add(ImportCommand.COMMAND_DESCRIPTION);
        descriptionList.add(ExportCommand.COMMAND_DESCRIPTION);
        descriptionList.add(ActionHistoryCommand.COMMAND_DESCRIPTION);
        descriptionList.add(HelpCommand.COMMAND_DESCRIPTION);
        descriptionList.add(ExitCommand.COMMAND_DESCRIPTION);
    }
    
```
###### \java\harmony\mastermind\logic\commands\HelpCommand.java
``` java
    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new ShowHelpRequestEvent(helpEntries));
        return new CommandResult(COMMAND_WORD, SUCCESSFULLY_SHOWN);
    }

}
```
###### \java\harmony\mastermind\logic\commands\RelocateCommand.java
``` java
 * Relocates save location
 */
public class RelocateCommand extends Command {

    public static final String COMMAND_WORD = "relocate";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Changes save location in MasterMind. "
            + "Parameters: FILE_PATH\n"
            + "Example: " + COMMAND_WORD
            + "Desktop";
    
    public static final String COMMAND_DESCRIPTION = "Change your data's save location";
    
    public static final String COMMAND_FORMAT = COMMAND_WORD + " <File Path>";

    public static final String MESSAGE_SUCCESS = "Relocated save location to %1$s";
    public static final String MESSAGE_INVALID_INPUT = "%1$s is not valid.";
    public static final String MESSAGE_UNWRITTABLE_FOLDER = "%1$s is not writtable.";

    private final String newFilePath;

    /** 
```
###### \java\harmony\mastermind\logic\commands\RelocateCommand.java
``` java
     * Convenience constructor using raw values.
     */
    public RelocateCommand(String newFilePath) {
        this.newFilePath = newFilePath.trim();
    }

```
###### \java\harmony\mastermind\logic\commands\RelocateCommand.java
``` java
    @Override
    public CommandResult execute() {
        assert model != null;
        assert newFilePath != null;
        try {
            FileUtil.checkSaveLocation(newFilePath);
            FileUtil.checkWrittableDirectory(newFilePath);
            model.relocateSaveLocation(newFilePath);
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_SUCCESS, newFilePath));
        } catch (FolderDoesNotExistException fdnee) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_INVALID_INPUT, newFilePath));
        } catch (UnwrittableFolderException ufe) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNWRITTABLE_FOLDER, newFilePath));
        }
    }
}
```
###### \java\harmony\mastermind\logic\HelpPopupEntry.java
``` java
public class HelpPopupEntry {
    private String commandWord;
    private String format;
    private String description;
    
    public HelpPopupEntry(String commandWord, String format, String description) {
        this.commandWord = commandWord;
        this.format = format;
        this.description = description;
    }

    public String getFormat() {
        return format;
    }

    public String getCommandWord() {
        return commandWord;
    }

    public String getDescription() {
        return description;
    }
}
```
###### \java\harmony\mastermind\model\Model.java
``` java
    /** Relocates save location to given directory */
    void relocateSaveLocation(String directory) throws FolderDoesNotExistException;
    
    
    /** push the command to undo history */
    void pushToUndoHistory(Undoable command);

```
###### \java\harmony\mastermind\model\ModelManager.java
``` java
    /**
     * This method should only be called when the user entered a new command
     * other than redo/undo
     **/
    public void clearUndoHistory() {
        undoHistory.clear();
    }

    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        taskManager.removeTask(target);
        indicateTaskManagerChanged();
    }

```
###### \java\harmony\mastermind\model\ModelManager.java
``` java
    @Override
    public synchronized void relocateSaveLocation(String newFilePath) throws FolderDoesNotExistException {
        raise(new RelocateFilePathEvent(newFilePath));
        indicateTaskManagerChanged();
    }
    

    // =========== Methods for Recurring Tasks=============================

```
###### \java\harmony\mastermind\storage\JsonUserPrefStorage.java
``` java
    public void setFilePath(String filePath) {
        assert filePath != null;
        logger.fine(String.format(SUCCESSFULLY_CHANGED_FILEPATH, filePath));
        this.filePath = filePath;
    }
}
```
###### \java\harmony\mastermind\storage\StorageManager.java
``` java
    /**
     * Handles RelocateFilePathEvent by first changing taskManger's file path, then moving
     * the file over and deleting the old one
     */
    @Subscribe
    public void handleRelocateEvent(RelocateFilePathEvent event) {
        assert event != null;
        assert event.getFilePath() != null;
        String oldPath = taskManagerStorage.getTaskManagerFilePath();
        String newPath = correctFilePathFormat(event.getFilePath());
        taskManagerStorage.setTaskManagerFilePath(newPath);
        updateConfig(newPath);
        try {
            logger.info("Trying to move into new file path.");
            taskManagerStorage.migrateIntoNewFolder(oldPath, newPath);
        } catch (IOException e) {
            logger.warning("Error occured while handling relocate event.");
            logger.warning("Reverting save location back to " + oldPath);
            taskManagerStorage.setTaskManagerFilePath(oldPath);
            updateConfig(oldPath);
        }
    }
   
```
###### \java\harmony\mastermind\storage\StorageManager.java
``` java
    //Appends the '/' if it is not that for a valid file path
    public String correctFilePathFormat(String newPath) {
        assert newPath != null;
        if (newPath.endsWith("/")) {
            newPath = newPath + "mastermind.xml";
        } else {
            newPath = newPath + "/mastermind.xml";
        }
        return newPath;
    }
    
```
###### \java\harmony\mastermind\storage\StorageManager.java
``` java
    /**
     * Updates the config.json file so that upon startup, the correct xml file will be
     * loaded.
     * @param newPath
     */
    public void updateConfig(String newPath) {
        assert newPath != null;
        Config config;
        String defaultConfigLocation = Config.DEFAULT_CONFIG_FILE;
        
        try {
            Optional<Config> configOptional = ConfigUtil.readConfig(defaultConfigLocation);
            config = configOptional.orElse(new Config());
        } catch (DataConversionException e) {
            logger.warning("Config file at " + defaultConfigLocation + " is not in the correct format. " +
                    "Using default config properties");
            config = new Config();
        }
        config.setTaskManagerFilePath(newPath);
        logger.fine("Updated config's data save location.");
        
        //Update config file in case it was missing to begin with or there are new/unused fields
        try {
            ConfigUtil.saveConfig(config, defaultConfigLocation);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }
    }
}
```
###### \java\harmony\mastermind\ui\HelpPopup.java
``` java
public class HelpPopup extends UiPart {

    private static final String FXML = "HelpPopup.fxml";

    private final String COMMAND_COL_HEADER = "Command";
    private final String FORMAT_COL_HEADER = "Format";
    private final String USAGE_COL_HEADER = "Usage";
    
    private final int COMMAND_COL_MIN_WIDTH = 100;
    private final int FORMAT_COL_MIN_WIDTH = 200;
    private final int USAGE_COL_MIN_WIDTH = 200;
    
    private final int DEFAULT_X_POS = 200;
    private final int DEFAULT_Y_POS = 100;
    private final int DEFAULT_HEIGHT = 800;
    private final int DEFAULT_WIDTH = 1000;

    private Popup popup;
    private boolean isFirstKey;
    private TableView<HelpPopupEntry> table;
    
    TableColumn<HelpPopupEntry, String> commandCol;
    TableColumn<HelpPopupEntry, String> formatCol;
    TableColumn<HelpPopupEntry, String> usageCol;
    
    ObservableList<HelpPopupEntry> entries;
    
```
###### \java\harmony\mastermind\ui\HelpPopup.java
``` java
    public HelpPopup() {
        initTable();
        initPopup();
        isFirstKey = true;
    }

```
###### \java\harmony\mastermind\ui\HelpPopup.java
``` java
    public void show(Node node) {
        assert node != null;
        table.setItems(entries);

        popup.show(node, DEFAULT_X_POS, DEFAULT_Y_POS);
        popup.centerOnScreen();
    }

```
###### \java\harmony\mastermind\ui\HelpPopup.java
``` java
    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
```
###### \java\harmony\mastermind\ui\HelpPopup.java
``` java
    @FXML
    private void initPopup() {
        popup = new Popup();

        popup.getContent().add(table);
        //properties();

        popup.addEventHandler(KeyEvent.KEY_RELEASED, keyEventHandler);
    }
    
```
###### \java\harmony\mastermind\ui\HelpPopup.java
``` java
    @FXML
    private void initTable() {
        table = new TableView<HelpPopupEntry>();
        table.setEditable(false);
        
        initCommandCol();
        initFormatCol();
        initUsageCol();
        
        table.getColumns().addAll(commandCol, formatCol, usageCol);
    }
    
```
###### \java\harmony\mastermind\ui\HelpPopup.java
``` java
    private void initCommandCol() {
        commandCol = new TableColumn<HelpPopupEntry, String>(COMMAND_COL_HEADER);
        commandCol.setMinWidth(COMMAND_COL_MIN_WIDTH);
        commandCol.setCellValueFactory(entry -> new ReadOnlyStringWrapper(entry.getValue().getCommandWord()));
    }

```
###### \java\harmony\mastermind\ui\HelpPopup.java
``` java
    private void initFormatCol() {
        formatCol = new TableColumn<HelpPopupEntry, String>(FORMAT_COL_HEADER);
        formatCol.setMinWidth(FORMAT_COL_MIN_WIDTH);
        formatCol.setCellValueFactory(entry -> new ReadOnlyStringWrapper(entry.getValue().getFormat()));
    }
    
```
###### \java\harmony\mastermind\ui\HelpPopup.java
``` java
    private void initUsageCol() {
        usageCol = new TableColumn<HelpPopupEntry, String>(USAGE_COL_HEADER);
        usageCol.setMinWidth(USAGE_COL_MIN_WIDTH);
        usageCol.setCellValueFactory(entry -> new ReadOnlyStringWrapper(entry.getValue().getDescription()));
    }
    
```
###### \java\harmony\mastermind\ui\HelpPopup.java
``` java
    @FXML
    EventHandler<KeyEvent> keyEventHandler = new EventHandler<KeyEvent>() {
        public void handle(KeyEvent event) {
            if (!isFirstKey && event.getCode() != null) {
                popup.hide();
            }
            isFirstKey = !isFirstKey;
        }
    };
    

```
###### \java\harmony\mastermind\ui\HelpPopup.java
``` java
    public void injectData(ArrayList<HelpPopupEntry> helpEntries) {
        entries = FXCollections.observableArrayList();
        for (int i = 0; i < helpEntries.size(); i++) {
            entries.add(helpEntries.get(i));
        }
    }
}
```
###### \java\harmony\mastermind\ui\MainWindow.java
``` java
    public Node getNode() {
        return rootLayout;
    }

```
###### \java\harmony\mastermind\ui\UiManager.java
``` java
    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        helpPopup.injectData(event.getHelpEntries());
        helpPopup.show(mainWindow.getNode());
    }

```
