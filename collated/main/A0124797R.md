# A0124797R
###### /java/harmony/mastermind/commons/exceptions/NotRecurringTaskException.java
``` java
/**
 * Signals that current Task is not recurring Task and not able to perform methods that are
 * for recurring tasks
 */
public class NotRecurringTaskException extends Exception{
    
    public NotRecurringTaskException() {
        super("Task is not a recurring Task");
    }

}
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
/**
 * Represents the in-memory model of the address book data. All changes to any
 * model should be synchronized.
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private final int FAIL = -1;
    private final TaskManager taskManager;
    private final FilteredList<Task> filteredTasks;
    private final FilteredList<Task> filteredFloatingTasks;
    private final FilteredList<Task> filteredEvents;
    private final FilteredList<Task> filteredDeadlines;
    private final FilteredList<Task> filteredArchives;
    private final Stack<Undoable> undoHistory;
    private final Stack<Redoable> redoHistory;
    private final Stack<String> commandHistory;

    public static final String TAB_HOME = "Home";
    public static final String TAB_TASKS = "Tasks";
    public static final String TAB_EVENTS = "Events";
    public static final String TAB_DEADLINES = "Deadlines";
    public static final String TAB_ARCHIVES = "Archives";

    private String currentTab;

    /**
     * Initializes a ModelManager with the given TaskManager TaskManager and its
     * variables should not be null
     */
    public ModelManager(TaskManager src, UserPrefs userPrefs) {
        super();
        assert src != null;
        assert userPrefs != null;

        logger.fine("Initializing with task manager: "
                    + src
                    + " and user prefs "
                    + userPrefs);

        taskManager = new TaskManager(src);
        filteredTasks = new FilteredList<>(taskManager.getTasks());
        filteredFloatingTasks = new FilteredList<>(taskManager.getFloatingTasks());
        filteredEvents = new FilteredList<>(taskManager.getEvents());
        filteredDeadlines = new FilteredList<>(taskManager.getDeadlines());
        filteredArchives = new FilteredList<>(taskManager.getArchives());
        undoHistory = new Stack<>();
        redoHistory = new Stack<>();
        commandHistory = new Stack<String>();
        currentTab = TAB_HOME;
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public ModelManager(ReadOnlyTaskManager initialData, UserPrefs userPrefs) {
        taskManager = new TaskManager(initialData);
        filteredTasks = new FilteredList<>(taskManager.getTasks());
        filteredFloatingTasks = new FilteredList<>(taskManager.getFloatingTasks());
        filteredEvents = new FilteredList<>(taskManager.getEvents());
        filteredDeadlines = new FilteredList<>(taskManager.getDeadlines());
        filteredArchives = new FilteredList<>(taskManager.getArchives());
        undoHistory = new Stack<>();
        redoHistory = new Stack<>();
        commandHistory = new Stack<String>();
        indicateTaskManagerChanged();
        currentTab = TAB_HOME;
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    /** update current tab to the specified tab*/
    public void updateCurrentTab(String tab) {
        this.currentTab = tab;
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    /** Deletes the given archived Task */
    public synchronized void deleteArchive(ReadOnlyTask target) throws TaskNotFoundException, ArchiveTaskList.TaskNotFoundException {
        taskManager.removeArchive(target);
        indicateTaskManagerChanged();
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    public synchronized void markTask(Task target) throws TaskNotFoundException {
        taskManager.markTask(target);
        indicateTaskManagerChanged();
    }
    
    @Override
    public synchronized void markDue(ArrayList<Task> targets) throws TaskNotFoundException {
        for (Task t: targets) {
            taskManager.markTask(t);
        }
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void unmarkTask(Task target) throws ArchiveTaskList.TaskNotFoundException, UniqueTaskList.DuplicateTaskException {
        taskManager.unmarkTask(target);
        indicateTaskManagerChanged();
    }
    
    @Override
    public String getCurrentTab(){
        return this.currentTab;
    }


```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    //=========== Filtered List Accessors ===============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredFloatingTaskList() {
        return new UnmodifiableObservableList<>(filteredFloatingTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredEventList() {
        return new UnmodifiableObservableList<>(filteredEvents);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredDeadlineList() {
        return new UnmodifiableObservableList<>(filteredDeadlines);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredArchiveList() {
        return new UnmodifiableObservableList<>(filteredArchives);
    }
    
    // =========== Methods for file access ================================

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    public synchronized void addNextTask(Task task) throws UniqueTaskList.DuplicateTaskException, NotRecurringTaskException {
        taskManager.addNextTask(task);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    public ObservableList<Task> getListToMark() {
        return getCurrentObservableList();
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    public void updateFilteredListToShow(String tab) {
        switch (tab) {
            case TAB_HOME:
                currentTab = TAB_HOME;
                break;
            case TAB_TASKS:
                currentTab = TAB_TASKS;
                break;
            case TAB_EVENTS:
                currentTab = TAB_EVENTS;
                break;
            case TAB_DEADLINES:
                currentTab = TAB_DEADLINES;
                break;
            case TAB_ARCHIVES:
                currentTab = TAB_ARCHIVES;
                break;
        }
        updateFilteredListToShowAll();
    }
    
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        switch (currentTab) {
            case TAB_HOME:
                filteredTasks.setPredicate(null);
                break;
            case TAB_TASKS:
                filteredFloatingTasks.setPredicate(null);
                break;
            case TAB_EVENTS:
                filteredEvents.setPredicate(null);
                break;
            case TAB_DEADLINES:
                filteredDeadlines.setPredicate(null);
                break;
            case TAB_ARCHIVES:
                filteredArchives.setPredicate(null);
                break;
        }
    }
    
    @Override
    public int getCurrentListSize() {
        switch (currentTab) {
            case TAB_HOME:
                return filteredTasks.size();
            case TAB_TASKS:
                return filteredFloatingTasks.size();
            case TAB_EVENTS:
                return filteredEvents.size();
            case TAB_DEADLINES:
                return filteredDeadlines.size();
            case TAB_ARCHIVES:
                return filteredArchives.size();
            default:
                //should not reach here
                return FAIL;
        }
    }

    @Override
    public void updateFilteredListToShowUpcoming(long time, String taskType) {
        updateFilteredList(new PredicateExpression(new DateQualifier(time, taskType)));
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    public void updateFilteredTagTaskList(Set<Tag> keywords) {
        updateFilteredList(new PredicateExpression(new TagQualifier(keywords)));
    }

    /**
     * update filtered list of specific tabs
     * @param expression
     */
    private void updateFilteredList(Expression expression) {
        switch (currentTab) {
            case TAB_HOME:
                filteredTasks.setPredicate(expression::satisfies);
                break;
            case TAB_TASKS:
                filteredFloatingTasks.setPredicate(expression::satisfies);
                break;
            case TAB_EVENTS:
                filteredEvents.setPredicate(expression::satisfies);
                break;
            case TAB_DEADLINES:
                filteredDeadlines.setPredicate(expression::satisfies);
                break;
            case TAB_ARCHIVES:
                filteredArchives.setPredicate(expression::satisfies);
                break;
        }
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    /**
     * Returns an ObservableList of the filtered tasks in current Tab
     */
    private ObservableList<Task> getCurrentObservableList() {
        ObservableList<Task> list = filteredTasks;
        
        switch (currentTab) {
            case "Home":
                list = filteredTasks;
                break;
            case "Tasks":
                list = filteredFloatingTasks;
                break;
            case "Events":
                list = filteredEvents;
                break;
            case "Deadlines":
                list = filteredDeadlines;
                break;
            case "Archives":
                list = filteredArchives;
                break;
        }

        return list;
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    /** Returns an UnmodifiableObservableList of filtered tasks in current Tab */
    public UnmodifiableObservableList<ReadOnlyTask> getCurrentList() {
        return new UnmodifiableObservableList<ReadOnlyTask>(getCurrentObservableList());
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    /**
     * used as a qualifier to filter tasks by tags
     */
    private class TagQualifier implements Qualifier {
        private Set<Tag> tagKeyWords;

        TagQualifier(Set<Tag> tagKeyWords) {
            this.tagKeyWords = tagKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            final Set<Tag> tagList = task.getTags().toSet();

            return !Collections.disjoint(tagList, tagKeyWords);
        }

        @Override
        public String toString() {
            return "tags="
                   + String.join(", ", tagKeyWords.toString());
        }
    }

    /**
     * used as a qualifier to filter dates to use in {@code UpcomingCommand}
     */
    private class DateQualifier implements Qualifier {
        private final String TYPE_DEADLINE = "deadlines";
        private final String TYPE_EVENT = "events";
        private final String TYPE_DUE = "due";
        
        private long timeNow;
        private long oneWeekFromNow;
        private final long oneWeek = 604800000;
        private String taskType;

        DateQualifier(long time, String taskType) {
            this.timeNow = new Date().getTime();
            this.oneWeekFromNow = time + oneWeek;
            this.taskType = taskType;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            switch (taskType) {
                case TYPE_DEADLINE:
                    return isUpcomingDeadline(task);
                case TYPE_EVENT:
                    return isUpcomingEvent(task);
                case TYPE_DUE:
                    return isTaskDue(task);
                default:
                    return isUpcomingAll(task);
            }
        }

        @Override
        public String toString() {
            return "Date before:"
                   + oneWeekFromNow;
        }
        
        private boolean isUpcomingAll(ReadOnlyTask task) {
            if (task.isFloating()) {
                return true;
            } else {
                return isUpcoming(task);
            }
        }
        
        private boolean isUpcomingEvent(ReadOnlyTask task) {
            if (task.isFloating() || task.isDeadline()) {
                return false;
            } else {
                return isUpcoming(task);
            }
        }
        
        private boolean isUpcomingDeadline(ReadOnlyTask task) {
            if (task.isFloating() || task.isEvent()) {
                return false;
            } else {
                return isUpcoming(task);
            }
        }
        
        private boolean isTaskDue(ReadOnlyTask task) {
            if (task.isFloating()) {
                return false;
            } else {
                return isDue(task);
            }
        }
        
        /**
         * Checks if end date of task is within one week from now.
         */
        private boolean isUpcoming(ReadOnlyTask task) {
            long taskTime = task.getEndDate().getTime();
            boolean isUpcoming = taskTime < oneWeekFromNow && taskTime > timeNow;
            return isUpcoming;
        }
        
        /**
         * Checks if tasks has already past
         */
        private boolean isDue(ReadOnlyTask task) {
            long taskTime = task.getEndDate().getTime();
            return taskTime < timeNow;
        }
    }

    
    /**
     * handle changing of tabs when using specific commands
     * @param event
     */
    @Subscribe
    private void handleTabChangedEvent(TabChangedEvent event){
        this.updateCurrentTab(event.toTabId);
    }
    
```
###### /java/harmony/mastermind/model/ReadOnlyTaskManager.java
``` java
/**
 * Unmodifiable view of an task manager
 * 
 */
public interface ReadOnlyTaskManager {

    UniqueTagList getUniqueTagList();

    UniqueTaskList getUniqueTaskList();

    UniqueTaskList getUniqueFloatingTaskList();

    UniqueTaskList getUniqueEventList();

    UniqueTaskList getUniqueDeadlineList();
    
    ArchiveTaskList getUniqueArchiveList();

    /** Returns an unmodifiable view of tasks list */
    List<ReadOnlyTask> getTaskList();

    /** Returns an unmodifiable view of tasks list */
    List<ReadOnlyTask> getFloatingTaskList();

    /** Returns an unmodifiable view of tasks list*/
    List<ReadOnlyTask> getEventList();

    /** Returns an unmodifiable view of tasks list */
    List<ReadOnlyTask> getDeadlineList();
    
    /** Returns an unmodifiable view of archive list */
    List<ReadOnlyTask> getArchiveList();

    /** Returns an unmodifiable view of tags list */
    List<Tag> getTagList();




}
```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Deletes the given Archived Task */
    void deleteArchive(ReadOnlyTask target) throws TaskNotFoundException, ArchiveTaskList.TaskNotFoundException;

```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Add the next recurring task */
    void addNextTask(Task task) throws UniqueTaskList.DuplicateTaskException, NotRecurringTaskException;

```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Marks the given task as done */
    void markTask(Task target) throws UniqueTaskList.TaskNotFoundException;
    
    /** Marks the given List of due tasks as done */
    void markDue(ArrayList<Task> targets) throws UniqueTaskList.TaskNotFoundException;

```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Updates the completed task as not done */
    void unmarkTask(Task target) throws UniqueTaskList.DuplicateTaskException,
    ArchiveTaskList.TaskNotFoundException;
    
```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Returns the current list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getCurrentList();

```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Returns the filtered floating task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredFloatingTaskList();
    
    /** Returns the filtered event list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredEventList();
    
    /** Returns the filtered deadline list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredDeadlineList();
    
    /** Returns the filtered archive list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredArchiveList();

```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** update current tab to the specified tab*/
    void updateCurrentTab(String tab);

    /** Updates the filter of the filtered task list for current tab to show all tasks */
    void updateFilteredListToShowAll();
    
    /** Updates the filter of the filtered task list for specified tab to show all tasks */
    void updateFilteredListToShow(String tab);
    
    /** Updates the filter of the filtered task list 
     * for Home tab to show all upcoming tasks */
    void updateFilteredListToShowUpcoming(long time, String taskType);
    
```
###### /java/harmony/mastermind/model/Model.java
``` java
    String getCurrentTab();
    
    /** get the filtered list size for the current tab */
    int getCurrentListSize();

```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** reads the file indicated */
    BufferedReader importFile(String fileToImport) throws FileNotFoundException;


}
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public String getRecur() {
        return this.recur;
    }
    
    @Override
    public boolean isRecur() {
        return recur != null;
    }

    @Override
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    @Override 
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Task // instanceof handles nulls
                && this.toString().equals(((Task) other).toString())); // state check
        
    }

    /** checks if task is marked */
    @Override
    public boolean isMarked() {
        return this.isMarked;
    }

```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    /** set task as marked */
    public Task mark() {
        this.isMarked = true;
        return this;
    }
    
    /** set task as not mark */
    public Task unmark() {
        this.isMarked = false;
        return this;
    }
    
    @Override
    public String toString() {
        return getAsText();
    }

```
###### /java/harmony/mastermind/model/task/ArchiveTaskList.java
``` java
public class ArchiveTaskList implements Iterable<Task> {

    private final ObservableList<Task> internalList = FXCollections.observableArrayList();


    /**
     * Signals that an operation targeting a specified task in the list would fail because
     * there is no such matching task in the list.
     */
    public static class TaskNotFoundException extends Exception {}
    
    
    /**
     * Constructs empty ArchiveTaskList.
     */
    public ArchiveTaskList() {}

    /**
     * Returns true if the list contains an equivalent task as the given argument.
     */
    public boolean contains(ReadOnlyTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds an archived task to the list.
     */
    public void add(Task toAdd) {
        assert toAdd != null;
        
        internalList.add(toAdd);
    }

    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {
            throw new TaskNotFoundException();
        }
        return taskFoundAndDeleted;
    }

    public ObservableList<Task> getInternalList() {
        return internalList;
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ArchiveTaskList // instanceof handles nulls
                && this.internalList.equals(
                ((ArchiveTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

}
```
###### /java/harmony/mastermind/model/task/ReadOnlyTask.java
``` java
public interface ReadOnlyTask {
    //provide safe read, unmodifiable task object
    final int INDEX_DAY = 0;
    final int INDEX_MONTH = 1;
    final int INDEX_DATE = 2;
    final int INDEX_TIME = 3;
    final int INDEX_YEAR = 5;
    final int INDEX_HOUR = 0;
    final int INDEX_MINUTE = 1;

    public String getName();
    public Date getStartDate();
    public Date getEndDate();
    public Date getCreatedDate();
    public UniqueTagList getTags();
    public String getRecur();
    
    public boolean isMarked();
    public boolean isFloating();
    public boolean isDeadline();
    public boolean isEvent();
    public boolean isRecur();
    
    public boolean isDue();
    public boolean isHappening();
    public Duration getDueDuration();
    public Duration getEventDuration();
    
    default boolean isSameTask(ReadOnlyTask task) {
        return task == this // short circuit if same object
                || (this.toString().equals(task.toString())); // state check  
    }
    
    /**
     * Formats the task as text, showing all task details.
     */
```
###### /java/harmony/mastermind/model/task/ReadOnlyTask.java
``` java
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        
        if (getStartDate() != null) {
            builder.append(" start:" + parseForConsole(getStartDate()));
        }
        
        if (getEndDate() != null) {
            builder.append(" end:" + parseForConsole(getEndDate()));
        }
        
        if (!getTags().toString().isEmpty()) {
            builder.append(" Tags: ")
            .append(getTags().toString());
        }
                
        return builder.toString();
    }

```
###### /java/harmony/mastermind/model/task/ReadOnlyTask.java
``` java
    /**
     * Formats the Date as text, showing Task's date.
     */
    default String parse(Date date) {
        String[] dateArr = date.toString().split(" ");
        String[] timeArr = dateArr[INDEX_TIME].split(":");
        final StringBuilder builder = new StringBuilder();
        
        builder.append(dateArr[INDEX_DAY] + " ").append(timeArr[INDEX_HOUR] + ":" + timeArr[INDEX_MINUTE] + " ")
            .append(dateArr[INDEX_DATE] + " ").append(dateArr[INDEX_MONTH] + " ").append(dateArr[INDEX_YEAR]);
        
        return builder.toString();
        
    }

```
###### /java/harmony/mastermind/model/task/ReadOnlyTask.java
``` java
    /**
     * Formats the Date as text, showing Task's date.
     */
    default String parseForConsole(Date date) {
        String[] dateArr = date.toString().split(" ");
        String[] timeArr = dateArr[INDEX_TIME].split(":");
        String year = dateArr[INDEX_YEAR].substring(2, 4);
        final StringBuilder builder = new StringBuilder();
        
        builder.append(timeArr[INDEX_HOUR] + ":" + timeArr[INDEX_MINUTE] + "|")
            .append(dateArr[INDEX_DATE]).append(dateArr[INDEX_MONTH]).append(year);
        
        return builder.toString();
        
    }
    
}
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
/**
 * Wraps all data at the task-manager level
 * Duplicates are not allowed (by .equals comparison)
 */
public class TaskManager implements ReadOnlyTaskManager {
    private static final int INDEX_RECURRENCE_KEYWORD = 0;
    private static final int INDEX_RECURRENCE_AMOUNT = 1;

    private static final int ONE_DAY = 1;
    private static final int ONE_WEEK = 7;
    private static final int ONE_MONTH = 1;
    private static final int ONE_YEAR = 1;
    
    private final UniqueTaskList tasks;
    private final UniqueTaskList floatingTasks;
    private final UniqueTaskList events;
    private final UniqueTaskList deadlines;
    private final ArchiveTaskList archives;
    private final UniqueTagList tags;
    private final TaskListComparator comparator;

    {
        tasks = new UniqueTaskList();
        floatingTasks = new UniqueTaskList();
        events = new UniqueTaskList();
        deadlines = new UniqueTaskList();
        archives = new ArchiveTaskList();
        tags = new UniqueTagList();
        comparator = new TaskListComparator();
    }

    public TaskManager() {}

    /**
     * Tasks and Tags are copied into this TaskManager
     */
    public TaskManager(ReadOnlyTaskManager toBeCopied) {
        this(toBeCopied.getUniqueTaskList(), toBeCopied.getUniqueFloatingTaskList(), 
                toBeCopied.getUniqueEventList(), toBeCopied.getUniqueDeadlineList(), 
                toBeCopied.getUniqueTagList(), toBeCopied.getUniqueArchiveList());
    }

    /**
     * Tasks and Tags are copied into this TaskManager
     */
    public TaskManager(UniqueTaskList tasks, UniqueTaskList floatingTasks, UniqueTaskList events, UniqueTaskList deadlines, UniqueTagList tags, ArchiveTaskList archiveTasks) {
        resetData(tasks.getInternalList(), floatingTasks.getInternalList(), events.getInternalList(),
                deadlines.getInternalList(), tags.getInternalList(), archiveTasks.getInternalList());
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    /** returns an {@code ObservableList} of floating tasks*/
    public ObservableList<Task> getFloatingTasks() {
        return floatingTasks.getInternalList();
    }
    
    /** returns an {@code ObservableList} of events*/
    public ObservableList<Task> getEvents() {
        return events.getInternalList();
    }
    
    /** returns an {@code ObservableList} of deadlines*/
    public ObservableList<Task> getDeadlines() {
        return deadlines.getInternalList();
    }

    /** returns an {@code ObservableList} of archives*/
    public ObservableList<Task> getArchives() {
        return archives.getInternalList();
    }
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public void setFloatingTasks(List<Task> floatingTasks) {
        this.floatingTasks.getInternalList().setAll(floatingTasks);
    }

    public void setEvents(List<Task> events) {
        this.events.getInternalList().setAll(events);
    }

    public void setDeadlines(List<Task> deadlines) {
        this.deadlines.getInternalList().setAll(deadlines);
    }
    
    public void setArchiveTasks(Collection<Task> archiveTasks) {
        this.archives.getInternalList().setAll(archiveTasks);
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public void resetData(Collection<? extends ReadOnlyTask> newTasks, 
            Collection<? extends ReadOnlyTask> newFloatingTasks, 
            Collection<? extends ReadOnlyTask> newEvents,
            Collection<? extends ReadOnlyTask> newDeadlines, 
            Collection<Tag> newTags,
            Collection<? extends ReadOnlyTask> newArchiveTasks) {
        
        setTasks(newTasks.stream().map(Task::new).collect(Collectors.toList()));
        setFloatingTasks(newFloatingTasks.stream().map(Task::new).collect(Collectors.toList()));
        setEvents(newEvents.stream().map(Task::new).collect(Collectors.toList()));
        setDeadlines(newDeadlines.stream().map(Task::new).collect(Collectors.toList()));
        setTags(newTags);
        setArchiveTasks(newArchiveTasks.stream().map(Task::new).map(Task::mark).collect(Collectors.toList()));
    }

    public void resetData(ReadOnlyTaskManager newData) {
        resetData(newData.getTaskList(), newData.getFloatingTaskList(), newData.getEventList(), 
                newData.getDeadlineList(), newData.getTagList(), newData.getArchiveList());
    }



//// task-level operations

    /**
     * Adds a task to the task manager and synchronize with all the tabs.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task t) throws UniqueTaskList.DuplicateTaskException {
        syncTagsWithMasterList(t);
        tasks.add(t);
        syncAddTask(t);
        this.getUniqueTaskList().getInternalList().sort(comparator);

    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    /**
     * Adds the next recurring task to the task manager.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addNextTask(Task t) throws UniqueTaskList.DuplicateTaskException, NotRecurringTaskException {
        syncTagsWithMasterList(t);
        Task newT = getNextTask(t);
        tasks.add(newT);
        syncAddTask(newT);
        EventsCenter.getInstance().post(new HighlightLastActionedRowRequestEvent(newT));
    }
    
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    /**
     * returns a Task with the next recurring date given a recurring Task
     * @throws NotRecurringTaskException
     */
    public Task getNextTask(Task t) throws NotRecurringTaskException {
        if (t.isFloating() || t.getRecur() == null){
            throw new NotRecurringTaskException();
        }
        
        Task newT = null;
        String[] recurVal = t.getRecur().split(" ");
        String nextRecur = getNextRecur(t.getRecur());
        Date nextEndDate = getNextDate(t.getEndDate(),recurVal[INDEX_RECURRENCE_KEYWORD]);
        
        if (t.isDeadline()) {
            newT = new Task(t.getName(), nextEndDate, t.getTags(), nextRecur, new Date());
        }else if (t.isEvent()) {
            Date nextStartDate = getNextDate(t.getStartDate(), recurVal[INDEX_RECURRENCE_KEYWORD]);
            newT = new Task(t.getName(), nextStartDate, nextEndDate, t.getTags(), nextRecur, new Date());
        }
        
        return newT;
        
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    /**
    * returns the next date based on the type of recurring task
    */
    private Date getNextDate(Date d, String recur) {
        Calendar c = Calendar.getInstance();
        c.setTime(d);
        int date;
        switch (recur) {
            case "daily" :   
                date = c.get(Calendar.DATE);
                c.set(Calendar.DATE, date + ONE_DAY);
                break;
            case "weekly" :  
                date = c.get(Calendar.DATE);
                c.set(Calendar.DATE, date + ONE_WEEK);
                break;
            case "monthly" : 
                date = c.get(Calendar.MONTH);
                c.set(Calendar.MONTH, date + ONE_MONTH);
                break;
            case "yearly" :  
                date = c.get(Calendar.YEAR);
                c.set(Calendar.YEAR, date + ONE_YEAR);
                break;
            default :
                assert false;
        }
        
        return c.getTime();
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    /**
    * returns the next date based on the type of recurring task
    */
    private String getNextRecur(String recur) {
        String[] recurArr = recur.split(" ");
        if (recurArr.length==1) {
            return recur;
        }else {
            int counter = Integer.parseInt(recurArr[INDEX_RECURRENCE_AMOUNT]);
            
            if (counter>2) {
                return recurArr[0] + " " + Integer.toString(counter-1);
            } else {
                return null;
            }
        }
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    /**
     * Removes an archived task as indicated
     */
    public boolean removeArchive(ReadOnlyTask key) throws ArchiveTaskList.TaskNotFoundException {
        if (archives.remove(key)) {
            return true;
        } else {
            throw new ArchiveTaskList.TaskNotFoundException();
        }
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    /**
     * marks task as completed by
     * removing the task from tasks and adds into archivedtasks
     */
    public boolean markTask(Task key) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.remove(key)) {
            archives.add(key.mark());
            this.getUniqueTaskList().getInternalList().sort(comparator);
            syncRemoveTask(key);
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    /**
     * marks task as not completed by
     * removing the task from archivedTasks and adds into tasks
     */
    public boolean unmarkTask(Task key) throws DuplicateTaskException, ArchiveTaskList.TaskNotFoundException {
        if (archives.remove(key)) {
            tasks.add(key.unmark());
            this.getUniqueTaskList().getInternalList().sort(comparator);
            syncAddTask(key.unmark());
            return true;
        } else {
            throw new ArchiveTaskList.TaskNotFoundException();
        }
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    /**
     * Synchronize adding of tasks across the tabs
     */
    private void syncAddTask(Task task) throws DuplicateTaskException{   
        if (task.isFloating()) {
            floatingTasks.add(task);
        } else if (task.isDeadline()) {
            deadlines.add(task);
        } else if (task.isEvent()) {
            events.add(task);
        }
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    /**
     * Synchronize removing of tasks across the tabs
     */
    private void syncRemoveTask(ReadOnlyTask task) throws TaskNotFoundException{
        if (task.isFloating()) {
            floatingTasks.remove(task);
        } else if (task.isDeadline()) {
            deadlines.remove(task);
        } else if (task.isEvent()) {
            events.remove(task);
        }
    }


//// tag-level operations

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getFloatingTaskList() {
        return Collections.unmodifiableList(floatingTasks.getInternalList());
    }
    
    @Override
    public List<ReadOnlyTask> getEventList() {
        return Collections.unmodifiableList(events.getInternalList());
    }
    
    @Override
    public List<ReadOnlyTask> getDeadlineList() {
        return Collections.unmodifiableList(deadlines.getInternalList());
    }
    
    @Override
    public List<ReadOnlyTask> getArchiveList() {
        return Collections.unmodifiableList(archives.getInternalList());
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    @Override
    public UniqueTaskList getUniqueFloatingTaskList() {
        return this.floatingTasks;
    }

    @Override
    public UniqueTaskList getUniqueEventList() {
        return this.events;
    }

    @Override
    public UniqueTaskList getUniqueDeadlineList() {
        return this.deadlines;
    }

    @Override
    public ArchiveTaskList getUniqueArchiveList() {
        return this.archives;
    }
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskManager // instanceof handles nulls
                && this.tasks.equals(((TaskManager) other).tasks)
                && this.floatingTasks.equals(((TaskManager) other).floatingTasks)
                && this.events.equals(((TaskManager) other).events)
                && this.deadlines.equals(((TaskManager) other).deadlines)
                && this.tags.equals(((TaskManager) other).tags)
                && this.archives.equals(((TaskManager) other).archives));
    }

```
###### /java/harmony/mastermind/storage/XmlAdaptedArchive.java
``` java
/**
 * JAXB-friendly version of the archived Task.
 * 
 */
public class XmlAdaptedArchive {

    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private Date startDate;
    @XmlElement(required = true)
    private Date endDate;
    @XmlElement(required = true)
    private String recur;
    @XmlElement(required = true)
    private Date createdDate;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedArchive() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedArchive(ReadOnlyTask source) {
        name = source.getName();
        startDate = source.getStartDate();
        endDate = source.getEndDate();
        recur = source.getRecur();
        createdDate = source.getCreatedDate();
        
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's ReadOnlyTask object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        
        final String name = this.name;
        final Date startDate = this.startDate;
        final Date endDate = this.endDate;
        final String recur = this.recur;
        final UniqueTagList tags = new UniqueTagList(taskTags);
        final Date createdDate = this.createdDate;
        
        return new Task(name, startDate, endDate, tags, recur, createdDate).mark();
    }
}
```
###### /java/harmony/mastermind/storage/XmlAdaptedDeadline.java
``` java
/**
 * JAXB-friendly version of the deadline type Task.
 */
public class XmlAdaptedDeadline {

    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private Date endDate;
    @XmlElement(required = true)
    private String recur;
    @XmlElement(required = true)
    private Date createdDate;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedDeadline() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedDeadline
     */
    public XmlAdaptedDeadline(ReadOnlyTask source) {
        name = source.getName();
        endDate = source.getEndDate();
        recur = source.getRecur();
        createdDate = source.getCreatedDate();

        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted deadline object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted deadline
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        
        final String name = this.name;
        final Date endDate = this.endDate;
        final String recur = this.recur;
        final UniqueTagList tags = new UniqueTagList(taskTags);
        
        return new Task(name, endDate, tags, recur, createdDate);
    }
}
```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    /**
     * Conversion task manager to a JAXB-friendly version
     */
    public XmlSerializableTaskManager(ReadOnlyTaskManager src) {
        floatingTasks.addAll(src.getFloatingTaskList().stream().map(XmlAdaptedTask::new).collect(Collectors.toList()));
        events.addAll(src.getEventList().stream().map(XmlAdaptedEvent::new).collect(Collectors.toList()));
        deadlines.addAll(src.getDeadlineList().stream().map(XmlAdaptedDeadline::new).collect(Collectors.toList()));
        tags = src.getTagList();
        archives.addAll(src.getArchiveList().stream()
                .map(XmlAdaptedArchive::new).collect(Collectors.toList()));
    }

```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public UniqueTaskList getUniqueTaskList() {
        UniqueTaskList lists = new UniqueTaskList();
        
        for (XmlAdaptedDeadline xmld : deadlines) {
            try {
                lists.add(xmld.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        for (XmlAdaptedEvent xmle : events) {
            try {
                lists.add(xmle.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        for (XmlAdaptedTask xmlt : floatingTasks) {
            try {
                lists.add(xmlt.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        lists.getInternalList().sort(comparator);
        return lists;
    }

```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public UniqueTaskList getUniqueFloatingTaskList() {
        UniqueTaskList lists = new UniqueTaskList();
        
        for (XmlAdaptedTask xmlt : floatingTasks) {
            try {
                lists.add(xmlt.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        return lists;
    }

```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public UniqueTaskList getUniqueEventList() {
        UniqueTaskList lists = new UniqueTaskList();
        for (XmlAdaptedEvent xmle : events) {
            try {
                lists.add(xmle.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        return lists;
    }

```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public UniqueTaskList getUniqueDeadlineList() {
        UniqueTaskList lists = new UniqueTaskList();
        for (XmlAdaptedDeadline xmld : deadlines) {
            try {
                lists.add(xmld.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        return lists;
    }
    
```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public ArchiveTaskList getUniqueArchiveList() {
        ArchiveTaskList lists = new ArchiveTaskList();
        for (XmlAdaptedArchive p : archives) {
            try {
                lists.add(p.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        return lists;
    }
    
    @Override
    public UniqueTagList getUniqueTagList() {
        try {
            return new UniqueTagList(tags);
        } catch (UniqueTagList.DuplicateTagException e) {
            e.printStackTrace();
            return null;
        }
    }

```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getTaskList() {
        List<ReadOnlyTask> tasks = getFloatingTaskList();
        List<ReadOnlyTask> event = getEventList();
        List<ReadOnlyTask> deadline = getDeadlineList();

        tasks.addAll(event);
        tasks.addAll(deadline);
        
        return tasks;
    }
    
```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getFloatingTaskList() {
        return floatingTasks.stream().map(p -> {
            try {
                return p.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                return null;
            }
        }).collect(Collectors.toCollection(ArrayList::new));
    }
    
```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getEventList() {
        return events.stream().map(p -> {
            try {
                return p.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                return null;
            }
        }).collect(Collectors.toCollection(ArrayList::new));
    }
    
```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getDeadlineList() {
        return deadlines.stream().map(p -> {
            try {
                return p.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                return null;
            }
        }).collect(Collectors.toCollection(ArrayList::new));
    }
    
```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getArchiveList() {
        return archives.stream().map(p -> {
            try {
                return p.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                return null;
            }
        }).collect(Collectors.toCollection(ArrayList::new));
    }

```
###### /java/harmony/mastermind/storage/XmlAdaptedEvent.java
``` java
/**
 * JAXB-friendly version of the event type Task.
 */
public class XmlAdaptedEvent {

    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private Date startDate;
    @XmlElement(required = true)
    private Date endDate;
    @XmlElement(required = true)
    private String recur;
    @XmlElement(required = true)
    private Date createdDate;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedEvent() {}


    /**
     * Converts a given event into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedEvent
     */
    public XmlAdaptedEvent(ReadOnlyTask source) {
        name = source.getName();
        startDate = source.getStartDate();
        endDate = source.getEndDate();
        recur = source.getRecur();
        createdDate = source.getCreatedDate();

        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted event object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted event
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        
        final String name = this.name;
        final Date startDate = this.startDate;
        final Date endDate = this.endDate;
        final String recur = this.recur;
        final Date createdDate = this.createdDate;
        final UniqueTagList tags = new UniqueTagList(taskTags);
        
        return new Task(name, startDate, endDate, tags, recur, createdDate);
    }
}
```
###### /java/harmony/mastermind/logic/LogicManager.java
``` java
    public CommandResult execute(String commandText) {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText);
        command.setData(model, storage);
        CommandResult result = command.execute();
        return result;
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }
    
    @Override
    public ObservableList<ReadOnlyTask> getFilteredFloatingTaskList() {
        return model.getFilteredFloatingTaskList();
    }
    
    @Override
    public ObservableList<ReadOnlyTask> getFilteredEventList() {
        return model.getFilteredEventList();
    }
    
    @Override
    public ObservableList<ReadOnlyTask> getFilteredDeadlineList() {
        return model.getFilteredDeadlineList();
    }
    
    @Override
    public ObservableList<ReadOnlyTask> getFilteredArchiveList() {
        return model.getFilteredArchiveList();
    }

```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the mark task command. <br>
     * 
     * @return the prepared mark command
     */
    private Command prepareMark(String args) {
        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            if (args.trim().equals("due")) {
                return new MarkCommand(args.trim());
            }
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }
        return new MarkCommand(index.get());
    }

```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the list task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareList(String args) {
        Optional<String> type = parseTab(args.toLowerCase());
        if (type.isPresent()) {
            if (type.get().equals("empty")) {
                return new ListCommand();
            } else {
                return new ListCommand(type);
            }
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        }
    }


```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the unmark task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareUnmark(String args) {
        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
        }
        return new UnmarkCommand(index.get());
    }
    
```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    /**
     * Returns the specified Tab name in the {@code ListCommand}
     * IF a correct Tab name is given. 
     * Returns an {@code Optional.empty()} otherwise.
     */
    private Optional<String> parseTab(String command) {
        if (command.isEmpty()) {
            return Optional.of("empty");
        }
        
        final Matcher matcher = TAB_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String type = matcher.group("tab").toLowerCase();

        return Optional.of(type);

    }

```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the upcoming task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareUpcoming(String args) {

        Optional<String> taskType = parseUpcoming(args);
        
        if (taskType.isPresent()) {
            return new UpcomingCommand(taskType.get());
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpcomingCommand.MESSAGE_USAGE));
        }
        
    }
    
```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    /**
     * Returns the specified arguments for {@code UpcomingCommand}
     * IF a correct arguments is given.
     */
    private Optional<String> parseUpcoming(String command) {
        if (command.isEmpty()) {
            return Optional.of("empty");
        }
        
        final Matcher matcher = UpcomingCommand.COMMAND_ARGUMENTS_PATTERN.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String type = matcher.group("taskType").toLowerCase();

        return Optional.of(type);

    }

    /**
     * Parses arguments in the context of the find tag command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareFindTag(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");

        final Set<Tag> tagSet = new HashSet<>();

        try {

            for (String tagName : keywords) {
                tagSet.add(new Tag(tagName));
            }

            return new FindTagCommand(tagSet);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
    
```
###### /java/harmony/mastermind/logic/Logic.java
``` java
/**
 * API of the Logic component
 */
public interface Logic {
    /**
     * Executes the command and returns the result.
     * @param commandText The command as entered by the user.
     * @return the result of the command execution.
     */
    CommandResult execute(String commandText);

    /** Returns the filtered list of tasks */
    ObservableList<ReadOnlyTask> getFilteredTaskList();

    /** Returns the filtered list of floating tasks*/
    ObservableList<ReadOnlyTask> getFilteredFloatingTaskList();

    /** Returns the filtered list of events*/
    ObservableList<ReadOnlyTask> getFilteredEventList();

    /** Returns the filtered list of deadlines*/
    ObservableList<ReadOnlyTask> getFilteredDeadlineList();

    /** Returns the filtered list of archived tasks*/
    ObservableList<ReadOnlyTask> getFilteredArchiveList();
    

}
```
###### /java/harmony/mastermind/logic/commands/MarkCommand.java
``` java
/**
 * marks a task as complete and moves it to the archives tab
 */
public class MarkCommand extends Command implements Undoable, Redoable {

    public static final String COMMAND_WORD = "mark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
                                               + ": mark a task as done "
                                               + "Parameters: INDEX (must be a positive integer)\n"
                                               + "Example: "
                                               + COMMAND_WORD
                                               + " 1";

    public static final String COMMAND_FORMAT = COMMAND_WORD + " <index>";
    public static final String COMMAND_DESCRIPTION = "Marking a task as done";

    public static final String MESSAGE_MARK_SUCCESS = "%1$s has been archived";
    public static final String MESSAGE_MARK_DUE_SUCCESS = "All Tasks that are due has been archived";
    public static final String MESSAGE_MARK_FAILURE = "Selected is already marked";
    public static final String MESSAGE_MARK_RECURRING_FAILURE = "Unable to add recurring Task";
    public static final String MESSAGE_UNDO_SUCCESS = "[Undo Mark Command] %1$s has been unmarked";
    public static final String MESSAGE_REDO_SUCCESS = "[Redo Mark Command] %1$s has been archived";

    private int targetIndex;
    private String type;
    private ArrayList<Task> tasksToMark;

    public MarkCommand(int targetIndex) {
        this.targetIndex = targetIndex;
        this.type = "empty";
        tasksToMark = new ArrayList<Task>();
    }
    
    public MarkCommand(String taskType) {
        this.type = taskType;
        tasksToMark = new ArrayList<Task>();
    }

    @Override
    public CommandResult execute() {
        try {
            if (this.model.getCurrentTab().equals(ModelManager.TAB_ARCHIVES)) {
                return new CommandResult(COMMAND_WORD, MarkCommand.MESSAGE_MARK_FAILURE);
            }
            
            executeMark();

            model.pushToUndoHistory(this);
            model.clearRedoHistory();

            if (type.equals("due")) {
                return new CommandResult(COMMAND_WORD, MESSAGE_MARK_DUE_SUCCESS);
            } else {
                return new CommandResult(COMMAND_WORD, String.format(MESSAGE_MARK_SUCCESS, tasksToMark.get(0)));
            }
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(COMMAND_WORD,Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_WORD,MESSAGE_MARK_RECURRING_FAILURE);
        } catch (NotRecurringTaskException e) {
            return new CommandResult(COMMAND_WORD,MESSAGE_MARK_RECURRING_FAILURE);
        }

    }

```
###### /java/harmony/mastermind/logic/commands/MarkCommand.java
``` java
    private void executeMark() throws TaskNotFoundException, DuplicateTaskException, NotRecurringTaskException {
        ObservableList<Task> lastShownList = model.getListToMark();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new TaskNotFoundException();
        }

        if (type.equals("empty")) {
            tasksToMark.add(lastShownList.get(targetIndex - 1));
            Task taskToMark = tasksToMark.get(0); 
            model.markTask(taskToMark);
            if (taskToMark.isRecur()) {
                model.addNextTask(taskToMark);
            }
        } else if (type.equals("due")){
            model.updateFilteredListToShowUpcoming(new Date().getTime(),type);
            lastShownList = model.getListToMark();
            for (Task task: lastShownList) {
                tasksToMark.add(task);
            }
            
            model.markDue(tasksToMark);
        }
        

    }
}
```
###### /java/harmony/mastermind/logic/commands/FindTagCommand.java
``` java
/**
 * Finds and lists all tasks in task manager whose tag contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */

public class FindTagCommand extends Command {

    public static final String COMMAND_WORD = "findtag";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ":\n" + "Finds all tasks whose tags contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n\t"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n\t"
            + "Example: " + COMMAND_WORD + " meal finals";
    
    public static final String COMMAND_FORMAT = COMMAND_WORD + " <keywords>...";
    public static final String COMMAND_DESCRIPTION = "Finds all tasks whose tags contain any of the specified keywords " 
            + "(case-sensitive)";

    private final Set<Tag> keywords;

    public FindTagCommand(Set<Tag> keywords) throws IllegalValueException {
        
        this.keywords = keywords;
    }

    /**
     * Returns copy of keywords in this command.
     */
    public Set<Tag> getKeywords() {
        return new HashSet<>(keywords);
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTagTaskList(keywords);
        return new CommandResult(COMMAND_WORD, getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### /java/harmony/mastermind/logic/commands/ListCommand.java
``` java
    public ListCommand() {
        tab = ModelManager.TAB_HOME.toLowerCase();
    }
    
    public ListCommand(Optional<String> args) {
        tab = args.get();
    }

    @Override
    public CommandResult execute() {
        assert tab != null;
        
        CommandResult cResult = null;
        String tabToShow = null;
        
        
        if (tab.equals(ModelManager.TAB_TASKS.toLowerCase())) {
            tabToShow = ModelManager.TAB_TASKS;
            cResult = new CommandResult(COMMAND_WORD, MESSAGE_SUCCESS_TASKS);
        } else if (tab.equals(ModelManager.TAB_EVENTS.toLowerCase())) {
            tabToShow = ModelManager.TAB_EVENTS;
            cResult = new CommandResult(COMMAND_WORD, MESSAGE_SUCCESS_EVENTS);
        } else if (tab.equals(ModelManager.TAB_DEADLINES.toLowerCase())) {
            tabToShow = ModelManager.TAB_DEADLINES;
            cResult = new CommandResult(COMMAND_WORD, MESSAGE_SUCCESS_DEADLINES);
        } else if (tab.equals(ModelManager.TAB_ARCHIVES.toLowerCase())) {
            tabToShow = ModelManager.TAB_ARCHIVES;
            cResult = new CommandResult(COMMAND_WORD, MESSAGE_SUCCESS_ARCHIVES);
        } else if (tab.equals(ModelManager.TAB_HOME.toLowerCase())){
            tabToShow = ModelManager.TAB_HOME;
            cResult =  new CommandResult(COMMAND_WORD, MESSAGE_SUCCESS);
        }
        
        model.updateFilteredListToShow(tabToShow);
        
        return cResult;
    }

    //@author A0143378Y
    /*
     * Clears all main window text
     */
    public static void displayClear() {
        detailedView = null;
    }

    //@author A0143378Y
    /*
     * Displays an individual GenericMemory item with all non-null details
     */
    public static String displayDetailed(GenericMemory item) {
        displayClear();
        detailedView = item;

        assert detailedView != null;

        return formatItem(item);
    }

    //@author A0143378Y
    /*
     * Formats the item display
     */
    private static String formatItem(GenericMemory item) {
        String result = ITEM_VIEW + "\n" + LINE + "\n" + item + "\n" + LINE2;
        return result;
    }

    //@author A0143378Y
    /*
     * Takes an ArrayList of GenericMemoryitems, and display them in a list form, with name as the heading
     */
    public static String displayList(ArrayList<GenericMemory> list, String name) {
        displayClear();
        detailedView = null;
        listName = name;

        assert listName != null;

        return formatList(list);
    }

    //@author A0143378Y
    /*
     * Formats the list display
     */ 
    private static String formatList(ArrayList<GenericMemory> list) {
        String result = listName + "\n" + LINE;
        for (int i=0; i < list.size(); i++) {
            String line = i + 1 + BRACKET_OPEN;
            line += BRACKET_CLOSE + list.get(i).getName();

            result = result + "\n" + line;
        }
        
        result = result + "\n" + LINE2;
        return result;
    }

    //@author A0143378Y
    /*
     * Displays list of item with the corresponding type
     */
    public static void displayType(ArrayList<GenericMemory> list, String type) {
        assert type.length() != 0;

        if (list.size() > 1) { // if list contains multiple items, show as list
            displayList(list, DISPLAY_ITEM_TYPE + type);
        } else if (list.size() == 1){ // if only one item, show item
            displayDetailed(list.get(0));
        }
    }
}
```
###### /java/harmony/mastermind/logic/commands/UpcomingCommand.java
``` java
/**
 * Lists all upcoming tasks in the task manager to the user.
 */
public class UpcomingCommand extends Command {

    public static final String COMMAND_WORD = "upcoming";

    public static final String MESSAGE_USAGE = COMMAND_WORD
                                               + ": List upcoming deadlines and events.\n"
                                               + "Parameters: TASKTYPE (Optional)\n"
                                               + "Example: \n"
                                               + COMMAND_WORD + "\n"
                                               + COMMAND_WORD + " events\n"
                                               + COMMAND_WORD + " deadlines";
    
    public static final String COMMAND_FORMAT = COMMAND_WORD + "[tab_name]";
    public static final String COMMAND_DESCRIPTION = "List tasks due in the week";

            
    public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile("(?<taskType>deadlines|events)");

    public final String TIME_TODAY = "today 2359";

    public static final String MESSAGE_SUCCESS_UPCOMING = "Listed all upcoming tasks";
    public static final String MESSAGE_SUCCESS_UPCOMING_DEADLINE = "Listed all upcoming deadlines";
    public static final String MESSAGE_SUCCESS_UPCOMING_EVENT = "Listed all upcoming events";
    public static final String COMMAND_SUMMARY = "Upcoming tasks: \n" + COMMAND_WORD;
    
    private String taskType;
    
    public UpcomingCommand() {}
    
    public UpcomingCommand(String type) {
        this.taskType = type;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredListToShowUpcoming(prettyTimeParser.parse(TIME_TODAY).get(0).getTime(), taskType);
        
        switch (taskType) {
            case "deadlines" :
                return new CommandResult(COMMAND_WORD, MESSAGE_SUCCESS_UPCOMING_DEADLINE);
            case "events" :
                return new CommandResult(COMMAND_WORD, MESSAGE_SUCCESS_UPCOMING_EVENT);
            default :
                return new CommandResult(COMMAND_WORD, MESSAGE_SUCCESS_UPCOMING);
        }
    }
    

}
```
###### /java/harmony/mastermind/logic/commands/ImportCommand.java
``` java
    public ImportCommand(String filePath, String extension) {
        this.fileToImport = filePath.trim();
        this.extension = extension;
        lstOfCmd = new ArrayList<String>();
    }

    @Override
    public CommandResult execute() {
        assert fileToImport != null;
        assert lstOfCmd != null;
        
        CommandResult result = null;
        
        switch (extension) {
            case EXT_ICS:
                result = importIcsFile();
                break;
            case EXT_CSV:
                result = importCsvFile();
                break;
        }
        return result;
        
    }
    
    /** gets the list of commands for adding tasks */
    public ArrayList<String> getTaskToAdd() {
        return this.lstOfCmd;
    }
    
    private CommandResult importCsvFile() {
        int currLine = 0;
        int errCount = 0;
        String errLines = "";
        try {
            Iterable<CSVRecord> records = CSVFormat.RFC4180
                    .withHeader(HEADER_NAME, HEADER_START_DATE, HEADER_START_TIME, HEADER_END_DATE, HEADER_END_TIME)
                    .parse(new FileReader(fileToImport));
            
            boolean isTask = false;
            for (CSVRecord record : records) {
                if (isTask) {
                    currLine++;
                    try {
                        Optional<Task> taskToAdd = parseCsvRecord(record);
                        if (taskToAdd.isPresent()) {
                            model.addTask(taskToAdd.get());
                        } else {
                            errCount++;
                            errLines += Integer.toString(currLine) + ","; 
                        }
                    } catch (IllegalValueException | InvalidEventDateException | IllegalArgumentException e) {
                        errCount++;
                        errLines += Integer.toString(currLine) + ","; 
                    }
                    
                } else {
                    currLine++;
                    isTask = true;
                    if (!record.get(INDEX_NAME).equals(HEADER_NAME)) {
                        return new CommandResult(COMMAND_WORD, MESSAGE_CSV_READ_FAILURE);
                    }
                    if (!record.get(INDEX_START_DATE).equals(HEADER_START_DATE)) {
                        return new CommandResult(COMMAND_WORD, MESSAGE_CSV_READ_FAILURE);
                    }
                    if (!record.get(INDEX_START_TIME).equals(HEADER_START_TIME)) {
                        return new CommandResult(COMMAND_WORD, MESSAGE_CSV_READ_FAILURE);
                    }
                    if (!record.get(INDEX_END_DATE).equals(HEADER_END_DATE)) {
                        return new CommandResult(COMMAND_WORD, MESSAGE_CSV_READ_FAILURE);
                    }
                    if (!record.get(INDEX_END_TIME).equals(HEADER_END_TIME)) {
                        return new CommandResult(COMMAND_WORD, MESSAGE_CSV_READ_FAILURE);
                    }
                }
            }
            
        } catch (IOException ioe) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_READ_FAILURE, fileToImport));
        }

        int addCount = currLine - errCount - HEADER_LINE;
        if (errLines.isEmpty()) {
            return new CommandResult(ImportCommand.COMMAND_WORD, String.format(MESSAGE_IMPORT_TXT_SUCCESS, addCount));
        } else {
            errLines = errLines.substring(0,errLines.length()-1);
            return new CommandResult(ImportCommand.COMMAND_WORD, String.format(MESSAGE_IMPORT_TXT_FAILURE, addCount, errLines));
        }
    }
    
    /**
     * reads a csv record and return a Task if its valid else an empty Optional
     * @return Parsed Task object
     * @throws IllegalValueException 
     * @throws InvalidEventDateException 
     */
    private Optional<Task> parseCsvRecord(CSVRecord record) throws IllegalValueException, InvalidEventDateException {
        Optional<String> name;
        Optional<String> startDate;
        Optional<String> endDate;
        
        if (record.get(HEADER_NAME).equals(EMPTY_ARG)) {
            return Optional.empty();
        } else {
            name = Optional.ofNullable(record.get(HEADER_NAME));
        }

        if (record.get(HEADER_START_DATE).equals(EMPTY_ARG)) {
            startDate = Optional.empty();
        } else if (record.get(HEADER_START_TIME).equals(EMPTY_ARG)) {
            return Optional.empty();
        } else {
            startDate = Optional.ofNullable(record.get(HEADER_START_DATE) + " " + record.get(HEADER_START_TIME));
        }
        if (record.get(HEADER_END_DATE).equals(EMPTY_ARG)) {
            endDate = Optional.empty();
        } else if (record.get(HEADER_END_TIME).equals(EMPTY_ARG)) {
            return Optional.empty();            
        } else {
            endDate = Optional.ofNullable(record.get(HEADER_END_DATE) + " " + record.get(HEADER_END_TIME));
        }
        if (startDate.isPresent() && !endDate.isPresent()) {
            return Optional.empty();
        }
        
        
        Set<String> tags = new HashSet<String>();
        tags.add("CSVIMPORT");

        TaskBuilder taskBuilder = new TaskBuilder(name.get());
        taskBuilder.withTags(tags);
        
        if (startDate.isPresent() && endDate.isPresent()) {
            taskBuilder.asEvent(prettyTimeParser.parse(startDate.get()).get(0), prettyTimeParser.parse(endDate.get()).get(0));
            return Optional.ofNullable(taskBuilder.build());
        } else if (endDate.isPresent()) {
            taskBuilder.asDeadline(prettyTimeParser.parse(endDate.get()).get(0));
            return Optional.ofNullable(taskBuilder.build());
        } else if (!endDate.isPresent()) {
            taskBuilder.asFloating();
            return Optional.ofNullable(taskBuilder.build());
        } else {
            return Optional.empty();
        }
        
    }
    
```
###### /java/harmony/mastermind/logic/commands/UnmarkCommand.java
``` java
public class UnmarkCommand extends Command implements Undoable, Redoable{
    public static final String COMMAND_WORD = "unmark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
                                               + ": undo marking of task as done"
                                               + "Parameters: INDEX (must be a positive integer)\n"
                                               + "Example: "
                                               + COMMAND_WORD
                                               + " 1";

    public static final String COMMAND_FORMAT = COMMAND_WORD + " <index>";
    public static final String COMMAND_DESCRIPTION = "Unmarking a task as done";

    public static final String MESSAGE_UNMARK_SUCCESS = "%1$s has been unmarked";
    public static final String MESSAGE_DUPLICATE_UNMARK_TASK = "%1$s already exist in not completed list";
    public static final String MESSAGE_UNMARK_FAILURE = "Tasks in current tab has not been marked";

    public static final String MESSAGE_UNDO_SUCCESS = "[Undo Unmark Command] %1$s has been archived";
    public static final String MESSAGE_REDO_SUCCESS = "[Redo Unmark Command] %1$s has been unmarked";

    private final int targetIndex;
    private Task taskToUnmark;

    public UnmarkCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        try {
            if (!this.model.getCurrentTab().equals(ModelManager.TAB_ARCHIVES)) {
                return new CommandResult(COMMAND_WORD, UnmarkCommand.MESSAGE_UNMARK_FAILURE);
            }
            
            executeUnmark();
            
            model.pushToUndoHistory(this);
            
            model.clearRedoHistory();
            
            requestHighlightLastActionedRow(taskToUnmark);

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNMARK_SUCCESS, taskToUnmark));
        } catch (DuplicateTaskException dte) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_DUPLICATE_UNMARK_TASK, taskToUnmark));
        } catch (TaskNotFoundException tnfe) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

```
###### /java/harmony/mastermind/logic/commands/UnmarkCommand.java
``` java
    private void executeUnmark() throws IndexOutOfBoundsException, TaskNotFoundException,
        DuplicateTaskException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredArchiveList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new TaskNotFoundException();
        }
        
        taskToUnmark = (Task) lastShownList.get(targetIndex - 1);
        
        model.unmarkTask(taskToUnmark);
    }
    
}
```
###### /java/harmony/mastermind/ui/CommandBox.java
``` java
    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandField.setText("");
}

    /**
     * Handles any KeyPress in the commandField
     */
    @FXML
    private void handleKeyPressed(KeyEvent event) {
        KeyCode key = event.getCode();
        switch (key) {
            case UP:
                restorePrevCommandText();
                return;
            case DOWN:
                restoreNextCommandText();
                return;
            case ENTER:
                learnWord(commandField.getText());
                return;
        }

        if (CTRL_ONE.match(event)) {
            raise(new NewResultAvailableEvent(ListCommand.COMMAND_WORD, ListCommand.MESSAGE_SUCCESS));
        } else if (CTRL_TWO.match(event)) {
            raise(new NewResultAvailableEvent(ListCommand.COMMAND_WORD, ListCommand.MESSAGE_SUCCESS_TASKS));
        } else if (CTRL_THREE.match(event)) {
            raise(new NewResultAvailableEvent(ListCommand.COMMAND_WORD, ListCommand.MESSAGE_SUCCESS_EVENTS));
        } else if (CTRL_FOUR.match(event)) {
            raise(new NewResultAvailableEvent(ListCommand.COMMAND_WORD, ListCommand.MESSAGE_SUCCESS_DEADLINES));
        } else if (CTRL_FIVE.match(event)) {
            raise(new NewResultAvailableEvent(ListCommand.COMMAND_WORD, ListCommand.MESSAGE_SUCCESS_ARCHIVES));
        }
    }

```
###### /java/harmony/mastermind/ui/CommandBox.java
``` java
    private void restoreCommandText() {
        commandField.setText(currCommandText);
    }

    private void restorePrevCommandText() {
        String prevCommand = getPrevCommandHistory();
        if (prevCommand != null) {
            // need to wrap in runLater due to concurrency threading in JavaFX
            Platform.runLater(new Runnable() {
                public void run() {
                    commandField.setText(prevCommand);
                    commandField.positionCaret(prevCommand.length());
                }
            });
        } // else ignore
    }

    private void restoreNextCommandText() {
        String nextCommand = getNextCommandHistory();
        // need to wrap in runLater due to concurrency threading in JavaFX
        Platform.runLater(new Runnable() {
            public void run() {
                if (nextCommand != null) {
                    commandField.setText(nextCommand);
                    commandField.positionCaret(nextCommand.length());
                } else {
                    commandField.setText("");
                }
            }
        });
}
    
    /**
     * Adds recent input into stack
     */
    private void updateCommandHistory(String command) {
        commandHistory.push(command);
        commandIndex = commandHistory.size();
    }

    private String getPrevCommandHistory() {
        if (commandHistory.empty()) {
            return null;
        } else if (commandIndex == 0) {
            return null;
        } else {
            commandIndex--;
            return commandHistory.get(commandIndex);
        }
    }

    private String getNextCommandHistory() {
        if (commandHistory.empty()) {
            return null;
        } else if (commandIndex >= commandHistory.size() - 1) {
            commandIndex = commandHistory.size();
            return null;
        } else {
            commandIndex++;
            return commandHistory.get(commandIndex);
        }
    }
    
    @Subscribe
    private void handleIncorrectCommand(IncorrectCommandAttemptedEvent event) {
        restoreCommandText();
    }
}
```
###### /java/harmony/mastermind/ui/HomeTableView.java
``` java
    /**
     * Initialize the displaying of tabs
     */
    @FXML
    private void initialize() {
        this.initIndex();
        this.initName();
        this.initStartDate();
        this.initEndDate();
        this.initTags();
        this.initRecur();
    }
```
###### /java/harmony/mastermind/ui/HomeTableView.java
``` java
    /**
     * Initialize a checkbox to determine whether task is recurring
     */
    protected void initRecur() {
        recurColumn.setSortable(false);
        recurColumn.prefWidthProperty().bind(homeTableView.widthProperty().multiply(WIDTH_MULTIPLIER_RECUR));
        recurColumn.setGraphic(new ImageView("file:src/main/resources/images/recur_white.png"));
        recurColumn.setCellValueFactory(task -> new SimpleBooleanProperty(task.getValue().isRecur()));
        recurColumn.setCellFactory(col -> renderRecurCell());
    }
    
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    /**
     * update the number of task in each tab in the tab title
     */
    protected void updateTabTitle() {
        tabLst.get(INDEX_HOME).setText(NAME_TABS[INDEX_HOME]
                                       + "("
                                       + logic.getFilteredTaskList().size()
                                       + ")");
        tabLst.get(INDEX_TASKS).setText(NAME_TABS[INDEX_TASKS]
                                        + "("
                                        + logic.getFilteredFloatingTaskList().size()
                                        + ")");
        tabLst.get(INDEX_EVENTS).setText(NAME_TABS[INDEX_EVENTS]
                                         + "("
                                         + logic.getFilteredEventList().size()
                                         + ")");
        tabLst.get(INDEX_DEADLINES).setText(NAME_TABS[INDEX_DEADLINES]
                                            + "("
                                            + logic.getFilteredDeadlineList().size()
                                            + ")");
        tabLst.get(INDEX_ARCHIVES).setText(NAME_TABS[INDEX_ARCHIVES]
                                           + "("
                                           + logic.getFilteredArchiveList().size()
                                           + ")");
    }

```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    /**
     * handle the switching of tabs when list/upcoming is used
     */
    private void updateTab(String result) {
        switch (result) {
            case ListCommand.MESSAGE_SUCCESS:
                tabPane.getSelectionModel().select(INDEX_HOME);
                break;
            case UpcomingCommand.MESSAGE_SUCCESS_UPCOMING:
            case UpcomingCommand.MESSAGE_SUCCESS_UPCOMING_DEADLINE:
            case UpcomingCommand.MESSAGE_SUCCESS_UPCOMING_EVENT:
                tabPane.getSelectionModel().select(INDEX_HOME);
                break;
            case ListCommand.MESSAGE_SUCCESS_TASKS:
                tabPane.getSelectionModel().select(INDEX_TASKS);
                break;
            case ListCommand.MESSAGE_SUCCESS_EVENTS:
                tabPane.getSelectionModel().select(INDEX_EVENTS);
                break;
            case ListCommand.MESSAGE_SUCCESS_DEADLINES:
                tabPane.getSelectionModel().select(INDEX_DEADLINES);
                break;
            case ListCommand.MESSAGE_SUCCESS_ARCHIVES:
                tabPane.getSelectionModel().select(INDEX_ARCHIVES);
                break;
        }
    }
    
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    @Subscribe
    private void handleTaskManagerChanged(TaskManagerChangedEvent event) {
        updateTabTitle();
        logger.info("Update tab title.");
    }
   
}
```
###### /java/harmony/mastermind/ui/DefaultTableView.java
``` java
    protected TableCell<ReadOnlyTask, Boolean> renderRecurCell() {
        return new TableCell<ReadOnlyTask, Boolean>() {

            @Override
            public void updateItem(Boolean isRecur, boolean isEmpty) {
                super.updateItem(isRecur, isEmpty);
                if (!isEmpty()) {
                    CheckBox box = new CheckBox();
                    box.setSelected(isRecur);
                    box.setDisable(true);
                    box.setStyle("-fx-opacity: 1");

                    this.setAlignment(Pos.CENTER);
                    this.setGraphic(box);
                } else {
                    this.setGraphic(null);
                    ;
                }
            }
        };
    }

```
