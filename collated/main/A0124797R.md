# A0124797R
###### /java/harmony/mastermind/commons/exceptions/NotRecurringTaskException.java
``` java
    public NotRecurringTaskException() {
        super("Task is not a recurring Task");
    }

}
```
###### /java/harmony/mastermind/logic/commands/AddCommand.java
``` java
    public AddCommand(String name, String startDate, String endDate, Set<String> tags, String recurVal) throws IllegalValueException, InvalidEventDateException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        Date startTime = prettyTimeParser.parse(startDate).get(0);
        Date endTime = prettyTimeParser.parse(endDate).get(0);
        
        if (startTime.after(endTime)) {
            throw new InvalidEventDateException();
        }

        this.toAdd = new Task(name, startTime, endTime, new UniqueTagList(tagSet), recurVal);

    }

    // deadline
```
###### /java/harmony/mastermind/logic/commands/MarkCommand.java
``` java
public class MarkCommand extends Command implements Undoable, Redoable {

    public static final String COMMAND_WORD = "mark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
                                               + ": mark a task as done "
                                               + "Parameters: INDEX (must be a positive integer)\n"
                                               + "Example: "
                                               + COMMAND_WORD
                                               + " 1";

    public static final String COMMAND_SUMMARY = "Marking a task as done:"
                                                 + "\n"
                                                 + COMMAND_WORD
                                                 + " INDEX";

    public static final String MESSAGE_SUCCESS = "%1$s has been archived";
    public static final String MESSAGE_MARKED_TASK = "%1$s is already marked";
    public static final String MESSAGE_MARK_RECURRING_FAILURE = "Unable to add recurring Task";

    public static final String MESSAGE_UNDO_SUCCESS = "[Undo Mark Command] %1$s has been unmarked";
    public static final String MESSAGE_REDO_SUCCESS = "[Redo Mark Command] %1$s has been archived";

    public final int targetIndex;

    public Task taskToMark;

    public MarkCommand(int targetIndex, String currentTab) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        try {
            executeMark();
            model.pushToUndoHistory(this);
            model.clearRedoHistory();

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_SUCCESS, taskToMark));
        } catch (TaskAlreadyMarkedException ex) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_MARKED_TASK, taskToMark));
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(COMMAND_WORD,Messages.MESSAGE_TASK_NOT_IN_MASTERMIND);
        } catch (DuplicateTaskException e) {
            return new CommandResult(COMMAND_WORD,MESSAGE_MARK_RECURRING_FAILURE);
        } catch (NotRecurringTaskException e) {
            return new CommandResult(COMMAND_WORD,MESSAGE_MARK_RECURRING_FAILURE);
        }

    }

    @Override
```
###### /java/harmony/mastermind/logic/commands/MarkCommand.java
``` java
    private void executeMark() throws TaskAlreadyMarkedException, IndexOutOfBoundsException, TaskNotFoundException, DuplicateTaskException, NotRecurringTaskException {
        ObservableList<Task> lastShownList = model.getListToMark();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new IndexOutOfBoundsException();
        }
        
        taskToMark = lastShownList.get(targetIndex - 1);

        if (taskToMark.isMarked()) {
            throw new TaskAlreadyMarkedException();
        }

        model.markTask(taskToMark);
        if (taskToMark.isRecur()) {
            model.addNextTask(taskToMark);
        }

    }
}
```
###### /java/harmony/mastermind/logic/commands/UnmarkCommand.java
``` java
public class UnmarkCommand extends Command implements Undoable, Redoable{
    public static final String COMMAND_WORD = "unmark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
                                               + ": undo marking of task as done"
                                               + "Parameters: INDEX (must be a positive integer)\n"
                                               + "Example: "
                                               + COMMAND_WORD
                                               + " 1";

    public static final String COMMAND_SUMMARY = "marks a task as not complete:"
                                                 + "\n"
                                                 + COMMAND_WORD
                                                 + " INDEX";

    public static final String MESSAGE_UNMARK_TASK_SUCCESS = "%1$s has been unmarked";
    public static final String MESSAGE_DUPLICATE_UNMARK_TASK = "%1$s already exist in not completed list";
    public static final String MESSAGE_UNMARK_TASK_FAILURE = "Tasks in current tab has not been marked";

    public static final String MESSAGE_UNDO_SUCCESS = "[Undo Unmark Command] %1$s has been archived";
    public static final String MESSAGE_REDO_SUCCESS = "[Redo Unmark Command] %1$s has been unmarked";

    public final int targetIndex;

    Task taskToUnmark;

    public UnmarkCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        try {
            executeUnmark();
            
            model.pushToUndoHistory(this);
            
            model.clearRedoHistory();

            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNMARK_TASK_SUCCESS, taskToUnmark));
        } catch (TaskAlreadyUnmarkedException tau) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_UNMARK_TASK_FAILURE, taskToUnmark));
        } catch (DuplicateTaskException dte) {
            return new CommandResult(COMMAND_WORD, String.format(MESSAGE_DUPLICATE_UNMARK_TASK, taskToUnmark));
        } catch (TaskNotFoundException tnfe) {
            return new CommandResult(COMMAND_WORD, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

    @Override
```
###### /java/harmony/mastermind/logic/commands/UnmarkCommand.java
``` java
    private void executeUnmark() throws IndexOutOfBoundsException, TaskNotFoundException,
        TaskAlreadyUnmarkedException, DuplicateTaskException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredArchiveList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new TaskNotFoundException();
        }
        
        taskToUnmark = (Task) lastShownList.get(targetIndex - 1);
        
        if (!taskToUnmark.isMarked()) {
            throw new TaskAlreadyUnmarkedException();
        }
        
        model.unmarkTask(taskToUnmark);
    }
}
```
###### /java/harmony/mastermind/logic/Logic.java
``` java
    /** Returns the filtered list of floating tasks*/
    ObservableList<ReadOnlyTask> getFilteredFloatingTaskList();

```
###### /java/harmony/mastermind/logic/Logic.java
``` java
    /** Returns the filtered list of events*/
    ObservableList<ReadOnlyTask> getFilteredEventList();

```
###### /java/harmony/mastermind/logic/Logic.java
``` java
    /** Returns the filtered list of deadlines*/
    ObservableList<ReadOnlyTask> getFilteredDeadlineList();

```
###### /java/harmony/mastermind/logic/Logic.java
``` java
    /** Returns the filtered list of archived tasks*/
    ObservableList<ReadOnlyTask> getFilteredArchiveList();
    

}
```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    private Command prepareMark(String args, String currentTab) {

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }
        return new MarkCommand(index.get(), currentTab);
    }
    
    /**
     * Parses arguments in the context of the list task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    private Command prepareList(String args) {
        Optional<String> type = parseType(args);
        if (!type.isPresent()) {
            return new ListCommand();
        }else {
            if (type.get().equals(ModelManager.TAB_TASKS.toLowerCase()) ||
                    type.get().equals(ModelManager.TAB_EVENTS.toLowerCase()) || 
                    type.get().equals(ModelManager.TAB_DEADLINES.toLowerCase()) ||
                    type.get().equals(ModelManager.TAB_ARCHIVES.toLowerCase())) {
                return new ListCommand(type);
            }else {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
            }
        }
    }

    /**
     * Parses arguments in the context of the unmark task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
```
###### /java/harmony/mastermind/logic/parser/Parser.java
``` java
    private Command prepareUnmark(String args, String currentTab) {
        if (!currentTab.equals(TAB_ARCHIVES)) {
            return new IncorrectCommand(UnmarkCommand.MESSAGE_UNMARK_TASK_FAILURE);
        }

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
        }
        return new UnmarkCommand(index.get());
    }
    
    /**
     * Returns the specified index in the {@code command} IF a positive unsigned
     * integer is given as the index. Returns an {@code Optional.empty()}
     * otherwise.
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }
    
    /**
     * checks if have the type to list archive
     */
    private Optional<String> parseType(String command) {
        final Matcher matcher = TASK_ARCHIVE_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String type = matcher.group("type").toLowerCase();

        return Optional.of(type);

    }

    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

    /**
     * Parses arguments in the context of the find tag command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareFindTag(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");

        final Set<Tag> tagSet = new HashSet<>();

        try {

            for (String tagName : keywords) {
                tagSet.add(new Tag(tagName));
            }

            return new FindTagCommand(tagSet);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

}
```
###### /java/harmony/mastermind/model/Model.java
``` java
    void deleteArchive(ReadOnlyTask target) throws TaskNotFoundException, ArchiveTaskList.TaskNotFoundException;

    /** Adds the given task */
    void addTask(Task task) throws UniqueTaskList.DuplicateTaskException;
    
    /** Add the next recurring task */
```
###### /java/harmony/mastermind/model/Model.java
``` java
    void addNextTask(Task task) throws UniqueTaskList.DuplicateTaskException, NotRecurringTaskException;

    /** Marks the given task as done */
```
###### /java/harmony/mastermind/model/Model.java
``` java
    void markTask(Task target) throws UniqueTaskList.TaskNotFoundException;
    
    /** Updates the completed task as not done */
```
###### /java/harmony/mastermind/model/Model.java
``` java
    void unmarkTask(Task target) throws UniqueTaskList.DuplicateTaskException,
    ArchiveTaskList.TaskNotFoundException;
    
```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Returns the current list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getCurrentList();

    /** push the command to redo history */
    void pushToRedoHistory(Redoable command);
    
    /** undo last action performed, throws EmptyStackException is there's no more action can be undone **/
    CommandResult redo() throws EmptyStackException;
    
    /** empty redoHistory **/
    // required when a new command is entered, model should throw away all remaining commands in the redo history
    void clearRedoHistory();
    
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();
    
```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Returns the filtered floating task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredFloatingTaskList();
    
```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Returns the filtered event list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredEventList();
    
```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Returns the filtered deadline list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredDeadlineList();
    
```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Returns the filtered archive list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredArchiveList();

```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Returns filtered task list as an {@code ObervableList<Task>} */
    ObservableList<Task> getListToMark();

```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** update current tab */
    void updateCurrentTab(String tab);

    /** Updates the filter of the filtered task list for current tab to show all tasks */
    void updateFilteredListToShowAll();
    
```
###### /java/harmony/mastermind/model/Model.java
``` java
    /** Updates the filter of the filtered task list 
     * for Home tab to show all upcoming tasks */
    void updateFilteredListToShowUpcoming(long time);
    
    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskList(Set<String> keywords);

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTagTaskList(Set<Tag> keywords);
    
    /** Search */
    void searchTask(String input);

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public ModelManager(ReadOnlyTaskManager initialData, UserPrefs userPrefs) {
        taskManager = new TaskManager(initialData);
        filteredTasks = new FilteredList<>(taskManager.getTasks());
        filteredFloatingTasks = new FilteredList<>(taskManager.getFloatingTasks());
        filteredEvents = new FilteredList<>(taskManager.getEvents());
        filteredDeadlines = new FilteredList<>(taskManager.getDeadlines());
        filteredArchives = new FilteredList<>(taskManager.getArchives());
        undoHistory = new Stack<>();
        redoHistory = new Stack<>();
        commandHistory = new Stack<String>();
        indicateTaskManagerChanged();
    }

    @Override
    public void resetData(ReadOnlyTaskManager newData) {
        taskManager.resetData(newData);
        clearUndoHistory();
        clearRedoHistory();
        indicateTaskManagerChanged();
    }

    @Override
    public ReadOnlyTaskManager getTaskManager() {
        return taskManager;
    }

    /** Raises an event to indicate the model has changed */
    private void indicateTaskManagerChanged() {
        raise(new TaskManagerChangedEvent(taskManager));
    }
    
    @Override
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public void updateCurrentTab(String tab) {
        this.currentTab = tab;
    }
    
    @Override
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public synchronized void markTask(Task target) throws TaskNotFoundException {
        taskManager.markTask(target);
        indicateTaskManagerChanged();
    }
    
    @Override
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public synchronized void unmarkTask(Task target) throws ArchiveTaskList.TaskNotFoundException,
    UniqueTaskList.DuplicateTaskException {
        taskManager.unmarkTask(target);
        indicateTaskManagerChanged();
    }
    
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredFloatingTaskList() {
        return new UnmodifiableObservableList<>(taskManager.getFloatingTasks());
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredEventList() {
        return new UnmodifiableObservableList<>(taskManager.getEvents());
    }

```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredDeadlineList() {
        return new UnmodifiableObservableList<>(taskManager.getDeadlines());
    }
    
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredArchiveList() {
        return new UnmodifiableObservableList<>(taskManager.getArchives());
    }
    
    //=========== Methods for Recurring Tasks===============================================================

    @Override
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public synchronized void addNextTask(Task task) throws UniqueTaskList.DuplicateTaskException, NotRecurringTaskException {
        taskManager.addNextTask(task);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    //=========== Filtered Task List Accessors ===============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }
    
    @Override
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public ObservableList<Task> getListToMark() {
        return getCurrentObservableList();
    }

    @Override
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public void updateFilteredListToShowAll() {
        switch (currentTab) {
            case TAB_HOME:      filteredTasks.setPredicate(null);
                                break;
            case TAB_TASKS:     filteredFloatingTasks.setPredicate(null);
                                break;
            case TAB_EVENTS:    filteredEvents.setPredicate(null);
                                break;
            case TAB_DEADLINES: filteredDeadlines.setPredicate(null);
                                break;
            case TAB_ARCHIVES:  filteredArchives.setPredicate(null);
                                break;
        }
    }
    
    @Override
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public void updateFilteredListToShowUpcoming(long time) {
        updateFilteredTaskList(new PredicateExpression(new DateQualifier(time)));
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords){
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
    }

    @Override
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public void updateFilteredTagTaskList(Set<Tag> keywords){
        updateFilteredTaskList(new PredicateExpression(new TagQualifier(keywords)));
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }
    
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    private ObservableList<Task> getCurrentObservableList() {
        ObservableList<Task> list = filteredTasks;
        
        switch (currentTab) {
            case "Home":        list = filteredTasks;
                                break;
            case "Tasks":       list = filteredFloatingTasks;
                                break;
            case "Events":      list = filteredEvents;
                                break;
            case "Deadlines":   list = filteredDeadlines;
                                break;
            case "Archives":    list = filteredArchives;
                                break;
        }
        
        return list;
    }
    
    @Override
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    public UnmodifiableObservableList<ReadOnlyTask> getCurrentList() {
        return new UnmodifiableObservableList<ReadOnlyTask>(getCurrentObservableList());
    }
    
    private void searchTask(String keyword, Memory memory) { 
        taskManager.searchTask(keyword, memory);
    }

    //========== Inner classes/interfaces used for filtering ==================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);
        String toString();
    }

    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsIgnoreCase(task.getName(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }
    
```
###### /java/harmony/mastermind/model/ModelManager.java
``` java
    private class TagQualifier implements Qualifier {
        private Set<Tag> tagKeyWords;

        TagQualifier(Set<Tag> tagKeyWords) {
            this.tagKeyWords = tagKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            final Set<Tag> tagList = task.getTags().toSet();
            
            return !Collections.disjoint(tagList, tagKeyWords);
        }

        @Override
        public String toString() {
            return "tags=" + String.join(", ", tagKeyWords.toString());
        }
    }
    
    private class DateQualifier implements Qualifier {
        private long oneWeekFromNow;
        private final long oneWeek = 604800000;

        DateQualifier(long time) {
            this.oneWeekFromNow = time + oneWeek ;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.isFloating()) {
                return true;
            }else{
                return task.getEndDate().getTime() < oneWeekFromNow;
            }
        }

        @Override
        public String toString() {
            return "Date before:" + oneWeekFromNow;
        }
    }

    @Override
    public void searchTask(String input) {
        // implementing next milestone
    }
    


}
```
###### /java/harmony/mastermind/model/ReadOnlyTaskManager.java
``` java
 */
public interface ReadOnlyTaskManager {

    UniqueTagList getUniqueTagList();

    UniqueTaskList getUniqueTaskList();

    UniqueTaskList getUniqueFloatingTaskList();

    UniqueTaskList getUniqueEventList();

    UniqueTaskList getUniqueDeadlineList();
    
    ArchiveTaskList getUniqueArchiveList();

    /**
     * Returns an unmodifiable view of tasks list
     */
    List<ReadOnlyTask> getTaskList();

    /**
     * Returns an unmodifiable view of tasks list
     */
    List<ReadOnlyTask> getFloatingTaskList();

    /**
     * Returns an unmodifiable view of tasks list
     */
    List<ReadOnlyTask> getEventList();

    /**
     * Returns an unmodifiable view of tasks list
     */
    List<ReadOnlyTask> getDeadlineList();
    
    /**
     * Returns an unmodifiable view of archive list
     */
    List<ReadOnlyTask> getArchiveList();

    /**
     * Returns an unmodifiable view of tags list
     */
    List<Tag> getTagList();




}
```
###### /java/harmony/mastermind/model/task/ArchiveTaskList.java
``` java
public class ArchiveTaskList implements Iterable<Task> {

    private final ObservableList<Task> internalList = FXCollections.observableArrayList();


    /**
     * Signals that an operation targeting a specified task in the list would fail because
     * there is no such matching task in the list.
     */
    public static class TaskNotFoundException extends Exception {}
    
    
    /**
     * Constructs empty ArchiveTaskList.
     */
    public ArchiveTaskList() {}

    /**
     * Returns true if the list contains an equivalent task as the given argument.
     */
    public boolean contains(ReadOnlyTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds an archived task to the list.
     */
    public void add(Task toAdd) {
        assert toAdd != null;
        
        internalList.add(toAdd);
    }

    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {
            throw new TaskNotFoundException();
        }
        return taskFoundAndDeleted;
    }

    public ObservableList<Task> getInternalList() {
        return internalList;
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ArchiveTaskList // instanceof handles nulls
                && this.internalList.equals(
                ((ArchiveTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

}
```
###### /java/harmony/mastermind/model/task/ReadOnlyTask.java
``` java
public interface ReadOnlyTask {
    //provide safe read, unmodifiable task object
    final int INDEX_DAY = 0;
    final int INDEX_MONTH = 1;
    final int INDEX_DATE = 2;
    final int INDEX_TIME = 3;
    final int INDEX_YEAR = 5;
    final int INDEX_HOUR = 0;
    final int INDEX_MINUTE = 1;

    public String getName();
    public Date getStartDate();
    public Date getEndDate();
    public UniqueTagList getTags();
    public String getRecur();
    
    public boolean isMarked();
    public boolean isFloating();
    public boolean isDeadline();
    public boolean isEvent();
    public boolean isRecur();
    
    public boolean isDue();
    public boolean isHappening();
    public Duration getDueDuration();
    public Duration getEventDuration();
    
```
###### /java/harmony/mastermind/model/task/ReadOnlyTask.java
``` java
    default boolean isSameTask(ReadOnlyTask task) {
        return this.getName().equals(task.getName());
    }
    
    /**
     * Formats the task as text, showing all task details.
     */
```
###### /java/harmony/mastermind/model/task/ReadOnlyTask.java
``` java
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        
        if (getStartDate() != null) {
            builder.append(" start:" + parseForConsole(getStartDate()));
        }
        
        if (getEndDate() != null) {
            builder.append(" end:" + parseForConsole(getEndDate()));
        }
        
        if (!getTags().toString().isEmpty()) {
            builder.append(" Tags: ")
            .append(getTags().toString());
        }
                
        return builder.toString();
    }
    
    /**
     * Formats the Date as text, showing Task's date.
     */
```
###### /java/harmony/mastermind/model/task/ReadOnlyTask.java
``` java
    default String parse(Date date) {
        String[] dateArr = date.toString().split(" ");
        String[] timeArr = dateArr[INDEX_TIME].split(":");
        final StringBuilder builder = new StringBuilder();
        
        builder.append(dateArr[INDEX_DAY] + " ").append(timeArr[INDEX_HOUR] + ":" + timeArr[INDEX_MINUTE] + " ")
            .append(dateArr[INDEX_DATE] + " ").append(dateArr[INDEX_MONTH] + " ").append(dateArr[INDEX_YEAR]);
        
        return builder.toString();
        
    }
    
    /**
     * Formats the Date as text, showing Task's date.
     */
```
###### /java/harmony/mastermind/model/task/ReadOnlyTask.java
``` java
    default String parseForConsole(Date date) {
        String[] dateArr = date.toString().split(" ");
        String[] timeArr = dateArr[INDEX_TIME].split(":");
        String year = dateArr[INDEX_YEAR].substring(2, 4);
        final StringBuilder builder = new StringBuilder();
        
        builder.append(timeArr[INDEX_HOUR] + ":" + timeArr[INDEX_MINUTE] + "|")
            .append(dateArr[INDEX_DATE]).append(dateArr[INDEX_MONTH]).append(year);
        
        return builder.toString();
        
    }
}
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public String getRecur() {
        return this.recur;
    }
    
    @Override
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isRecur() {
        return recur != null;
    }

    @Override
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    @Override 
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Task // instanceof handles nulls
                && this.toString().equals(((Task) other).toString())); // state check
        
    }
        
    @Override
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public boolean isMarked() {
        return this.marked;
    }

```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public Task mark() {
        this.marked = true;
        return this;
    }
    
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    public Task unmark() {
        this.marked = false;
        return this;
    }
    
```
###### /java/harmony/mastermind/model/task/Task.java
``` java
    @Override
    public String toString() {
        return getAsText();
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public TaskManager(ReadOnlyTaskManager toBeCopied) {
        this(toBeCopied.getUniqueTaskList(), toBeCopied.getUniqueFloatingTaskList(), 
                toBeCopied.getUniqueEventList(), toBeCopied.getUniqueDeadlineList(), 
                toBeCopied.getUniqueTagList(), toBeCopied.getUniqueArchiveList());
    }

    /**
     * Tasks and Tags are copied into this TaskManager
     */
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public TaskManager(UniqueTaskList tasks, UniqueTaskList floatingTasks, UniqueTaskList events, UniqueTaskList deadlines, UniqueTagList tags, ArchiveTaskList archiveTasks) {
        resetData(tasks.getInternalList(), floatingTasks.getInternalList(), events.getInternalList(),
                deadlines.getInternalList(), tags.getInternalList(), archiveTasks.getInternalList());
    }

    public static ReadOnlyTaskManager getEmptyTaskManager() {
        return new TaskManager();
    }

//// list overwrite operations

    public ObservableList<Task> getTasks() {
        return tasks.getInternalList();
    }
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public ObservableList<Task> getFloatingTasks() {
        return floatingTasks.getInternalList();
    }
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public ObservableList<Task> getEvents() {
        return events.getInternalList();
    }
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public ObservableList<Task> getDeadlines() {
        return deadlines.getInternalList();
    }
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public ObservableList<Task> getArchives() {
        return archives.getInternalList();
    }
    
    public void setTasks(List<Task> tasks) {
        this.tasks.getInternalList().setAll(tasks);
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public void setFloatingTasks(List<Task> floatingTasks) {
        this.floatingTasks.getInternalList().setAll(floatingTasks);
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public void setEvents(List<Task> events) {
        this.events.getInternalList().setAll(events);
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public void setDeadlines(List<Task> deadlines) {
        this.deadlines.getInternalList().setAll(deadlines);
    }
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public void setArchiveTasks(Collection<Task> archiveTasks) {
        this.archives.getInternalList().setAll(archiveTasks);
    }

    public void setTags(Collection<Tag> tags) {
        this.tags.getInternalList().setAll(tags);
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public void resetData(Collection<? extends ReadOnlyTask> newTasks, 
            Collection<? extends ReadOnlyTask> newFloatingTasks, 
            Collection<? extends ReadOnlyTask> newEvents,
            Collection<? extends ReadOnlyTask> newDeadlines, 
            Collection<Tag> newTags,
            Collection<? extends ReadOnlyTask> newArchiveTasks) {
        
        setTasks(newTasks.stream().map(Task::new).collect(Collectors.toList()));
        setFloatingTasks(newFloatingTasks.stream().map(Task::new).collect(Collectors.toList()));
        setEvents(newEvents.stream().map(Task::new).collect(Collectors.toList()));
        setDeadlines(newDeadlines.stream().map(Task::new).collect(Collectors.toList()));
        setTags(newTags);
        setArchiveTasks(newArchiveTasks.stream().map(Task::new).map(Task::mark).collect(Collectors.toList()));
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public void resetData(ReadOnlyTaskManager newData) {
        resetData(newData.getTaskList(), newData.getFloatingTaskList(), newData.getEventList(), 
                newData.getDeadlineList(), newData.getTagList(), newData.getArchiveList());
    }



//// task-level operations

    /**
     * Adds a task to the task manager.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task t) throws UniqueTaskList.DuplicateTaskException {
        syncTagsWithMasterList(t);
        tasks.add(t);
        syncAddTask(t);
    }
    
    /**
     * Adds the next recurring task to the task manager.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public void addNextTask(Task t) throws UniqueTaskList.DuplicateTaskException, NotRecurringTaskException {
        syncTagsWithMasterList(t);
        Task newT = getNextTask(t);
        tasks.add(newT);
        syncAddTask(newT);
    }
    
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    /**
     * returns a Task with the next recurring date given a recurring Task
     */
    public Task getNextTask(Task t) throws NotRecurringTaskException {
        if (t.isFloating() || t.getRecur() == null){
            throw new NotRecurringTaskException();
        }
        
        Task newT = null;
        String[] recurVal = t.getRecur().split(" ");
        String nextRecur = getNextRecur(t.getRecur());
        Date nextEndDate = getNextDate(t.getEndDate(),recurVal[0]);
        
        if (t.isDeadline()) {
            newT = new Task(t.getName(), nextEndDate, t.getTags(), nextRecur);
        }else if (t.isEvent()) {
            Date nextStartDate = getNextDate(t.getStartDate(), recurVal[0]);
            newT = new Task(t.getName(), nextStartDate, nextEndDate, t.getTags(), nextRecur);
        }
        
        return newT;
        
    }
    
    /**
    * returns the next date based on the type of recurring task
    */
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    private Date getNextDate(Date d, String recur) {
        Calendar c = Calendar.getInstance();
        c.setTime(d);
        int date;
        switch (recur) {
            case "daily":   date = c.get(Calendar.DATE);
                            c.set(Calendar.DATE, date + 1);
                            break;
            case "weekly":  date = c.get(Calendar.DATE);
                            c.set(Calendar.DATE, date + 7);
                            break;
            case "biweekly":  date = c.get(Calendar.DATE);
                            c.set(Calendar.DATE, date + 14);
                            break;
            case "monthly": date = c.get(Calendar.MONTH);
                            c.set(Calendar.MONTH, date + 1);
                            break;
            case "yearly":  date = c.get(Calendar.YEAR);
                            c.set(Calendar.YEAR, date + 1);
                            break;
        }
        
        return c.getTime();
    }
    
    /**
    * returns the next date based on the type of recurring task
    */
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    private String getNextRecur(String recur) {
        String[] recurArr = recur.split(" ");
        if (recurArr.length==1) {
            return recur;
        }else {
            int counter = Integer.parseInt(recurArr[1]);
            
            if (counter>2) {
                return recurArr[0] + " " + Integer.toString(counter-1);
            } else {
                return null;
            }
        }
    }

    /**
     * Ensures that every tag in this task:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     */
    private void syncTagsWithMasterList(Task task) {
        final UniqueTagList taskTags = task.getTags();
        tags.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        for (Tag tag : tags) {
            masterTagObjects.put(tag, tag);
        }

        // Rebuild the list of task tags using references from the master list
        final Set<Tag> commonTagReferences = new HashSet<>();
        for (Tag tag : taskTags) {
            commonTagReferences.add(masterTagObjects.get(tag));
        }
        task.setTags(new UniqueTagList(commonTagReferences));
    }

    public boolean removeTask(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.remove(key)) {
            syncRemoveTask(key);
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }
    
    public boolean removeArchive(ReadOnlyTask key) throws ArchiveTaskList.TaskNotFoundException {
        if (archives.remove(key)) {
            return true;
        } else {
            throw new ArchiveTaskList.TaskNotFoundException();
        }
    }
    
    /**
     * marks task as completed by
     * removing the task from tasks and adds into archivedtasks
     * throws TaskNotFoundException
     * throws DuplicateTaskException 
     */
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public boolean markTask(Task key) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.remove(key)) {
            archives.add(key.mark());
            syncRemoveTask(key);
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }
    
    /**
     * marks task as not completed by
     * removing the task from archivedTasks and adds into tasks
     * throws TaskNotFoundException, DuplicateTaskException 
     */
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    public boolean unmarkTask(Task key) throws DuplicateTaskException, ArchiveTaskList.TaskNotFoundException {
        if (archives.remove(key)) {
            tasks.add(key.unmark());
            syncAddTask(key.unmark());
            return true;
        } else {
            throw new ArchiveTaskList.TaskNotFoundException();
        }
    }
    
    /**
     * Synchronize adding of tasks
     */
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    private void syncAddTask(Task task) throws DuplicateTaskException{   
        if (task.isFloating()) {
            floatingTasks.add(task);
        } else if (task.isDeadline()) {
            deadlines.add(task);
        } else if (task.isEvent()) {
            events.add(task);
        }
    }
    
    /**
     * Synchronize removing of tasks
     */
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    private void syncRemoveTask(ReadOnlyTask task) throws TaskNotFoundException{
        if (task.isFloating()) {
            floatingTasks.remove(task);
        } else if (task.isDeadline()) {
            deadlines.remove(task);
        } else if (task.isEvent()) {
            events.remove(task);
        }
    }


//// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

//// util methods

    @Override
    public String toString() {
        return tasks.getInternalList().size() + " tasks, " + tags.getInternalList().size() +  " tags,"
                + archives.getInternalList().size();
    }

    @Override
    public List<ReadOnlyTask> getTaskList() {
        return Collections.unmodifiableList(tasks.getInternalList());
    }
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getFloatingTaskList() {
        return Collections.unmodifiableList(floatingTasks.getInternalList());
    }
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getEventList() {
        return Collections.unmodifiableList(events.getInternalList());
    }
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getDeadlineList() {
        return Collections.unmodifiableList(deadlines.getInternalList());
    }
    
```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getArchiveList() {
        return Collections.unmodifiableList(archives.getInternalList());
    }

    @Override
    public List<Tag> getTagList() {
        return Collections.unmodifiableList(tags.getInternalList());
    }

    @Override
    public UniqueTaskList getUniqueTaskList() {
        return this.tasks;
    }

    @Override
    public UniqueTaskList getUniqueFloatingTaskList() {
        return this.floatingTasks;
    }

    @Override
    public UniqueTaskList getUniqueEventList() {
        return this.events;
    }

    @Override
    public UniqueTaskList getUniqueDeadlineList() {
        return this.deadlines;
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    @Override
    public ArchiveTaskList getUniqueArchiveList() {
        return this.archives;
    }

    @Override
    public UniqueTagList getUniqueTagList() {
        return this.tags;
    }

```
###### /java/harmony/mastermind/model/TaskManager.java
``` java
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskManager // instanceof handles nulls
                && this.tasks.equals(((TaskManager) other).tasks)
                && this.floatingTasks.equals(((TaskManager) other).floatingTasks)
                && this.events.equals(((TaskManager) other).events)
                && this.deadlines.equals(((TaskManager) other).deadlines)
                && this.tags.equals(((TaskManager) other).tags)
                && this.archives.equals(((TaskManager) other).archives));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasks, tags);
    }

    public void searchTask(String keyword, Memory memory) {
        ParserSearch.run(keyword, memory);
        
    }

}
```
###### /java/harmony/mastermind/storage/XmlAdaptedArchive.java
``` java
public class XmlAdaptedArchive {

    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private Date startDate;
    @XmlElement(required = true)
    private Date endDate;
    @XmlElement(required = true)
    private String recur;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedArchive() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedArchive(ReadOnlyTask source) {
        name = source.getName();
        startDate = source.getStartDate();
        endDate = source.getEndDate();
        recur = source.getRecur();
        
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's ReadOnlyTask object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        
        final String name = this.name;
        final Date startDate = this.startDate;
        final Date endDate = this.endDate;
        final String recur = this.recur;
        final UniqueTagList tags = new UniqueTagList(taskTags);
        
        return new Task(name, startDate, endDate, tags, recur).mark();
    }
}
```
###### /java/harmony/mastermind/storage/XmlAdaptedDeadline.java
``` java
public class XmlAdaptedDeadline {

    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private Date endDate;
    @XmlElement(required = true)
    private String recur;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedDeadline() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedDeadline
     */
    public XmlAdaptedDeadline(ReadOnlyTask source) {
        name = source.getName();
        endDate = source.getEndDate();
        recur = source.getRecur();

        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted deadline object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted deadline
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        
        final String name = this.name;
        final Date endDate = this.endDate;
        final String recur = this.recur;
        final UniqueTagList tags = new UniqueTagList(taskTags);
        
        return new Task(name, endDate, tags, recur);
    }
}
```
###### /java/harmony/mastermind/storage/XmlAdaptedEvent.java
``` java
public class XmlAdaptedEvent {

    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private Date startDate;
    @XmlElement(required = true)
    private Date endDate;
    @XmlElement(required = true)
    private String recur;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedEvent() {}


    /**
     * Converts a given event into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedEvent
     */
    public XmlAdaptedEvent(ReadOnlyTask source) {
        name = source.getName();
        startDate = source.getStartDate();
        endDate = source.getEndDate();
        recur = source.getRecur();

        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted event
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        
        final String name = this.name;
        final Date startDate = this.startDate;
        final Date endDate = this.endDate;
        final String recur = this.recur;
        final UniqueTagList tags = new UniqueTagList(taskTags);
        
        return new Task(name, startDate, endDate, tags, recur);
    }
}
```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    public XmlSerializableTaskManager(ReadOnlyTaskManager src) {
        floatingTasks.addAll(src.getFloatingTaskList().stream().map(XmlAdaptedTask::new).collect(Collectors.toList()));
        events.addAll(src.getEventList().stream().map(XmlAdaptedEvent::new).collect(Collectors.toList()));
        deadlines.addAll(src.getDeadlineList().stream().map(XmlAdaptedDeadline::new).collect(Collectors.toList()));
        tags = src.getTagList();
        archives.addAll(src.getArchiveList().stream()
                .map(XmlAdaptedArchive::new).collect(Collectors.toList()));
    }

```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public UniqueTaskList getUniqueTaskList() {
        UniqueTaskList lists = new UniqueTaskList();
        for (XmlAdaptedTask xmlt : floatingTasks) {
            try {
                lists.add(xmlt.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        for (XmlAdaptedEvent xmle : events) {
            try {
                lists.add(xmle.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        for (XmlAdaptedDeadline xmld : deadlines) {
            try {
                lists.add(xmld.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        return lists;
    }

```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public UniqueTaskList getUniqueFloatingTaskList() {
        UniqueTaskList lists = new UniqueTaskList();
        
        for (XmlAdaptedTask xmlt : floatingTasks) {
            try {
                lists.add(xmlt.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        return lists;
    }

```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public UniqueTaskList getUniqueEventList() {
        UniqueTaskList lists = new UniqueTaskList();
        for (XmlAdaptedEvent xmle : events) {
            try {
                lists.add(xmle.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        return lists;
    }

```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public UniqueTaskList getUniqueDeadlineList() {
        UniqueTaskList lists = new UniqueTaskList();
        for (XmlAdaptedDeadline xmld : deadlines) {
            try {
                lists.add(xmld.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        return lists;
    }
    
```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public ArchiveTaskList getUniqueArchiveList() {
        ArchiveTaskList lists = new ArchiveTaskList();
        for (XmlAdaptedArchive p : archives) {
            try {
                lists.add(p.toModelType());
            } catch (IllegalValueException e) {

            }
        }
        return lists;
    }
    
    @Override
    public UniqueTagList getUniqueTagList() {
        try {
            return new UniqueTagList(tags);
        } catch (UniqueTagList.DuplicateTagException e) {
            e.printStackTrace();
            return null;
        }
    }

```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getTaskList() {
        List<ReadOnlyTask> tasks = getFloatingTaskList();
        List<ReadOnlyTask> event = getEventList();
        List<ReadOnlyTask> deadline = getDeadlineList();

        tasks.addAll(event);
        tasks.addAll(deadline);
        
        return tasks;
    }
    
```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getFloatingTaskList() {
        return floatingTasks.stream().map(p -> {
            try {
                return p.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                return null;
            }
        }).collect(Collectors.toCollection(ArrayList::new));
    }
    
```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getEventList() {
        return events.stream().map(p -> {
            try {
                return p.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                return null;
            }
        }).collect(Collectors.toCollection(ArrayList::new));
    }
    
```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getDeadlineList() {
        return deadlines.stream().map(p -> {
            try {
                return p.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                return null;
            }
        }).collect(Collectors.toCollection(ArrayList::new));
    }
    
```
###### /java/harmony/mastermind/storage/XmlSerializableTaskManager.java
``` java
    @Override
    public List<ReadOnlyTask> getArchiveList() {
        return archives.stream().map(p -> {
            try {
                return p.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                return null;
            }
        }).collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public List<Tag> getTagList() {
        return Collections.unmodifiableList(tags);
    }

}
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    /**
     * update the number of task in each tab in the tab title
     */
    private void updateTabTitle() {
        tabLst.get(INDEX_HOME).setText(NAME_TABS[INDEX_HOME] + "(" 
                + logic.getFilteredTaskList().size() + ")");
        tabLst.get(INDEX_TASKS).setText(NAME_TABS[INDEX_TASKS] + "("
                + logic.getFilteredFloatingTaskList().size() + ")");
        tabLst.get(INDEX_EVENTS).setText(NAME_TABS[INDEX_EVENTS] + "("
                + logic.getFilteredEventList().size() + ")");
        tabLst.get(INDEX_DEADLINES).setText(NAME_TABS[INDEX_DEADLINES] + "("
                + logic.getFilteredDeadlineList().size() + ")");
        tabLst.get(INDEX_ARCHIVES).setText(NAME_TABS[INDEX_ARCHIVES] + "("
                + logic.getFilteredArchiveList().size() + ")");
    }
    
    
    @FXML
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initialize() {
        initHomeTab();
        initTaskTab();
        initEventTab();
        initDeadlineTab();
        initArchiveTab();
        
        initAutoComplete();
        
        initActionHistory(actionHistory);
        actionHistory.setPlaceholder(new Label("No action history yet"));
        
        // default focus to cammand box
        Platform.runLater(()->commandField.requestFocus());
    }

    /**
     * Initialise the tasks in the Home tab 
     */
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initHomeTab() {
        initIndex(indexHome);
        initName(taskNameHome);
        initStartDate(startDateHome);
        initEndDate(endDateHome);
        initTags(tagsHome);
        initRecur(recurHome);
    }

    /**
     * Initialise the tasks in the Task tab 
     */
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initTaskTab() {
        initIndex(indexTask);
        initName(taskNameTask);
        initStartDate(startDateTask);
        initEndDate(endDateTask);
        initTags(tagsTask);
        initRecur(recurTask);
    }
    /**
     * Initialise the task in the Event tab 
     */
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initEventTab() {
        initIndex(indexEvent);
        initName(taskNameEvent);
        initStartDate(startDateEvent);
        initEndDate(endDateEvent);
        initTags(tagsEvent);
        initRecur(recurEvent);
    }
    /**
     * Initialise the task in the Deadline tab 
     */
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initDeadlineTab() {
        initIndex(indexDeadline);
        initName(taskNameDeadline);
        initStartDate(startDateDeadline);
        initEndDate(endDateDeadline);
        initTags(tagsDeadline);
        initRecur(recurDeadline);
    }
    /**
     * Initialise the task in the archive tab 
     */
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initArchiveTab() {
        initIndex(indexArchive);
        initName(taskNameArchive);
        initStartDate(startDateArchive);
        initEndDate(endDateArchive);
        initTags(tagsArchive);  
        initRecur(recurArchive);
    }
    
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void initRecur(TableColumn<ReadOnlyTask, Boolean> recurColumn) {
        recurColumn.setGraphic(new ImageView("file:src/main/resources/images/recur_white.png"));
        recurColumn.prefWidthProperty().bind(taskTableHome.widthProperty().multiply(WIDTH_MULTIPLIER_RECUR));
        recurColumn.setCellValueFactory(task -> new SimpleBooleanProperty(task.getValue().isRecur()));
        recurColumn.setCellFactory( col -> new TableCell<ReadOnlyTask, Boolean>(){
            
            @Override
            public void updateItem(Boolean isRecur , boolean isEmpty){
                super.updateItem(isRecur, isEmpty);
                if(!isEmpty()){
                    CheckBox box = new CheckBox();
                    box.setSelected(isRecur);
                    box.setDisable(true);
                    box.setStyle("-fx-opacity: 1");
                    
                    this.setAlignment(Pos.CENTER);
                    this.setGraphic(box);
                }else{
                    this.setGraphic(null);;
                }
            }
        });
    }


    /**
     * Handles all command input keyed in by user
     */
    @FXML
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void handleCommandInputChanged() {
        // Take a copy of the command text
        currCommandText = commandField.getText();
        
        setStyleToIndicateCorrectCommand();
        
        String currentTab = getCurrentTab();
        /*
         * We assume the command is correct. If it is incorrect, the command box
         * will be changed accordingly in the event handling code {@link
         * #handleIncorrectCommandAttempted}
         */
        mostRecentResult = logic.execute(currCommandText, currentTab);
        consoleOutput.setText(mostRecentResult.feedbackToUser);
        
        this.pushToActionHistory(mostRecentResult.title, mostRecentResult.feedbackToUser);

        //updates the tab when a list command is called
        updateTab(mostRecentResult);

        //adds current command into the stack
        updateCommandHistory(currCommandText);

        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }

```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    /**
     * Handles any KeyPress in the commandField
     */
    @FXML
    private void handleKeyPressed(KeyEvent event) {
        KeyCode key = event.getCode();
        switch (key) {
            case UP:    restorePrevCommandText();
                        return;
            case DOWN:  restoreNextCommandText();
                        return;
            case ENTER: learnWord(commandField.getText());
                        return;
        }
        
        if (CTRL_ONE.match(event)) {
            updateTab(ListCommand.MESSAGE_SUCCESS);
        }else if (CTRL_TWO.match(event)) {
            updateTab(ListCommand.MESSAGE_SUCCESS_TASKS);
        }else if (CTRL_THREE.match(event)) {
            updateTab(ListCommand.MESSAGE_SUCCESS_EVENTS);
        }else if (CTRL_FOUR.match(event)) {
            updateTab(ListCommand.MESSAGE_SUCCESS_DEADLINES);
        }else if (CTRL_FIVE.match(event)) {
            updateTab(ListCommand.MESSAGE_SUCCESS_ARCHIVES);
        }
    }
    
    @FXML
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void updateTab(CommandResult result) {
        String tab = result.toString();
        updateTab(tab);
    }
    
    @Subscribe
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void handleTaskManagerChanged(TaskManagerChangedEvent event) {
        updateTabTitle();
    }
    
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    //updates the tab if list/upcoming command is used
    /**
     * handle the switching of tabs
     */
    private void updateTab(String result) {
        switch (result) {
            case ListCommand.MESSAGE_SUCCESS:               tabPane.getSelectionModel().select(INDEX_HOME);
                        
                                                            break;
            case UpcomingCommand.MESSAGE_SUCCESS_UPCOMING:  tabPane.getSelectionModel().select(INDEX_HOME);
                                                            break;
            case ListCommand.MESSAGE_SUCCESS_TASKS:         tabPane.getSelectionModel().select(INDEX_TASKS);
                                                            break;
            case ListCommand.MESSAGE_SUCCESS_EVENTS:        tabPane.getSelectionModel().select(INDEX_EVENTS);
                                                            break;
            case ListCommand.MESSAGE_SUCCESS_DEADLINES:     tabPane.getSelectionModel().select(INDEX_DEADLINES);
                                                            break;
            case ListCommand.MESSAGE_SUCCESS_ARCHIVES:      tabPane.getSelectionModel().select(INDEX_ARCHIVES);
                                                            break;
        }
    }
    
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    /**
     * Adds recent input into stack
     */
    private void updateCommandHistory(String command) {
        commandHistory.push(command);
        commandIndex = commandHistory.size();
    }

```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private String getPrevCommandHistory() {
        if (commandHistory.empty()) {
            return null;
        }else if (commandIndex == 0) {
            return null;
        }else {
            commandIndex--;
            return commandHistory.get(commandIndex);
        }
    }
    
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private String getNextCommandHistory() {
        if (commandHistory.empty()) {
            return null;
        }else if (commandIndex >= commandHistory.size()-1) {
            return null;
        }else {
            commandIndex++;
            return commandHistory.get(commandIndex);
        }
    }
    
    public void disposeAutoCompleteBinding(){
        this.autoCompletionBinding.dispose();
    }
    
    @Subscribe
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Invalid command: " + currCommandText));
        restoreCommandText();
    }
    
    /**
     * Sets the command box style to indicate a correct command.
     */
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void setStyleToIndicateCorrectCommand() {
        commandField.setText("");
    }

```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void restoreCommandText() {
        commandField.setText(currCommandText);
    }
    
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void restorePrevCommandText() {
        String prevCommand = getPrevCommandHistory();
        if (prevCommand!=null) {
            //need to wrap in runLater due to concurrency threading in JavaFX
            Platform.runLater(new Runnable() {
                public void run() {
                    commandField.setText(prevCommand);
                    commandField.positionCaret(prevCommand.length());
                }
            });
        }//else ignore
    }
    
```
###### /java/harmony/mastermind/ui/MainWindow.java
``` java
    private void restoreNextCommandText() {
        String nextCommand = getNextCommandHistory();
        //need to wrap in runLater due to concurrency threading in JavaFX
        Platform.runLater(new Runnable() {
            public void run() {
                if (nextCommand!=null) {
                    commandField.setText(nextCommand);
                    commandField.positionCaret(nextCommand.length());
                }else {
                    commandField.setText("");
                }
            }
        });
    }
}
```
